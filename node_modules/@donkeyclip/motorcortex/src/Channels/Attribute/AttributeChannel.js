/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { getLaneKey } from '../../_coreUtils/helper';
import Channel from '../Channel';
import LanesHandler from './LanesHandler';
import IReMa from './helpers/IReMa';

import { _FWDS, _BWDS } from './helpers/_CONST';

function executeSubscriber(periodSubs) {
  if (periodSubs) {
    const keys = Object.keys(periodSubs);
    for (let j = 0; j < keys.length; j++) {
      periodSubs[keys[j]]();
    }
  }
}

class AttributeChannel extends Channel {
  constructor(props) {
    super(props);

    /*
        comboAttributes are attributes of type object, holding a number of other attributes.
        E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs
        in an object format keeping the value of each attribute at any given point.
        Combo attributes are passed on the constructor of the Channel in the format:
        props.comboAttributes: {
            transition: ['translateX', 'translateY', ...],
            <something_else>: ['<attrName1>', '<attrName2>', ...]
        }
        */
    this.comboAttributes = props.comboAttributes ?? {};

    /**
     * For incidents that do not have animatedAttrs there should be only one lane per element.
     * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
     * up with just one lane per element: <element_id>_<this.fixedAttributeName>
     */
    this.fixedAttributeName = '_';

    this.LanesHandler = new LanesHandler({
      comboAttributes: this.comboAttributes,
    });

    this.irema = new IReMa();

    this.direction = _FWDS;
  }

  static type = 'attributes';

  get lanes() {
    return this.LanesHandler.lanes;
  }

  get incidentsById() {
    return this.LanesHandler.incidentsById;
  }

  _resize(durationFraction) {
    this.LanesHandler._resize(durationFraction);
  }

  /* *******************************************************
    DECISION METHODS
  ******************************************************* */
  /**
   * All of the incidents coming to this method are element-attribute incidents meaning that they only
   * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
   * object
   *
   * @param {array} incidents - A collection of Incidents in the form:
   * {
   *  millisecond
   *  incident
   *  id
   * }
   * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
   *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
   *  but will also include an errors array on its return and also will only include the success callbacks on
   *  the execute key of its return
   * @returns either:
   *   {
   *       result:true,
   *       execute: // an array of functions that when executed it will add the Incidents on the Channels
   *   }
   *   or
   *   {
   *       result: false,
   *       errors
   *   }
   */
  checkAddition(incidents, type = 'all-or-nothing') {
    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
    /* an array where we keep all affected lanes so we can slip on them at the end.
    The format for each affected lane we keep is:
    {
        mcid: mcid,
        attribute: attribute
    }
    */
    const affectedLanes = [];

    // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
    // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
    // Because LanesSandboxHandler is only there for testing we don't want to execute these changes
    // during checks but still we need to do so on success. For this, the onSuccessActions array holds all executable
    // functions retured by various LanesHandlerSanbox functions so it can execute them on success.
    const onSuccessActions = [];

    const conflicts = [];
    for (let i = 0; i < incidents.length; i++) {
      let incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not
      const laneItem = incidents[i]; // in the form {millisecond, parentMillisecond, incident, id}
      const { incident } = laneItem; // the ContextAwareIncident of our MonoIncident
      let { mcid, attribute } = incident;
      attribute ||= this.fixedAttributeName; // the attribute of the MonoIncident

      // maybe it has to
      LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

      affectedLanes.push({
        mcid,
        attribute,
      });

      // **** if the lane did exist before the new addition check for conflicts
      const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(
        laneItem,
        mcid,
        attribute,
      );

      // helper.log(overlappingAnim)
      if (overlappingAnims.length > 0) {
        const overlappingIncident = this.incidentsById[overlappingAnims[0].id];
        incidentConflicts = true;
        conflicts.push({
          type: 'unauthorised, overlapping incidents on the same element',
          element_mcid: mcid,
          attribute,
          millisecond: overlappingAnims[0].millisecond,
          incident: overlappingIncident
            ? {
                attrs: overlappingIncident.DescriptiveIncident.attrs,
                props: overlappingIncident.DescriptiveIncident.props,
                duration: overlappingIncident.duration,
              }
            : undefined,
        });
      }

      if (!incidentConflicts) {
        const executables = LanesHandlerSandbox.addElementToLane(
          mcid,
          attribute,
          laneItem.millisecond,
          incident,
        );
        onSuccessActions.push(() => {
          for (let j = 0; j < executables.length; j++) {
            executables[j]();
          }
          incident._onGetContextOnce();
        });
      }
    } // end for each incident

    // if we have conflicts and the type = "all-or-nothing"
    if (conflicts.length > 0 && type === 'all-or-nothing') {
      return {
        result: false,
        errors: conflicts,
      };
    }

    // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
    // This callback will apply all passing additions.

    // success message
    const lanesHandler = this.LanesHandler;
    const exec = function execFunct() {
      for (let i = 0; i < affectedLanes.length; i++) {
        const laneKey = getLaneKey(
          affectedLanes[i].mcid,
          affectedLanes[i].attribute,
        );
        const sortedLane = LanesHandlerSandbox.lanes[laneKey].exportFlattened();

        sortedLane.sort((a, b) => a.millisecond - b.millisecond);

        LanesHandlerSandbox.lanes.setValue(laneKey, sortedLane);
      }
      for (let i = 0; i < onSuccessActions.length; i++) {
        onSuccessActions[i]();
      }
      lanesHandler.applySandboxChanges(LanesHandlerSandbox);
    };

    return {
      result: true,
      errors: conflicts,
      execute: exec,
    };
  }

  /**
   * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
   * that apply the change
   * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
   * @param {number} millisecondsDelta - the milliseconds delta to apply to the incidents
   * @returns {object} -
   * either:
      {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
      }
    or
      {
        result: false,
        errors: // an array including all the errors / conflicts found on edit
      }
   */
  checkEdit(incidents, millisecondsDelta) {
    const affectedIncidentIds = [];
    for (let i = 0; i < incidents.length; i++) {
      affectedIncidentIds.push(incidents[i].id);
    }

    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

    const conflicts = [];

    // for each of the affectedAnimations
    for (let i = 0; i < incidents.length; i++) {
      let {
        incident: { id: incidentId, mcid, attribute },
      } = incidents[i];

      attribute ||= this.fixedAttributeName;

      const lane = LanesHandlerSandbox.getLane(mcid, attribute);

      // check for conflicts and edit lane items millisecond
      for (let k = 0; k < lane.length; k++) {
        if (lane[k].id === incidentId) {
          const affectedAnim = lane[k];
          const testLaneElement = { ...affectedAnim };
          testLaneElement.millisecond += millisecondsDelta;
          testLaneElement.incident =
            LanesHandlerSandbox.incidentsById[testLaneElement.id];
          const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(
            testLaneElement,
            mcid,
            attribute,
            affectedIncidentIds,
          );

          if (overlappingAnims.length > 0) {
            conflicts.push({
              type: 'unauthorised, overlapping animations on the same element',
              meta: {
                element_mcid: mcid,
                attribute,
                newAnimation: testLaneElement,
                overlappingAnims,
              },
            });
          }

          break;
        } // end of if we found the specific animation on the lane's sequence
      } // end of each lane's item
    } // end for each affected animation's id

    if (conflicts.length > 0) {
      return {
        result: false,
        errors: conflicts,
      };
    }

    const that = this;
    const exec = function execFunct() {
      that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);
      that.irema.reset();
    };
    return {
      result: true,
      execute: exec,
    };
  }

  /**
   * @param {array} incidents - [{id, start, end, startDelta}]
   * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
   *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
   * */
  checkResizedIncidents(incidents, fullChannelResize = false) {
    const excludeIdsFromCheck = [];
    for (let i = 0; i < incidents.length; i++) {
      excludeIdsFromCheck.push(incidents[i].id);
    }

    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

    const conflicts = [];

    // for each of the incidents passed
    for (let i = 0; i < incidents.length; i++) {
      // get the ContextAwareIncident
      let { mcid, attribute } =
        this.LanesHandler.incidentsById[incidents[i].id];
      attribute ||= this.fixedAttributeName;

      const lane = LanesHandlerSandbox.getLane(mcid, attribute);
      const testDuration = incidents[i].end - incidents[i].start;

      // check for conflicts and edit lane items millisecond
      for (let k = 0; k < lane.length; k++) {
        if (lane[k].id !== incidents[i].id) {
          continue;
        }

        if (fullChannelResize) {
          break;
        }
        const testLaneElement = { ...lane[k] };
        testLaneElement.millisecond += incidents[i].startDelta;
        testLaneElement.incident =
          LanesHandlerSandbox.incidentsById[testLaneElement.id];
        const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(
          testLaneElement,
          mcid,
          attribute,
          excludeIdsFromCheck,
          testDuration,
        );

        if (overlappingAnims.length > 0) {
          conflicts.push({
            type: 'unauthorized overlapping animations on the same element',
            meta: {
              element_mcid: mcid,
              attribute,
              newAnimation: testLaneElement,
              overlappingAnims,
            },
          });
        }
      } // end of each lane's item
    } // end for each affected animation's id

    if (conflicts.length > 0) {
      return {
        result: false,
        errors: conflicts,
      };
    }

    const that = this;

    const exec = function execFunct() {
      // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
      // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
      // success message
      for (let i = 0; i < incidents.length; i++) {
        that.LanesHandler.updateLane(
          [incidents[i].id],
          incidents[i].startDelta,
        );
      }
      that.irema.reset();
    };

    return {
      execute: exec,
      result: true,
    };
  }

  /**
   *
   */
  checkDelete(removedAnimations) {
    const removedAnimationIds = [];
    for (let i = 0; i < removedAnimations.length; i++) {
      removedAnimationIds.push(removedAnimations[i].id);
    }

    const that = this;
    const exec = function execFunct() {
      that.LanesHandler.deleteAnimations(removedAnimationIds);
      that.irema.reset();
    };

    return {
      result: true,
      execute: exec,
    };
  }

  /**
   * This method is responsible for recalculating the scratch values of the first
   * Incident of each of the lanes of the LanesHandler according to the provided
   * context id
   * */
  recalcScratchValues(contextId) {
    this.LanesHandler.recalcScratchValues(contextId);
  }

  /**
   * Slips to just one lane forwards
   * @param {string} laneid - the id of the lane
   * @param {array} lane - the lane to slip into
   * @param {number} from - the millisecond the slip starts from
   * @param {number} to - the target millisecond of the slip
   * @param {string} contextId - the contextId of the Incidents to slip
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  slipIntoLaneForwards(laneid, lane, from, to, contextId, forceReset = false) {
    if (to === 0 && !forceReset) {
      return true;
    }
    // this flag indicates whether the lane should be included on the next circle or not
    let includeOnNextIteration = true;

    const participatingAnims = [];
    const lastAffectedIndex = this.LanesHandler.getLastAffectedIndex(
      contextId,
      laneid,
      forceReset,
    );
    let newLastAffectedIndex = lastAffectedIndex[0];
    let endingPoint = lastAffectedIndex[1];

    let lastParticipatingFinished = false;

    for (let i = lastAffectedIndex[0]; i < lane.length; i++) {
      const laneItem = lane[i];

      if (laneItem.millisecond >= to) {
        // if the next Incident is outside the from-to area, further down
        if (!forceReset || i === 0) {
          const threshold = Math.floor(
            laneItem.millisecond / this.irema.subPeriod,
          );
          this.irema.subscribe(contextId, _FWDS, threshold, laneid, lane);
        }
        includeOnNextIteration = false;
        break;
      } else if (endingPoint <= from) {
        // this case is for lanes that have completed their forwards execution
        if (i < lane.length - 1) {
          // for direction changes
          if (lane[i + 1].millisecond < to) {
            endingPoint =
              this.incidentsById[lane[i + 1].id].duration +
              lane[i + 1].millisecond;
          }
        } else {
          includeOnNextIteration = false;
        }
      } else if (endingPoint >= from && endingPoint <= to) {
        // the end of the Incident is within from-to
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = true;
        if (i < lane.length - 1) {
          endingPoint =
            this.incidentsById[lane[i + 1].id].duration +
            lane[i + 1].millisecond;
        } else {
          includeOnNextIteration = false;
        }
      } else {
        // to is within Incident
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = false;
        break;
      }
    }

    if (newLastAffectedIndex !== lastAffectedIndex[0]) {
      this.LanesHandler.setLastAffectedIndex(
        contextId,
        laneid,
        newLastAffectedIndex,
      );
    }

    if (participatingAnims.length === 0) {
      // there are two cases forceReset can be used: a) when we are flashing the Clip
      // going from 0 to millisecond via flash method of ExtendableClip or when
      // we want to seek the Clip without executing it (like it was in transitional state)
      // we diferentiate the two by the from value which in case (a) is always 0
      if (!!forceReset && from === 0) {
        const firstIncident = this.incidentsById[lane[0].id];
        firstIncident.onProgress(0, contextId);
        return true;
      }
      return includeOnNextIteration;
    }

    // We only care about the last (in chronological order) Incident, as this
    // will define the final value
    const lastIndex = participatingAnims.length - 1;
    const participatingAnim =
      this.incidentsById[participatingAnims[lastIndex].id];

    const startMillisecond = participatingAnims[lastIndex].millisecond;

    // if the animation ends before the target millisecond
    // and it's the last one on the row
    let end = !lastParticipatingFinished
      ? to - startMillisecond
      : participatingAnim._duration;
    participatingAnim.onProgress(end, contextId);
    return includeOnNextIteration;
  }

  /**
   * Slips to just one lane backwards
   * @param {string} laneid - the id of the lane
   * @param {array} lane - the lane to slip into
   * @param {number} from - the millisecond the slip starts from
   * @param {number} to - the target millisecond of the slip
   * @param {string} contextId - the contextId of the Incidents to slip
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  slipToLaneBackwards(laneid, lane, from, to, contextId) {
    let includeOnNextIteration = true;

    const participatingAnims = [];
    const lastAffectedIndex = this.LanesHandler.getLastAffectedIndex(
      contextId,
      laneid,
    );
    let newLastAffectedIndex = lastAffectedIndex[0];
    let endingPoint = lastAffectedIndex[1];

    let lastParticipatingFinished = false;

    for (let i = lastAffectedIndex[0]; i >= 0; i--) {
      const laneItem = lane[i];

      if (endingPoint < to) {
        // if the next Incident is outside the from-to area, further down
        const threshold = Math.floor(endingPoint / this.irema.subPeriod);
        this.irema.subscribe(contextId, _BWDS, threshold, laneid, lane);
        includeOnNextIteration = false;
        break;
      } else if (laneItem.millisecond > from) {
        // this case is for lanes that have completed their backwards execution
        if (i > 0) {
          // for direction changes
          if (
            lane[i - 1].millisecond +
              this.incidentsById[lane[i - 1].id].duration <
            to
          ) {
            endingPoint =
              this.incidentsById[lane[i - 1].id].duration +
              lane[i - 1].millisecond;
          }
        } else {
          includeOnNextIteration = true;
        }
      } else if (laneItem.millisecond <= from && laneItem.millisecond > to) {
        // the start of the Incident is within from-to
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = true;
        if (i > 0) {
          endingPoint =
            this.incidentsById[lane[i - 1].id].duration +
            lane[i - 1].millisecond;
        } else {
          includeOnNextIteration = false;
        }
      } else {
        // to is within Incident
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = false;
        break;
      }
    }

    if (newLastAffectedIndex !== lastAffectedIndex[0]) {
      this.LanesHandler.setLastAffectedIndex(
        contextId,
        laneid,
        newLastAffectedIndex,
      );
    }

    if (participatingAnims.length === 0) {
      return true;
    }
    // We only care about the last (in chronological order) Incident, as this
    // will define the final value
    const lastIndex = participatingAnims.length - 1;
    const participatingAnim =
      this.incidentsById[participatingAnims[lastIndex].id];

    const startMillisecond = participatingAnims[lastIndex].millisecond;

    // if the animation starts before the target millisecond
    // and it's the last one on the row
    let end = !lastParticipatingFinished ? to - startMillisecond : 0;

    participatingAnim.onProgress(end, contextId);
    return includeOnNextIteration;
  }

  /**
    @param {number} from - the millisecond to start from
    @param {number} to - the millisecond to go to
    @param {string} contextId - the context id to "move"
    @param {boolean} forceReset - set to true if status recalc is needed after edit
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  moveTo(from, to, contextId, forceReset = false) {
    const direction = to >= from ? _FWDS : _BWDS; // TODO possible solution on 0-0 bug
    const executionSubscribers = this.irema.executionSubscribers(
      contextId,
      direction,
    );

    if (forceReset || direction !== this.direction) {
      this.irema._nextIterationLanes = {}; // it might not needed
    }
    const currentNextIterationLanes = this.irema.nextIterationLanes(
      contextId,
      this.lanes,
    );
    const currentPeriod = this.irema.currentPeriod(contextId);
    const newPeriod = Math.floor(to / this.irema.subPeriod);

    if (direction === _FWDS) {
      for (let i = currentPeriod; i <= newPeriod; i++) {
        executeSubscriber(executionSubscribers[i]);
      }
    } else {
      for (let i = currentPeriod; i >= newPeriod; i--) {
        executeSubscriber(executionSubscribers[i]);
      }
    }

    // step 1: iterate through all lanes
    const nextIterationLanes = {};
    const laneKeys = Object.keys(currentNextIterationLanes);
    const funcToRun =
      direction === _FWDS
        ? this.slipIntoLaneForwards.bind(this)
        : this.slipToLaneBackwards.bind(this);
    for (let i = 0; i < laneKeys.length; i++) {
      const lane = this.lanes[laneKeys[i]];
      const res = funcToRun(laneKeys[i], lane, from, to, contextId, forceReset);
      if (res) {
        nextIterationLanes[laneKeys[i]] = lane;
      }
    }
    this.irema.setCurrentPeriod(contextId, newPeriod);
    this.irema.setNextIterationLanes(contextId, nextIterationLanes);
    this.direction = direction;
  }
}

export default AttributeChannel;
