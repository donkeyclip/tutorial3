/* eslint-disable sonarjs/no-duplicate-string */
import { Effect, HTMLClip, loadPlugin } from '../../../main';
import expect from 'expect';
import { _FWDS } from '../helpers/_CONST';
import _BWDS from '../../../../dist/motorcortex.esm';

const attrs1000 = '{"animatedAttrs":{"test":1000}}';
const attrs500 = '{"animatedAttrs":{"test":500}}';

const element1 = 'element-1';
const element2 = 'element-2';
const element3 = 'element-3';

const el1Lane = 'element-1___test';
const el2Lane = 'element-2___test';
const el3Lane = 'element-3___test';

const pluginName = '@test/plugin';
const attrName = 'test';
const clipid = 'my-clip';

let element1Counter = 0;
let element2Counter = 0;
let element3Counter = 0;
/** ************************* PLUGIN DEFINITION ************************ */
/** ******************************************************************* */
let log = [];
let AttributeChannel, Irema;

class DataAttr extends Effect {
  onGetContext() {}

  // eslint-disable-next-line no-unused-vars
  onProgress(ms) {
    const fraction = this.getFraction(ms);
    log.push({
      id: this.DescriptiveIncident.id,
      attrs: JSON.stringify(this.attrs),
      elementid: this.element.id,
      targetValue: this.targetValue,
      fraction,
    });
    const { initialValue } = this;
    const { targetValue } = this;
    const value = initialValue + (targetValue - initialValue) * fraction;

    this.element.setAttribute(this.attributeKey, value);
  }

  getScratchValue() {
    // eslint-disable-line no-unused-vars
    return 0;
  }
}

const testPlugin = {
  npm_name: pluginName,
  name: 'Test Plugin',
  incidents: [
    {
      exportable: DataAttr,
      name: 'DataAttr',
    },
  ],
};

const TestPlugin = loadPlugin(testPlugin);
const DataAttrInc = TestPlugin.DataAttr;

function createIncident(
  value,
  selector,
  duration,
  delay = 0,
  hiatus = 0,
  repeats = 1,
) {
  let id;
  switch (selector) {
    case element1:
      id = `${element1}-${element1Counter++}`;
      break;
    case element2:
      id = `${element2}-${element2Counter++}`;
      break;
    case element3:
      id = `${element3}-${element3Counter++}`;
      break;
  }

  return new DataAttrInc(
    {
      animatedAttrs: {
        [attrName]: value,
      },
    },
    {
      selector: `#${selector}`,
      duration,
      delay,
      hiatus,
      repeats,
      id,
    },
  );
}

let clip;
test('STL01. Go forwards by 50ms', () => {
  document.body.innerHTML = '<div id="clip-container"></div>';

  clip = new HTMLClip({
    html: `
      <div id="my-root-div">
          <div id="${element1}" class="my-class" data-motorcortex2-id="${element1}" ${attrName}="0"></div>
          <div id="${element2}" class="my-class" data-motorcortex2-id="${element2}" ${attrName}="0"></div>
          <div id="${element3}" class="my-class" data-motorcortex2-id="${element3}" ${attrName}="0"></div>
      </div>`,
    css: `
      #my-root-div {
          width: 800px;
          height: 400px;
      }
      .my-class {
          display: inline-block;
          width: 50%;
          height: 100%;
      }
        `,
    host: document.querySelector('#clip-container'),
    id: clipid,
  });

  let totalRes = true;
  /************ element1 ********************/
  totalRes &&= clip.addIncident(createIncident(500, element1, 100), 100).result;
  totalRes &&= clip.addIncident(createIncident(1000, element1, 100), 0).result;
  totalRes &&= clip.addIncident(
    createIncident(2000, element1, 100),
    200,
  ).result;
  totalRes &&= clip.addIncident(createIncident(0, element1, 100), 300).result;

  /************ element2 ********************/
  totalRes &&= clip.addIncident(createIncident(500, element2, 100), 400).result;
  totalRes &&= clip.addIncident(createIncident(0, element2, 100), 700).result;
  totalRes &&= clip.addIncident(
    createIncident(1000, element2, 100),
    800,
  ).result;
  totalRes &&= clip.addIncident(
    createIncident(2000, element2, 100, 0, 100),
    900,
  ).result;

  /************ element3 ********************/
  totalRes &&= clip.addIncident(
    createIncident(1000, element3, 200, 100, 0, 2),
    500,
  ).result;
  totalRes &&= clip.addIncident(
    createIncident(500, element3, 100),
    1400,
  ).result;

  expect(totalRes).toBe(true);

  AttributeChannel = clip.realClip.instantiatedChannels[pluginName];
  Irema = AttributeChannel.irema;
  log = [];
  clip.playableProgress(50 / clip.duration, 50);

  /*********************** values *******************************************/
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(500);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(0);

  /************************** log & other meta ****************************/
  expect(log).toEqual([
    {
      id: 'element-1-1',
      attrs: attrs1000,
      elementid: 'element-1',
      targetValue: 1000,
      fraction: 0.5,
    },
  ]);
  expect(clip.realClip.runTimeInfo.currentMillisecond).toBe(50);
  expect(clip.runTimeInfo.currentMillisecond).toBe(50);

  /***************** next iteration lanes and subscribers *********************/
  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _FWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([el1Lane]);
  expect(Object.keys(subs)).toEqual(['0', '10', '40', '50']);
  expect(Object.keys(subs['0'])).toEqual([el1Lane]);
  expect(Object.keys(subs['40'])).toEqual([el2Lane]);

  /***************************** lastAffectedIndex ***************************/
  expect(Object.keys(subs['50'])).toEqual([el3Lane]);
  const nextEl1 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el1Lane,
  );
  const nextEl2 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el2Lane,
  );
  const nextEl3 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el3Lane,
  );
  expect(nextEl1).toEqual([0, 100]);
  expect(nextEl2).toEqual([0, 500]);
  expect(nextEl3).toEqual([0, 1100]);
});

test('STL02. slip forwards to the limit of end and start of incidents', () => {
  log = [];
  clip.playableProgress(400 / clip.duration, 400);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(0);

  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _FWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([]);
  expect(Object.keys(subs)).toEqual(['0', '10', '40', '50']);
  expect(Object.keys(subs['0'])).toEqual([el1Lane]);
  expect(Object.keys(subs['40'])).toEqual([el2Lane]);
  expect(Object.keys(subs['50'])).toEqual([el3Lane]);
  expect(log).toEqual([
    {
      id: 'element-1-3',
      attrs: '{"animatedAttrs":{"test":0}}',
      elementid: 'element-1',
      targetValue: 0,
      fraction: 1,
    },
  ]);

  /***************************** lastAffectedIndex ***************************/
  const nextEl1 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el1Lane,
  );
  const nextEl2 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el2Lane,
  );
  const nextEl3 = AttributeChannel.LanesHandler.getLastAffectedIndex(
    clipid,
    el3Lane,
  );
  expect(nextEl1).toEqual([3, 400]);
  expect(nextEl2).toEqual([0, 500]);
  expect(nextEl3).toEqual([0, 1100]);
});

test('STL03. slip forwards on the delay of Incident', () => {
  log = [];
  clip.playableProgress(550 / clip.duration, 550);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(500);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(log).toEqual([
    {
      id: 'element-2-0',
      attrs: attrs500,
      elementid: 'element-2',
      targetValue: 500,
      fraction: 1,
    },
    {
      id: 'element-3-0',
      attrs: attrs1000,
      elementid: 'element-3',
      targetValue: 1000,
      fraction: 0,
    },
  ]);

  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _FWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([el3Lane]);
  expect(Object.keys(subs)).toEqual(['0', '10', '40', '50', '70']);
  expect(Object.keys(subs['0'])).toEqual([el1Lane]);
  expect(Object.keys(subs['40'])).toEqual([el2Lane]);
  expect(Object.keys(subs['50'])).toEqual([el3Lane]);
  expect(Object.keys(subs['70'])).toEqual([el2Lane]);
});

test('STL04. slip forwards on an idle point of clip', () => {
  log = [];
  clip.playableProgress(1200 / clip.duration, 1200);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(2000);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(1000);
  expect(log).toEqual([
    {
      id: 'element-3-0',
      attrs: attrs1000,
      elementid: 'element-3',
      targetValue: 1000,
      fraction: 1,
    },
    {
      id: 'element-2-3',
      attrs: '{"animatedAttrs":{"test":2000}}',
      elementid: 'element-2',
      targetValue: 2000,
      fraction: 1,
    },
  ]);

  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _FWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([]);
  expect(Object.keys(subs)).toEqual(['0', '10', '40', '50', '70', '140']);
  expect(Object.keys(subs['0'])).toEqual([el1Lane]);
  expect(Object.keys(subs['40'])).toEqual([el2Lane]);
  expect(Object.keys(subs['50'])).toEqual([el3Lane]);
  expect(Object.keys(subs['70'])).toEqual([el2Lane]);
  expect(Object.keys(subs['140'])).toEqual([el3Lane]);
});

test('STL05. slip backwards on an the middle of incidents', () => {
  log = [];
  clip.playableProgress(150 / clip.duration, 150);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(750);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(log).toEqual([
    {
      id: 'element-1-0',
      attrs: attrs500,
      elementid: 'element-1',
      targetValue: 500,
      fraction: 0.5,
    },
    {
      id: 'element-2-0',
      attrs: attrs500,
      elementid: 'element-2',
      targetValue: 500,
      fraction: 0,
    },
    {
      id: 'element-3-0',
      attrs: attrs1000,
      elementid: 'element-3',
      targetValue: 1000,
      fraction: 0,
    },
  ]);

  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _BWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([el1Lane]);
  expect(Object.keys(subs)).toEqual([]);
});

test('STL06. slip backwards on a subsequent Incident', () => {
  log = [];
  clip.playableProgress(50 / clip.duration, 50);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element1).getAttribute(attrName),
    ),
  ).toBe(500);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element2).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(
    parseInt(
      clip.realClip.context.getElementByMCID(element3).getAttribute(attrName),
    ),
  ).toBe(0);
  expect(log).toEqual([
    {
      id: 'element-1-1',
      attrs: '{"animatedAttrs":{"test":1000}}',
      elementid: 'element-1',
      targetValue: 1000,
      fraction: 0.5,
    },
  ]);

  const nextIterationLanes = Irema.nextIterationLanes(clipid, {});
  const subs = Irema.executionSubscribers(clipid, _BWDS);
  expect(Object.keys(nextIterationLanes)).toEqual([el1Lane]);
  expect(Object.keys(subs)).toEqual([]);
});
