/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import {
  getLaneKey,
  getMCIDandAttrOutOfLaneKey,
  hasOwnProp,
} from '../../_coreUtils/helper';
import createProxy from '../../_coreUtils/proxies/ObjectProxy/ObjectProxy';
import setInitialValueForCombo from './helpers/ComboAttrsCascading';

class LanesHandler {
  constructor(props = {}) {
    /**
     * Keeps the lanes of the Channel in the form:
     * {
     *  <motorcortex-id>_<attribute>: [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
     * }
    /** @type {{}}
     */
    this.lanes = {};
    if (props.lanes) {
      this.lanes = props.lanes;
    }

    /**
     * An object that will will hold the index of the last animated item of the lane per contextid
     * This information is useful for the faster identification of the items that should
     * be animated when progressing from ms1 to ms2
     * The information will be kept in the form:
     * {
     *   <contextid>: {
     *    {
     *      <lane_id>: <index>,
     *      ...
     *    }
     *  }
     * @type {{}}
     */
    this.lastAnimatedItemPerLane = {};

    this.comboAttributes = {};
    if (props.comboAttributes != null) {
      this.comboAttributes = props.comboAttributes;
    }

    /**
      Keeps an indexing of the lanes each Animation belongs to. The form is the following:
      belongingLaneKeysByAnimationId: {
          <animation_id>: [laneKey1, laneKey2, ...],
          <animation_id>: [laneKey2, laneKey3, ...],
          ...
      }
     * @type {{}}
    */
    this.belongingLaneKeysByAnimationId = {};
    if (props.belongingLaneKeysByAnimationId) {
      this.belongingLaneKeysByAnimationId =
        props.belongingLaneKeysByAnimationId;
    }

    /*
        keeps all Incidents (that appear on the lanes) mapped on a key - value pair
        object on which the keys are the ids and the values the corresponding Incidents.
        The Incidents of this object are ContextAwareIncidents
        */
    this.incidentsById = {}; // we need to keep this
    if (props.incidentsById) {
      this.incidentsById = props.incidentsById;
    }
  }

  /**
   * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
   * No checks are performed.
   * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
   * run.
   * @param {number} durationFraction: the fraction between the new duration and the current
   */
  _resize(durationFraction) {
    const keys = Object.keys(this.lanes); //._keys();

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const theLane = this.lanes[key];
      for (let j = 0; j < theLane.length; j++) {
        theLane[j].millisecond = theLane[j].millisecond * durationFraction;
      }
    }
  }

  /**
   * it creates a new LanesHandler that acts as a sanbox for testing changes
   */
  createTestLanesSanbox() {
    const props = {
      lanes: createProxy(this.lanes),
      belongingLaneKeysByAnimationId: createProxy(
        this.belongingLaneKeysByAnimationId,
      ),
      incidentsById: { ...this.incidentsById },
    };

    if (this.comboAttributes) {
      props.comboAttributes = this.comboAttributes;
    }

    return new LanesHandler(props);
  }

  getLane(mcid, attr) {
    return this.lanes[getLaneKey(mcid, attr)];
  }

  applySandboxChanges(SanboxObject) {
    this.lanes = SanboxObject.lanes.exportFlattened();

    this.belongingLaneKeysByAnimationId =
      SanboxObject.belongingLaneKeysByAnimationId.exportFlattened();
    this.incidentsById = { ...SanboxObject.incidentsById };
  }

  /**
   * return true if lane exists or false otherwise
   * @param {String} mcid
   * @param {String} attr
   * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false
   */
  laneExists(mcid, attr, ifNotCreateIt = false) {
    const laneKey = getLaneKey(mcid, attr);

    // TODO: Figure out why using the hasOwnProp here breaks the tests
    // eslint-disable-next-line no-prototype-builtins
    if (this.lanes.hasOwnProperty(laneKey)) {
      return true;
    }

    if (ifNotCreateIt) {
      this.lanes.setValue(laneKey, []);
    }
    return false;
  }

  /**
   * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
   * @param {string} mcid
   * @param {String} attr
   * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
   *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
   *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
   *  of them together guarantees that there is going to be no conflict between them even after the edit
   * @param {Number} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
   *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)
   * @retuns {array} - a list of all overlapping animations of the lane
   */
  getOverlappingAnims(
    { millisecond, incident },
    mcid,
    attr,
    excludeIdsFromCheck = [],
    testDuration = null,
  ) {
    const lane = this.lanes[getLaneKey(mcid, attr)];
    if (!lane) return [];
    const arr = [];
    for (let i = 0; i < lane.length; i++) {
      const existingAnim = lane[i];
      let durationToUseOnChecks = testDuration ?? incident.duration;
      const duration = this.incidentsById[existingAnim.id].duration;
      if (
        existingAnim.id !== incident.id &&
        !excludeIdsFromCheck.includes(existingAnim.id) &&
        // existing anim starts within the new anim's extend
        ((existingAnim.millisecond >= millisecond &&
          existingAnim.millisecond < durationToUseOnChecks + millisecond) ||
          // or ends within the new anim's extend
          (existingAnim.millisecond + duration > millisecond &&
            existingAnim.millisecond + duration <=
              durationToUseOnChecks + millisecond) ||
          // or it starts before and ends after the new anim's extend
          (existingAnim.millisecond < millisecond &&
            existingAnim.millisecond + duration >
              durationToUseOnChecks + millisecond))
      ) {
        arr.push(existingAnim);
      }
    }
    return arr;
  }

  /**
   * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
   * No checks are performed, just execution.
   * This method is executed on the context of SandboxLanesHandler
   * @param {String} mcid
   * @param {String} attr
   * @param {Number} millisecond
   * @param {Object} incident
   */
  addElementToLane(mcid, attr, millisecond, incident) {
    const executables = [];
    const laneKey = getLaneKey(mcid, attr);

    this.incidentsById[incident.id] = incident;
    const laneElement = {
      millisecond,
      id: incident.id,
    };
    this.laneExists(mcid, attr, true);
    this.lanes.pushValue(laneKey, laneElement);

    this.lanes[laneKey].sortBy('millisecond'); // uses the ObjectProxy's sortBy (we're on Sandbox env)
    const sortedLane = Array.from(this.lanes[laneKey]); // we use the spread operator as we want to work on the snapshot of the lanes before the rest of the Incidents enter
    const newAnimsIndex = sortedLane.findIndex(
      (item) => item.id === incident.id,
    ); // uses ObjectProxy's findIndex

    // indexing stuff
    if (!hasOwnProp(incident.id)) {
      this.belongingLaneKeysByAnimationId.setValue(incident.id, [laneKey]);
    } else {
      this.belongingLaneKeysByAnimationId.pushValue(incident.id, laneKey);
    }
    // step 1: set the initial values of the new Animation
    if (newAnimsIndex === 0) {
      // if the newly entered animation is the first of the lane
      if (sortedLane.length > 1) {
        // and it has other animations too
        const pureInitialValues =
          this.incidentsById[sortedLane[1].id].pureInitialValues;
        executables.push(() => {
          incident.setInitialValue(pureInitialValues);
        });
      } else {
        executables.push(() => {
          incident.setInitialValue();
        });
      }
    } else {
      executables.push(() => {
        const previousAnimValues =
          this.incidentsById[sortedLane[newAnimsIndex - 1].id]
            .animatedAttributeValue;
        incident.setInitialValue(previousAnimValues);
      });
    }

    /* if the attribute of the lane is a compo attribute */
    if (hasOwnProp(this.comboAttributes, attr)) {
      executables.push(() => {
        setInitialValueForCombo(
          sortedLane,
          this.incidentsById,
          incident.initialValue,
          newAnimsIndex,
        );
      });
    }

    // step 2: set the initial values of the following Animation (if any).
    if (newAnimsIndex + 1 < sortedLane.length) {
      const nextAnimeId = sortedLane[newAnimsIndex + 1].id;
      executables.push(() => {
        this.incidentsById[nextAnimeId].setInitialValue(
          incident.animatedAttributeValue,
        );
        if (this.incidentsById[nextAnimeId].gotContext) {
          this.incidentsById[nextAnimeId].lastWish();
          this.incidentsById[nextAnimeId].onGetContext();
        }
      });
    }
    return executables;
  }

  /**
   * it justs updates the lane
   * It gets executed on the context of the real LanesHanlder and not of the Sanbox
   * No checks are performed, just execution
   * @param {array} affectedAnimationsIds
   * @param {int} millisecondDelta
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  updateLane(affectedAnimationsIds, millisecondsDelta) {
    // first we group the affected animations by lanes
    const affectedLanes = {};
    const that = this;
    for (let i = 0; i < affectedAnimationsIds.length; i++) {
      const belongingLanes =
        this.belongingLaneKeysByAnimationId[affectedAnimationsIds[i]];
      for (let j = 0; j < belongingLanes.length; j++) {
        const laneKey = belongingLanes[j];
        if (!hasOwnProp(affectedLanes, laneKey)) {
          affectedLanes[laneKey] = {
            animations: [],
            lane: that.lanes[laneKey],
            laneData: getMCIDandAttrOutOfLaneKey(belongingLanes[j]),
          };
        }
        affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);
      }
    }

    // for each of the affected lanes
    for (const laneKey in affectedLanes) {
      const { laneData, lane, animations } = affectedLanes[laneKey];
      const shallowLaneCopy = [...lane];
      shallowLaneCopy.sort((a, b) => a.millisecond - b.millisecond);
      const isComboAttr = hasOwnProp(this.comboAttributes, laneData.attribute);
      // edit lane items millisecond
      for (let k = 0; k < lane.length; k++) {
        if (animations.includes(lane[k].id)) {
          lane[k].millisecond += millisecondsDelta;
        }
      } // end for searching for the animations within the lane

      lane.sort((a, b) => a.millisecond - b.millisecond);
      this.lanes[laneKey] = lane;

      for (let i = 0; i < animations.length; i++) {
        const animationToCheck = animations[i];
        const animationIndexBeforeEdit = shallowLaneCopy.findIndex(
          (item) => item.id === animationToCheck,
        );

        const animationIndexAfterEdit = lane.findIndex(
          (item) => item.id === animationToCheck,
        );

        if (
          animationIndexBeforeEdit === animationIndexAfterEdit &&
          animationIndexAfterEdit <= 1
        ) {
          continue;
        }

        const animation = this.incidentsById[lane[animationIndexAfterEdit].id];

        if (animationIndexBeforeEdit + 1 < lane.length) {
          // if the animation was not the last animation on the lane before the edit
          // we should take care of the initial values of the animation's previous successor
          if (animationIndexBeforeEdit === 0) {
            // if the edited animation was the first one before the edit
            // pass its initial values to its previous successor as its new initial values
            if (isComboAttr) {
              setInitialValueForCombo(
                lane,
                this.incidentsById,
                animation.pureInitialValues,
                0,
                true,
              );
            } else {
              const animationIncident =
                this.incidentsById[shallowLaneCopy[1].id];
              animationIncident.setInitialValue(animation.pureInitialValues);
              animationIncident.onGetContext();
            }
          } else {
            // else if the edited animation was not the first one before the edit
            // meaning its previous successor is not the first one on the lane after the edit
            // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value
            if (isComboAttr) {
              const indexToAffect =
                animationIndexAfterEdit > animationIndexBeforeEdit
                  ? animationIndexBeforeEdit
                  : animationIndexAfterEdit;
              setInitialValueForCombo(
                lane,
                this.incidentsById,
                this.incidentsById[
                  shallowLaneCopy[animationIndexBeforeEdit - 1].id
                ].animatedAttributeValue,
                indexToAffect,
                true,
              );
            } else {
              this.incidentsById[
                shallowLaneCopy[animationIndexBeforeEdit + 1].id
              ].setInitialValue(
                this.incidentsById[
                  shallowLaneCopy[animationIndexBeforeEdit - 1].id
                ].animatedAttributeValue,
              );
              this.incidentsById[
                shallowLaneCopy[animationIndexBeforeEdit + 1].id
              ].onGetContext();
            }
          }
        }

        // for the edited animation itself now:
        if (animationIndexAfterEdit === 0) {
          // is it the first one (after edit)?
          // get the initial values of the previously 0 indexed animation of the lane
          if (isComboAttr) {
            setInitialValueForCombo(
              lane,
              this.incidentsById,
              this.incidentsById[shallowLaneCopy[0].id].pureInitialValues,
              animationIndexAfterEdit,
              true,
            );
          } else {
            animation.setInitialValue(
              this.incidentsById[shallowLaneCopy[0].id].pureInitialValues,
            );
            animation.onGetContext();
          }
        } else {
          // else if it is not the first one after editd
          // just grab the target value of the previous animation on the updated lane and set it as its initial value
          if (isComboAttr) {
            setInitialValueForCombo(
              lane,
              this.incidentsById,
              this.incidentsById[lane[animationIndexAfterEdit - 1].id]
                .animatedAttributeValue,
              animationIndexAfterEdit,
              true,
            );
          } else {
            animation.setInitialValue(
              this.incidentsById[lane[animationIndexAfterEdit - 1].id]
                .animatedAttributeValue,
            );
            animation.onGetContext();
          }
        }

        // for its new next animation (if it has one)
        if (animationIndexAfterEdit + 1 >= lane.length) {
          continue;
        }
        // set its initial value to equal the target value of the edited animation
        if (isComboAttr) {
          setInitialValueForCombo(
            lane,
            this.incidentsById,
            animation.animatedAttributeValue,
            animationIndexAfterEdit + 1,
            true,
          );
          continue;
        }

        const incident =
          this.incidentsById[lane[animationIndexAfterEdit + 1].id];

        incident.setInitialValue(animation.animatedAttributeValue);
        incident.onGetContext();
      }
    } // end for each of the belonging lanes of the animation
  }

  /**
   * removes the list of animations as provided
   * @param {array} removedAnimations - an array with the removed animations' ids
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  deleteAnimations(removedAnimations) {
    const affectedLanes = {};

    for (let i = 0; i < removedAnimations.length; i++) {
      const id = removedAnimations[i];
      // for each lane the affected Animation appears in
      const belongingLanes = this.belongingLaneKeysByAnimationId[id];
      for (let j = 0; j < belongingLanes.length; j++) {
        let lane = this.lanes[belongingLanes[j]];

        let animationIndexBeforeEdit = -1;
        for (let k = 0; k < lane.length; k++) {
          if (lane[k].id === id) {
            animationIndexBeforeEdit = k;
            break;
          }
        }

        const animationToDelete = { ...lane[animationIndexBeforeEdit] };
        const animationObjectToDelete =
          this.incidentsById[animationToDelete.id];
        const laneData = getMCIDandAttrOutOfLaneKey(belongingLanes[j]);

        // gets the lane without the removed animation
        const newLane = [];
        for (let k = 0; k < lane.length; k++) {
          if (lane[k].id !== id) {
            newLane.push(lane[k]);
          }
        }
        this.lanes[belongingLanes[j]] = newLane;
        lane = this.lanes[belongingLanes[j]];

        if (lane.length === 0) {
          // in case there are no more animations on the lane any more we reset
          // the lane by running the progress(0,0), so that the affected elements
          // will get back to their original attribute value
          animationObjectToDelete.onProgress(0);
          delete this.lanes[belongingLanes[j]];
          if (hasOwnProp(affectedLanes, belongingLanes[j])) {
            delete affectedLanes[belongingLanes[j]];
          }
          continue;
        }

        affectedLanes[belongingLanes[j]] = getMCIDandAttrOutOfLaneKey(
          belongingLanes[j],
        );
        const pureInitialValues =
          this.incidentsById[animationToDelete.id].pureInitialValues;
        if (
          animationIndexBeforeEdit >= lane.length ||
          pureInitialValues === false
        ) {
          continue;
        }

        if (hasOwnProp(this.comboAttributes, laneData.attribute)) {
          setInitialValueForCombo(
            lane,
            this.incidentsById,
            pureInitialValues,
            animationIndexBeforeEdit,
            true,
          );
          continue;
        }

        const incident = this.incidentsById[lane[animationIndexBeforeEdit].id];
        incident.setInitialValue(pureInitialValues);
        incident.onGetContext();
      }

      delete this.belongingLaneKeysByAnimationId[removedAnimations[i]];
    }
    return affectedLanes;
  }

  /**
   * This method is responsible for recalculating the scratch values of the first
   * Incident of each of the lanes of the LanesHandler according to the provided
   * context id
   * */
  recalcScratchValues(contextId) {
    const keys = Object.keys(this.lanes);

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const theLane = this.lanes[key];
      if (theLane.length > 0) {
        const firstIncident = this.incidentsById[theLane[0].id];
        const newScratchValue = firstIncident.getScratchValue(contextId);
        const laneData = getMCIDandAttrOutOfLaneKey(key);
        if (hasOwnProp(this.comboAttributes, laneData.attribute)) {
          // if it is a combo
          setInitialValueForCombo(
            theLane,
            this.incidentsById,
            newScratchValue,
            0,
            true,
          );
        } else {
          // else if it's not a combo attribute
          firstIncident.setInitialValue(newScratchValue);
        }
        firstIncident.lastWish();
        firstIncident.onGetContext();
      }
    }
  }

  // lastAnimatedItemPerLane related methods
  getLastAffectedIndex(contextid, laneid, forceReset) {
    if (!this.lastAnimatedItemPerLane[contextid]) {
      this.lastAnimatedItemPerLane[contextid] = {
        [laneid]: [
          0,
          this.incidentsById[this.lanes[laneid][0].id].duration +
            this.lanes[laneid][0].millisecond,
        ],
      };
    } else if (!this.lastAnimatedItemPerLane[contextid][laneid] || forceReset) {
      this.lastAnimatedItemPerLane[contextid][laneid] = [
        0,
        this.incidentsById[this.lanes[laneid][0].id].duration +
          this.lanes[laneid][0].millisecond,
      ];
    }
    return this.lastAnimatedItemPerLane[contextid][laneid];
  }

  setLastAffectedIndex(contextid, laneid, index) {
    if (!this.lastAnimatedItemPerLane[contextid]) {
      this.lastAnimatedItemPerLane[contextid] = {};
    }
    this.lastAnimatedItemPerLane[contextid][laneid] = [
      index,
      this.incidentsById[this.lanes[laneid][index].id].duration +
        this.lanes[laneid][index].millisecond,
    ];
  }
}

export default LanesHandler;
