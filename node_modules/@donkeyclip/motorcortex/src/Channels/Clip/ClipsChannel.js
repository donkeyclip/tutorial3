/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import helper, { hasOwnProp } from '../../_coreUtils/helper';
import Channel from '../Channel';

class ClipChannel extends Channel {
  /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
  onInitialise() {
    this.incidents = [];
    this.incidentsById = {};
  }

  _incidentById(id) {
    return this.incidentsById[id];
  }

  _resize(durationFraction) {
    for (let i = 0; i < this.incidents.length; i++) {
      this.incidents[i].millisecond *= durationFraction;
    }
  }

  /**
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
  checkAddition(incidents) {
    const errors = [];
    const candidateIncidentsById = {};
    const incidentsToConcat = [];

    for (let i = 0; i < incidents.length; i++) {
      candidateIncidentsById[incidents[i].id] = incidents[i].incident;
      incidentsToConcat.push({
        id: incidents[i].id,
        millisecond: incidents[i].millisecond,
      });
      if (hasOwnProp(this.incidentsById, incidents[i].id)) {
        helper.error(
          `Incident with the id ${incidents[i].id} already exists. Addition is rejected.`,
        );
        errors.push({
          type: 'Already existing id',
          meta: {
            id: incidents[i].id,
          },
        });
      }
    }

    if (errors.length > 0) {
      return {
        result: false,
        errors,
      };
    }

    const that = this;
    const exec = function execFunct() {
      that.incidentsById = Object.assign(
        that.incidentsById,
        candidateIncidentsById,
      );

      that.incidents.push(...incidentsToConcat);

      that.incidents.sort((a, b) => a.millisecond - b.millisecond);

      for (let i = 0; i < incidents.length; i++) {
        that._incidentById(incidents[i].id)._onGetContextOnce(that.context);
      }
    };

    return { result: true, execute: exec };
  }

  /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */
  checkEdit(incidentsArray, millisecondsDelta) {
    const incidents = this.incidents;
    const exec = function execFunct() {
      let id;
      for (let i = 0; i < incidentsArray.length; i++) {
        id = incidentsArray[i].id;
        for (let j = 0; j < incidents.length; j++) {
          if (incidents[j].id === id) {
            incidents[j].millisecond += millisecondsDelta;
            break;
          }
        }
      }
      incidents.sort((a, b) => a.millisecond - b.millisecond);
    };

    return { result: true, execute: exec };
  }

  checkDelete(incidentsArray) {
    const that = this;
    const incidentIds = [];
    for (let i = 0; i < incidentsArray.length; i++) {
      incidentIds.push(incidentsArray[i].id);
    }

    const exec = function execFunct() {
      const newIncidents = that.incidents.filter(
        (incident) => !incidentIds.includes(incident.id),
      );

      that.incidents = newIncidents;
      for (let i = 0; i < incidentIds.length; i++) {
        delete that.incidentsById[incidentIds[i]];
      }
    };

    return { result: true, execute: exec };
  }

  /**
   * @param {array} incidents - [{id, start, end, startDelta}]
   */
  checkResizedIncidents(incidents) {
    const selfIncidents = this.incidents;
    const exec = function execFunct() {
      let id;
      for (let i = 0; i < incidents.length; i++) {
        id = incidents[i].id;
        for (let j = 0; j < selfIncidents.length; j++) {
          if (selfIncidents[j].id === id) {
            selfIncidents[j].millisecond += incidents[i].startDelta;
            break;
          }
        }
      }
      selfIncidents.sort((a, b) => a.millisecond - b.millisecond);
    };

    return { result: true, execute: exec };
  }

  /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  moveTo(from, to, contextId, forceReset = false) {
    // TODO: This function really similar to moveTo from the AttributeChannel.js, refactor it based on that and extract common functions
    if (forceReset) {
      // incidents: [{id, millisecond}, {}, {}...]
      for (let i = 0; i < this.incidents.length; i++) {
        const laneItem = this.incidents[i];
        const incident = this._incidentById(laneItem.id);

        if (to < laneItem.millisecond) {
          incident.onProgress(0, 0, contextId, true);
        } else if (to > laneItem.millisecond + incident.duration) {
          incident.onProgress(1, incident.duration, contextId, true);
        } else {
          incident.onProgress(
            (to - laneItem.millisecond) / incident.duration,
            to - laneItem.millisecond,
            contextId,
            true,
          );
        }
      }
      return;
    }

    const that = this;
    let participatingItems;
    if (to > from) {
      participatingItems = this.incidents.filter(
        (laneItem) =>
          // it ends after from and before to millisecond
          // or it ends after the target millisecond but also starts before it
          (laneItem.millisecond + that._incidentById(laneItem.id).duration >=
            from &&
            laneItem.millisecond + that._incidentById(laneItem.id).duration <=
              to) ||
          (that._incidentById(laneItem.id).duration + laneItem.millisecond >=
            to &&
            laneItem.millisecond <= to),
      );
    } else {
      participatingItems = this.incidents.filter(
        (laneItem) =>
          // it ends after from and before to millisecond
          // or it ends after the target millisecond but also starts before it
          (laneItem.millisecond + that._incidentById(laneItem.id).duration >=
            to &&
            laneItem.millisecond + that._incidentById(laneItem.id).duration <=
              from) ||
          (that._incidentById(laneItem.id).duration + laneItem.millisecond >=
            from &&
            laneItem.millisecond <= from),
      );
    }

    for (let i = 0; i < participatingItems.length; i++) {
      const laneItem = participatingItems[i];
      const contextAwareClipIncident = this._incidentById(laneItem.id);

      const overcameEnd =
        (to - laneItem.millisecond) / contextAwareClipIncident.duration >= 1;

      const fraction = overcameEnd
        ? 1
        : (to - laneItem.millisecond) / contextAwareClipIncident.duration;
      const millisecond = overcameEnd
        ? contextAwareClipIncident.duration
        : to - laneItem.millisecond;

      contextAwareClipIncident.onProgress(
        fraction,
        millisecond,
        contextId,
        false,
      );
    }
  }
}

export default ClipChannel;
