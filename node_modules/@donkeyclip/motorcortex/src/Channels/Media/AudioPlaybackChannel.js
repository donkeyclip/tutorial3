/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { getAnId } from '../../_coreUtils/helper';
import ClipsChannel from '../Clip/ClipsChannel';

const dataSeparator = '|||';

class AudioPlaybackChannel extends ClipsChannel {
  constructor(props) {
    super(props);
    // keeps the list of the ids of MediaIncidents that are currently been played
    // in the form `${id}|||$[contextId}`
    this.playingIncidentsIds = [];
    // when the Channel's Clip enters the transitional state the Channel ignores
    // moveTos. When the transition ends though, no matter the currentMillisecond
    // its Clip was it should recalc which sources to play as if we were going from
    // 0 to the the target millisecond because of the different way the Playback operates
    // (it has no onProgress). For this, it's very important to store the information
    // that it entered the transitional state so on the next playing state moveTo
    // to force as from ms 0.
    this.transitioned = false;
    props.subscribe(getAnId(), this._stateChange.bind(this), 0, 1, true);
  }

  /**
   *
   * @param {integer} ms: the millisecond of the incident
   * @param {string} state: the new state
   * @param {object} options: an optional options object. In the case of the exceptional block this object carries the
   * info and it should be considered as it directs our Channel not to stop a specific Incident
   * @private
   */
  _stateChange(ms, state, options = {}) {
    if (state === 'paused' || state === 'idle' || state === 'blocked') {
      this._stopPlayingIncidents(options);
      this.transitioned = true;
    }
  }

  /**
   *
   * @param {object} options: An options object. Currently supports the "exception" key that if present it holds the id
   * of an Incident that we want to exclude from our stop
   * @private
   */
  _stopPlayingIncidents(options = {}) {
    for (let i = 0; i < this.playingIncidentsIds.length; i++) {
      const incidentInfo = this.playingIncidentsIds[i].split(dataSeparator);
      if (!incidentInfo[0].startsWith(options.exception)) {
        this._incidentById(incidentInfo[0]).stop(incidentInfo[1]);
      }
    }
    this.playingIncidentsIds = [];
  }

  /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  moveTo(from, to, contextId, forceReset = false) {
    if (this.runTimeInfo.state === 'transitional' || !!forceReset) {
      this.transitioned = true;
      this._stopPlayingIncidents();

      for (let i = 0; i < this.incidents.length; i++) {
        const { id, millisecond } = this.incidents[i];
        const incident = this._incidentById(id);

        let end;
        if (to < millisecond) {
          end = 0;
        } else if (to > millisecond + incident.duration) {
          end = incident.duration;
        } else {
          end = to - millisecond;
        }

        incident.onProgress(end, contextId, true);
      }
      return;
    }

    if (this.transitioned) {
      from = 0;
      this.transitioned = false;
    }
    // the only way AudioPlaybackChannel can accept from > to is when its owner Clip is starting a fresh loop
    // as the AudioPlaybackChannel does not execute on seek command. In this case we should stop everything and
    // set from equals to 0
    const freshLoop = from > to;

    const incidents = this.incidents;

    for (let i = 0; i < incidents.length; i++) {
      const laneItem = incidents[i];
      const millisecond = laneItem.millisecond;
      const MediaIncident = this._incidentById(laneItem.id);
      const duration = MediaIncident.duration;
      const end = millisecond + duration;
      const incidentID = `${laneItem.id}${dataSeparator}${contextId}`;

      // Finishing animations
      if ((end > from && end <= to) || freshLoop) {
        MediaIncident.stop(contextId);
        const index = this.playingIncidentsIds.indexOf(incidentID);
        if (index > -1) {
          this.playingIncidentsIds.splice(index, 1);
        }
      }
      // Starting animations
      const fromToUse = freshLoop ? 0 : from;
      if (millisecond >= fromToUse && millisecond < to && end > to) {
        const overcameEnd = (to - millisecond) / duration >= 1;
        const fraction = overcameEnd ? 1 : (to - millisecond) / duration;
        const ms = overcameEnd ? duration : to - millisecond;
        const startAttempt = MediaIncident.play(fraction, ms, contextId);
        if (startAttempt) {
          this.playingIncidentsIds.push(incidentID);
        }
      }
    }

    this.runTimeInfo.currentMillisecond = to;
  }
}

export default AudioPlaybackChannel;
