// TESTER LOADING
import TesterClass from '../../../tester/Tester';
import DC from '../../Clip/Browser/Descriptive/HTMLDescriptiveClip';
import DI from '../../DescriptiveIncidents/DescriptiveIncident';
import { loadPlugin, Effect } from '../../main';
import { _MC_Attribute } from '../../_configuration/_CONST';
// STATES LOADING
import {
  descriptiveTree as descriptiveTree1,
  lanes as lanes1,
  realTree as realTree1,
} from './states/state1';
import {
  descriptiveTree as descriptiveTree2,
  lanes as lanes2,
  realTree as realTree2,
} from './states/state2';
import {
  descriptiveTree as descriptiveTree3,
  lanes as lanes3,
  realTree as realTree3,
} from './states/state3';
import {
  descriptiveTree as descriptiveTree4,
  lanes as lanes4,
  realTree as realTree4,
} from './states/state4';
import {
  descriptiveTree as descriptiveTree5,
  lanes as lanes5,
  realTree as realTree5,
} from './states/state5';
import {
  descriptiveTree as descriptiveTree6,
  lanes as lanes6,
  realTree as realTree6,
} from './states/state6';
import {
  descriptiveTree as descriptiveTree7,
  lanes as lanes7,
  realTree as realTree7,
} from './states/state7';

const Tester = new TesterClass();

// PLAIN INCIDENTS DEFINITION
const di1 = new DI(
  {
    animatedAttrs: { alpha: 1 },
  },
  {
    duration: 1000,
    id: 'di1',
    selector: '.my-class',
  },
);

const di2 = new DI(
  {
    animatedAttrs: {
      alpha: 2,
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'di2',
  },
);

const di3 = new DI(
  {
    animatedAttrs: {
      alpha: 3,
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'di3',
  },
);

// PLUGIN WITH COMPO ATTRIBUTES DEFINITION
class MyPluginIncident extends Effect {
  onGetContext() {}

  onProgress() {
    // eslint-disable-line no-unused-vars
  }

  getScratchValue() {
    return {
      gamma: 0,
      delta: 0,
      epsilon: 0,
    };
  }
}

// An Incident that takes scratch values from the CSS
class MyPluginIncident2 extends Effect {
  onGetContext() {}

  onProgress() {
    // eslint-disable-line no-unused-vars
  }

  getScratchValue() {
    return {
      opacity: this.context.window
        .getComputedStyle(this.element)
        .getPropertyValue('opacity'),
      left: this.context.window
        .getComputedStyle(this.element)
        .getPropertyValue('left'),
      width: this.element.getAttribute('data-width'),
    };
  }
}

const npmName = '@donkeyclip/test-plugin';
const testPlugin = {
  npm_name: npmName,
  name: 'Test Plugin',
  incidents: [
    {
      exportable: MyPluginIncident,
      name: 'MPInc',
    },
    {
      exportable: MyPluginIncident2,
      name: 'MPInc2',
    },
  ],
  compositeAttributes: {
    compo: ['gamma', 'delta', 'epsilon'],
    compo2: ['opacity', 'left', 'width'],
  },
};

const TestPlugin = loadPlugin(testPlugin);

const cdi0 = new TestPlugin.MPInc(
  {
    animatedAttrs: {
      compo: { epsilon: 1 },
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'cdi0',
  },
);

const cdi1 = new TestPlugin.MPInc(
  {
    animatedAttrs: {
      compo: { gamma: 1 },
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'cdi1',
  },
);

const cdi2 = new TestPlugin.MPInc(
  {
    animatedAttrs: {
      compo: { delta: 2 },
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'cdi2',
  },
);

const cdi3 = new TestPlugin.MPInc(
  {
    animatedAttrs: {
      compo: { gamma: 3, delta: 3 },
    },
  },
  {
    selector: '.my-class',
    duration: 1000,
    id: 'cdi3',
  },
);

// CLIPS
let myClip;

// TESTS
test('Move an Incident from the second index of a lane to the first (0)', () => {
  document.body.innerHTML = '<div id="clip-container"></div>';

  const myClip0 = new DC({
    html: `
                        <div id="my-root-div">
                            <div id="element-1" class="my-class" data-motorcortex2-id="my-class-1"></div>
                        </div>`,
    css: '',
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
  });

  myClip0.addIncident(di1, 1000);
  myClip0.addIncident(di2, 3000);
  myClip0.addIncident(di3, 5000);

  // first check that the state of the clip as expected
  const lh = myClip0.realClip.instantiatedChannels[_MC_Attribute].LanesHandler;
  let descTreeTest = Tester.testTree(descriptiveTree1, myClip0);
  let realTreeTest = Tester.testTree(realTree1, myClip0.realClip);
  let lanesTest = Tester.testLanes(lanes1, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();

  // move the second incident to the first index
  const res = myClip0.moveIncident('di2', 0);
  expect(res.result).toBe(true);
  descTreeTest = Tester.testTree(descriptiveTree2, myClip0);
  realTreeTest = Tester.testTree(realTree2, myClip0.realClip);
  lanesTest = Tester.testLanes(lanes2, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('Add three incidents with composite attributes and check their initial values', () => {
  document.body.innerHTML = '<div id="clip-container"></div>';

  myClip = new DC({
    html: `
                        <div id="my-root-div">
                            <div id="element-1" class="my-class" data-motorcortex2-id="my-class-1"></div>
                        </div>`,
    css: '',
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
  });

  myClip.addIncident(cdi1, 1000);
  myClip.addIncident(cdi2, 3000);
  myClip.addIncident(cdi3, 5000);

  // first check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree3, myClip);
  const realTreeTest = Tester.testTree(realTree3, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes3, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('move the last combo-attribute item to the zero index. Expect combo attributes of the lane to adapt the change', () => {
  // then move the last item to the zero index and check
  const res = myClip.moveIncident('cdi3', 0);
  expect(res.result).toBe(true);
  // and check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree4, myClip);
  const realTreeTest = Tester.testTree(realTree4, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes4, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('move the second combo-attribute incident to the last position. Expect combo attributes of the lane to adapt the change', () => {
  const res = myClip.moveIncident('cdi1', 5000);
  expect(res.result).toBe(true);
  // and check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree5, myClip);
  const realTreeTest = Tester.testTree(realTree5, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes5, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('move the first combo-attribute incident to the last position. Expect combo attributes of the lane to adapt the change', () => {
  // then move the first incident to the last position and check
  const res = myClip.moveIncident('cdi3', 6000);
  expect(res.result).toBe(true);
  // and check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree6, myClip);
  const realTreeTest = Tester.testTree(realTree6, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes6, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('add a new combo-attribute Incident in the first index. Expect combo attributes of the lane to adapt the change', () => {
  // then add a new Incident in the first index and check
  const res = myClip.addIncident(cdi0, 0);
  expect(res.result).toBe(true);
  // and check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree7, myClip);
  const realTreeTest = Tester.testTree(realTree7, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes7, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

test('remove the first combo-attribute Incident. Expect combo attributes of the lane to adapt the change', () => {
  // then remove the first Incident and check
  const res = myClip.removeIncident('cdi0');
  expect(res.result).toBe(true);
  // and check that the state of the clip as expected
  const lh = myClip.realClip.instantiatedChannels[npmName].LanesHandler;
  const descTreeTest = Tester.testTree(descriptiveTree6, myClip);
  const realTreeTest = Tester.testTree(realTree6, myClip.realClip);
  const lanesTest = Tester.testLanes(lanes6, lh.lanes, lh.incidentsById);
  expect(descTreeTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
});

/** broken from jest v.24 to v.25 **/
test(`check fragmented clips scratch values on combo attributes are dynamically recalculated
    on CASI Copy instantiation when the CASI enters the Clip`, () => {
  console.warn('TODO, check and restore test');

  // document.body.innerHTML = '<div id="clip-container"></div>';

  // myRootClip = new DC({
  //   html: `
  //     <div id="my-root-div">
  //         <div class="casi-container"></div>
  //         <div class="casi-container"></div>
  //     </div>`,
  //   css: '',
  //   host: document.querySelector('#clip-container'),
  //   id: 'my-root-clip'
  // });

  // myCASI = new DC({
  //   html: `
  //   <div>
  //       <div class="incident-target" data-width="100px" data-motorcortex2-id="width100"></div>
  //       <div class="incident-target" data-width="40px" data-motorcortex2-id="width40"></div>
  //   </div>`,
  //   css: `.incident-target{
  //       opacity: 0;
  //       left: 50px
  //   }`,
  //   selector: '.casi-container',
  //   id: 'my-root-clip'
  // });

  // const casiInc1 = new TestPlugin.MPInc2(
  //   {
  //     animatedAttrs: {
  //       compo2: { opacity: 1, left: '100px' }
  //     }
  //   },
  //   {
  //     selector: '.incident-target',
  //     duration: 1000,
  //     id: 'casiInc1'
  //   }
  // );

  // const casiInc2 = new TestPlugin.MPInc2(
  //   {
  //     animatedAttrs: {
  //       compo2: { opacity: 0.5, left: '75px' }
  //     }
  //   },
  //   {
  //     selector: '.incident-target',
  //     duration: 1000,
  //     id: 'casiInc2'
  //   }
  // );

  // myCASI.addIncident(casiInc1, 0);
  // myCASI.addIncident(casiInc2, 1000);

  // myRootClip.addIncident(myCASI, 0);

  // // expect that all CASI Incidents have properly reset their start and end values
  // // according to the scratch values gathered from the instantiated (real) clips
  // // of the CASI
  // const myCASIincidentsById =
  //   myCASI.realClip.instantiatedChannels[npmName].LanesHandler.incidentsById;
  // const myCASIpluginCAIncidentsKeys = myCASIincidentsById._keys();
  // for (let i = 0; i < myCASIpluginCAIncidentsKeys.length; i++) {
  //   const cai = myCASIincidentsById._get(myCASIpluginCAIncidentsKeys[i]);
  //   if (cai.constructionIngredients.props.id === 'casiInc1') {
  //     // first in lane
  //     for (const contextKey in cai.contexts) {
  //       // for each context
  //       if (myCASIpluginCAIncidentsKeys[i] === 'casiInc1_width100_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: '0',
  //           left: '50px',
  //           width: '100px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '100px'
  //         });
  //       } else if (myCASIpluginCAIncidentsKeys[i] === 'casiInc1_width40_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: '0',
  //           left: '50px',
  //           width: '40px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '40px'
  //         });
  //       }
  //     }
  //   } else {
  //     // second in lane
  //     for (const contextKey in cai.contexts) {
  //       // for each context
  //       if (myCASIpluginCAIncidentsKeys[i] === 'casiInc2_width100_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '100px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 0.5,
  //           left: '75px',
  //           width: '100px'
  //         });
  //       } else if (myCASIpluginCAIncidentsKeys[i] === 'casiInc2_width40_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '40px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 0.5,
  //           left: '75px',
  //           width: '40px'
  //         });
  //       }
  //     }
  //   }
  // }
});

/** broken from jest v.24 to v.25 **/
test(`check fragmented clips scratch values on combo attributes are dynamically recalculated
    on CASI Copy instantiation when the CASI already on a Clip accepts Incidents`, () => {
  console.warn('TODO, check and restore test');

  // document.body.innerHTML = '<div id="clip-container"></div>';

  // myRootClip = new DC({
  //   html: `
  //           <div id="my-root-div">
  //               <div class="casi-container"></div>
  //               <div class="casi-container"></div>
  //           </div>`,
  //   css: '',
  //   host: document.querySelector('#clip-container'),
  //   id: 'my-root-clip'
  // });

  // myCASI = new DC({
  //   html: `
  //           <div>
  //               <div class="incident-target" data-width="100px" data-motorcortex2-id="width100"></div>
  //               <div class="incident-target" data-width="40px" data-motorcortex2-id="width40"></div>
  //           </div>`,
  //   css: `.incident-target{
  //               opacity: 0;
  //               left: 50px
  //           }`,
  //   selector: '.casi-container',
  //   id: 'my-root-clip'
  // });

  // myRootClip.addIncident(myCASI, 0);

  // const casiInc1 = new TestPlugin.MPInc2(
  //   {
  //     animatedAttrs: {
  //       compo2: { opacity: 1, left: '100px' }
  //     }
  //   },
  //   {
  //     selector: '.incident-target',
  //     duration: 1000,
  //     id: 'casiInc1'
  //   }
  // );

  // const casiInc2 = new TestPlugin.MPInc2(
  //   {
  //     animatedAttrs: {
  //       compo2: { opacity: 0.5, left: '75px' }
  //     }
  //   },
  //   {
  //     selector: '.incident-target',
  //     duration: 1000,
  //     id: 'casiInc2'
  //   }
  // );

  // myCASI.addIncident(casiInc1, 0);
  // myCASI.addIncident(casiInc2, 1000);

  // // expect that all CASI Incidents have properly reset their start and end values
  // // according to the scratch values gathered from the instantiated (real) clips
  // // of the CASI
  // const myCASIincidentsById =
  //   myCASI.realClip.instantiatedChannels[npmName].LanesHandler.incidentsById;
  // const myCASIpluginCAIncidentsKeys = myCASIincidentsById._keys();
  // for (let i = 0; i < myCASIpluginCAIncidentsKeys.length; i++) {
  //   const cai = myCASIincidentsById._get(myCASIpluginCAIncidentsKeys[i]);
  //   if (cai.constructionIngredients.props.id === 'casiInc1') {
  //     // first in lane
  //     for (const contextKey in cai.contexts) {
  //       // for each context
  //       if (myCASIpluginCAIncidentsKeys[i] === 'casiInc1_width100_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: '0',
  //           left: '50px',
  //           width: '100px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '100px'
  //         });
  //       } else if (myCASIpluginCAIncidentsKeys[i] === 'casiInc1_width40_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: '0',
  //           left: '50px',
  //           width: '40px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '40px'
  //         });
  //       }
  //     }
  //   } else {
  //     // second in lane
  //     for (const contextKey in cai.contexts) {
  //       // for each context
  //       if (myCASIpluginCAIncidentsKeys[i] === 'casiInc2_width100_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '100px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 0.5,
  //           left: '75px',
  //           width: '100px'
  //         });
  //       } else if (myCASIpluginCAIncidentsKeys[i] === 'casiInc2_width40_compo2') {
  //         expect(cai.contexts[contextKey].initialValue).toEqual({
  //           opacity: 1,
  //           left: '100px',
  //           width: '40px'
  //         });
  //         expect(cai.contexts[contextKey].targetValue).toEqual({
  //           opacity: 0.5,
  //           left: '75px',
  //           width: '40px'
  //         });
  //       }
  //     }
  //   }
  // }
});
