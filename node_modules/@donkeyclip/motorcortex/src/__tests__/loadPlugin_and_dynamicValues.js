/* eslint-disable sonarjs/no-duplicate-string */
import AttributeChannel from '../Channels/Attribute/AttributeChannel';
import ClipChannel from '../Channels/Clip/ClipsChannel';
import NullClip from '../Clip/Browser/Descriptive/helpers/NullClip';
import HTMLDescriptiveClip from '../Clip/Browser/Descriptive/HTMLDescriptiveClip';
import DescriptiveIncident from '../DescriptiveIncidents/DescriptiveIncident';
import { HTMLClip, loadPlugin, Effect } from '../main';

const npm_name = 'test-plugin';
class MyPluginIncident extends Effect {
  onGetContext() {}

  // eslint-disable-next-line no-unused-vars
  onProgress(t) {}
}

class MySecondPluginIncident extends Effect {
  onGetContext() {}

  // eslint-disable-next-line no-unused-vars
  onProgress(t) {}
}

class MyPluginClip extends HTMLClip {
  buildTree() {}
}

class MyPluginClip2 extends HTMLClip {
  get html() {
    return `<div data-motorcortex2-id="123">${this.attrs.text} ${this.attrs.number} ${this.attrs.color}</div>`;
  }

  get css() {
    return `
      div{
        width: 100%;
      }
    `;
  }

  buildTree() {
    const di = new DescriptiveIncident(
      { animatedAttrs: { x: 200 } },
      { selector: 'div', duration: 2000 },
    );
    this.addIncident(di, 0);
  }
}

const testPlugin = {
  npm_name,
  incidents: [
    {
      exportable: MyPluginIncident,
      name: 'MPInc',
      attributesValidationRules: {
        animatedAttrs: {
          optional: false,
          type: 'object',
          props: {
            test: {
              type: 'amount',
            },
            stagger: {
              type: 'measurement',
              optional: true,
              units: ['px', '%'],
            },
            stagger2: {
              type: 'measurement',
              optional: true,
              units: ['px', '%'],
            },
            stagger3: {
              type: 'color',
              optional: true,
            },
            staggerObject: {
              type: 'object',
              optional: true,
              props: {
                alpha: {
                  type: 'amount',
                },
              },
            },
          },
        },
      },
    },
    {
      exportable: MySecondPluginIncident,
      name: 'MSPInc',
      attributesValidationRules: {
        animatedAttrs: {
          optional: false,
          type: 'object',
          props: {
            test: {
              type: 'number',
              optional: false,
            },
            testObj: {
              type: 'object',
              optional: true,
              props: {
                msr: {
                  type: 'measurement',
                  units: ['%', 'px'],
                  min: 0,
                  max: 10,
                  optional: true,
                },
              },
            },
          },
        },
      },
    },
    {
      exportable: MyPluginClip,
      name: 'MPClip',
      originalDims: {
        width: '1000px',
        height: '800px',
      },
    },
    {
      exportable: MyPluginClip2,
      name: 'MPClip2',
      attributesValidationRules: {
        text: {
          type: 'string',
          optional: false,
        },
        number: {
          type: 'string',
          optional: false,
        },
        color: {
          type: 'color',
          optional: true,
        },
      },
      originalDims: {
        width: '1000px',
        height: '800px',
      },
    },
  ],
};

const TestPlugin = loadPlugin(testPlugin);

test('Plugin loading', () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 0,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  const newMPClip = new TestPlugin.MPClip({
    selector: '.test-host',
  });

  expect(newMPInc instanceof DescriptiveIncident).toBe(true);
  expect(newMPClip instanceof HTMLClip).toBe(true);

  expect(newMPInc.constructor.Incident).toBe(MyPluginIncident);
  expect(newMPInc.constructor.plugin_npm_name).toBe(npm_name);
  expect(newMPInc.constructor.Channel).toBe(AttributeChannel);
  expect(newMPInc.constructor.plugin).toBe(npm_name);

  expect(newMPClip.constructor.Incident).toBe(HTMLDescriptiveClip.Incident);
  expect(newMPClip.constructor.plugin_npm_name).toBe(
    '@donkeyclip/self-contained-incidents',
  );
  expect(newMPClip.constructor.Channel).toBe(ClipChannel);
  expect(newMPClip.constructor.plugin).toBe(npm_name);
  expect(newMPInc.constructor.attrsValidationRules).toEqual({
    animatedAttrs: {
      type: 'object',
      optional: false,
      props: {
        test: {
          type: 'number',
        },
        stagger: {
          type: 'measurement',
          optional: true,
          units: ['px', '%'],
        },
        stagger2: {
          type: 'measurement',
          optional: true,
          units: ['px', '%'],
        },
        stagger3: {
          type: 'color',
          optional: true,
        },
        staggerObject: {
          type: 'object',
          optional: true,
          props: {
            alpha: {
              type: 'number',
            },
          },
        },
      },
    },
    initialValues: {
      type: 'object',
      optional: true,
      props: {
        test: {
          type: 'number',
          optional: true,
        },
        stagger: {
          type: 'measurement',
          optional: true,
          units: ['px', '%'],
        },
        stagger2: {
          type: 'measurement',
          optional: true,
          units: ['px', '%'],
        },
        stagger3: {
          type: 'color',
          optional: true,
        },
        staggerObject: {
          type: 'object',
          optional: true,
          props: {
            alpha: {
              optional: true,
              type: 'number',
            },
          },
        },
      },
    },
  });
});

test(`01. Plugin validation rules`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 'alpha',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.result).toBe(false);
});

test(`02. Plugin validation rules with valid initialValues`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 0,
      },
      initialValues: {
        test: 1,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc instanceof DescriptiveIncident).toBe(true);
});

test(`03. Plugin validation rules with invalid initialValues`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 0,
      },
      initialValues: {
        test: 'alpha',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.result).toBe(false);
});

test(`04. Edit incident passing wrong attributes according to validation rules`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 0,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  const res = newMPInc.editAttributes({});
  expect(res.result).toBe(false);
});

test(`05. Mandatory animatedAttrs to accept null initialValues`, () => {
  const newMPInc = new TestPlugin.MSPInc(
    {
      animatedAttrs: {
        test: 0,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc instanceof DescriptiveIncident).toBe(true);
});

test(`06. Editing the attributes of an Incident with mandatory animatedAttrs and missing initialValues`, () => {
  const newMPInc = new TestPlugin.MSPInc(
    {
      animatedAttrs: {
        test: 0,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  const res = newMPInc.editAttributes({
    animatedAttrs: {
      test: 2,
    },
  });

  expect(res.result).toBe(true);
});

test(`07. Creating an Incident with invalid initialValues`, () => {
  const newMPInc = new TestPlugin.MSPInc(
    {
      animatedAttrs: {
        test: 0,
        testObj: {
          msr: '8px',
        },
      },
      initialValues: {
        testObj: {
          msr: '2',
        },
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.result).toBe(false);
});

test(`08. Editing the initialValues of an Incident that should not pass`, () => {
  const newMPInc = new TestPlugin.MSPInc(
    {
      animatedAttrs: {
        test: 0,
        testObj: {
          msr: '8px',
        },
      },
      initialValues: {
        testObj: {
          msr: '2px',
        },
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  const res = newMPInc.editAttributes({
    animatedAttrs: {
      test: 0,
      testObj: {
        msr: '8px',
      },
    },
    initialValues: {
      testObj: {
        msr: '2',
      },
    },
  });

  expect(res.result).toBe(false);
});

test(`09. Removal of Plugin Clip as CASI on MC CASI Clip`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div id="casi-container" class="a" test="0"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
  });

  // ********************************************************
  // create a CASI with selector targeting a div on root clip
  const myCASI = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div id="plugin-clip-container" class="a" test="0"></div>
                <div id="#three-mc-clip-container"></div>
            </div>`,
    css: ``,
    selector: '#casi-container',
    id: 'myCASI',
  });
  // add CASI to the root Clip
  myRootClip.addIncident(myCASI, 0);

  // *********************************************************
  // create a CASI of the plugin's Clip Incident
  const myMPClip = new TestPlugin.MPClip({
    selector: '#plugin-clip-container',
    id: 'myMPClip',
    containerParams: {
      width: '600px',
    },
  });
  // add it to the casi clip
  myCASI.addIncident(myMPClip, 0);

  // *********************************************************
  // create a third-level MC CASI
  const my3CASI = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div id="plugin-clip-container" class="a" test="0"></div>
                <div id="mc-clip-container"></div>
            </div>`,
    css: ``,
    selector: '#three-mc-clip-container',
    id: 'my3CASI',
  });
  // add it to the casi clip
  myCASI.addIncident(my3CASI, 0);

  // *********************************************************
  // remove my3CASI from myCASI
  const res = myCASI.removeIncident(my3CASI);
  expect(res.result).toBe(true);

  // *********************************************************
  // remove myMPClip from myCASI
  const res2 = myCASI.removeIncident(myMPClip);
  expect(res2.result).toBe(true);
});
// TODO test attributes editing on Incidents without validation rules
test(`10. Plugin validation rules`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: 12,
        stagger: '@stagger(100px,200px)',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );
  expect(newMPInc instanceof DescriptiveIncident).toBe(true);
});

test(`11. Test attributesStaggers on valid attrs pass, including staggers`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@stagger(100px,200px)',
        test: 12,
        stagger2: '@stagger(150%, 250%, 0.2, easeOutCubic, linear, true)',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe('animatedAttrs.stagger2');
});

test(`12. Test attributesStaggers on valid attrs pass, including expressions`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@expression(100+200)px',
        test: 12,
        stagger2: '@expression(index*4 + total)%',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe('animatedAttrs.stagger2');
});

test(`13. Test attributesStaggers on valid attrs pass, including pattern`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@pattern(20px, 30px)',
        test: 12,
        stagger2: '@pattern(20px, 30px)',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe('animatedAttrs.stagger2');
});

test(`14. Test attributesStaggers on valid attrs pass, including attribute`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@attribute(data-attr)',
        test: 12,
        stagger2: '@attribute(data-attr2)',
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe('animatedAttrs.stagger2');
});

test(`15. Test attributesStaggers on valid attrs pass, including staggers`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@stagger(100px,200px)',
        test: 12,
        staggerObject: {
          alpha: '@stagger(0,1)',
        },
      },
    },
    {
      selector: '.test',
      duration: '@stagger(0,1000)',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe(
    'animatedAttrs.staggerObject.alpha',
  );
});

test(`16. Test attributesStaggers on valid attrs pass, including expressions`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@expression(index+total/2)px',
        test: 12,
        staggerObject: {
          alpha: '@expression(random(1,3))',
        },
      },
    },
    {
      selector: '.test',
      duration: '@expression(150+12)',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(2);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[1].path).toBe(
    'animatedAttrs.staggerObject.alpha',
  );
});

test(`17. Test stagger expression on animatedProperty and duration`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@stagger(100px,200px)',
        test: 12,
      },
    },
    {
      selector: '.a',
      duration: '@stagger(0, 1000)',
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);

  const animatedAttributesSplitters =
    myRootClip.realClip.children[Object.keys(myRootClip.realClip.children)[0]]
      .leaf.children;

  let i = 0;
  for (let id in animatedAttributesSplitters) {
    expect(
      animatedAttributesSplitters[id].leaf.data.attrs.animatedAttrs.stagger,
    ).toEqual(i * 20 + 100 + 'px');
    expect(animatedAttributesSplitters[id].leaf.data.props.duration).toEqual(
      i * 200,
    );

    const CAIkeys = Object.keys(animatedAttributesSplitters[id].leaf.children);
    const staggerCAI =
      animatedAttributesSplitters[id].leaf.children[CAIkeys[0]];
    expect(staggerCAI.leaf.originalAnimatedAttributeValue).toBe(
      i * 20 + 100 + 'px',
    );
    expect(staggerCAI.leaf.constructionIngredients.props.duration).toBe(
      i * 200,
    );
    i++;
  }
});

test(`18. Test math expression on animatedProperty and duration`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@expression(100+index*20)px',
        test: 12,
      },
    },
    {
      selector: '.a',
      duration: '@expression(index*200)',
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);

  const animatedAttributesSplitters =
    myRootClip.realClip.children[Object.keys(myRootClip.realClip.children)[0]]
      .leaf.children;

  let i = 0;
  for (let id in animatedAttributesSplitters) {
    expect(
      animatedAttributesSplitters[id].leaf.data.attrs.animatedAttrs.stagger,
    ).toEqual(i * 20 + 100 + 'px');
    expect(animatedAttributesSplitters[id].leaf.data.props.duration).toEqual(
      i * 200,
    );

    const CAIkeys = Object.keys(animatedAttributesSplitters[id].leaf.children);
    const staggerCAI =
      animatedAttributesSplitters[id].leaf.children[CAIkeys[0]];
    expect(staggerCAI.leaf.originalAnimatedAttributeValue).toBe(
      i * 20 + 100 + 'px',
    );
    expect(staggerCAI.leaf.constructionIngredients.props.duration).toBe(
      i * 200,
    );
    i++;
  }
});

test(`19. Test pattern expression on animatedProperty and duration`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@pattern(120px, 130px, 140px)',
        test: 12,
      },
    },
    {
      selector: '.a',
      duration: '@pattern(200, 400, 600)',
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);

  const animatedAttributesSplitters =
    myRootClip.realClip.children[Object.keys(myRootClip.realClip.children)[0]]
      .leaf.children;

  let i = 0;
  for (let id in animatedAttributesSplitters) {
    expect(
      animatedAttributesSplitters[id].leaf.data.attrs.animatedAttrs.stagger,
    ).toEqual(['120px', '130px', '140px'][i % 3]);
    expect(animatedAttributesSplitters[id].leaf.data.props.duration).toEqual(
      [200, 400, 600][i % 3],
    );

    const CAIkeys = Object.keys(animatedAttributesSplitters[id].leaf.children);
    const staggerCAI =
      animatedAttributesSplitters[id].leaf.children[CAIkeys[0]];
    expect(staggerCAI.leaf.originalAnimatedAttributeValue).toBe(
      ['120px', '130px', '140px'][i % 3],
    );
    expect(staggerCAI.leaf.constructionIngredients.props.duration).toBe(
      [200, 400, 600][i % 3],
    );
    i++;
  }
});

test(`20. Test attribute expression on animatedProperty`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div data-attr="100px" class="a"></div>
                <div data-attr="200px" class="a"></div>
                <div data-attr="300px" class="a"></div>
                <div data-attr="400px" class="a"></div>
                <div data-attr="500px" class="a"></div>
                <div data-attr="600px" class="a"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@attribute(data-attr)',
        test: 12,
      },
    },
    {
      selector: '.a',
      duration: 1000,
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);

  const animatedAttributesSplitters =
    myRootClip.realClip.children[Object.keys(myRootClip.realClip.children)[0]]
      .leaf.children;

  let i = 0;
  for (let id in animatedAttributesSplitters) {
    expect(
      animatedAttributesSplitters[id].leaf.data.attrs.animatedAttrs.stagger,
    ).toEqual(i * 100 + 100 + 'px');

    const CAIkeys = Object.keys(animatedAttributesSplitters[id].leaf.children);
    const staggerCAI =
      animatedAttributesSplitters[id].leaf.children[CAIkeys[0]];
    expect(staggerCAI.leaf.originalAnimatedAttributeValue).toBe(
      i * 100 + 100 + 'px',
    );
    i++;
  }
});

test(`21. Test stagger for incident exists in case of stagger props`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@stagger(100px,200px)',
        test: 12,
      },
    },
    {
      selector: '.test',
      duration: '@stagger(100, 200)',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(1);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.staggerProps).toEqual({
    mode: 'linear',
    from: 100,
    to: 200,
    unit: '',
    fraction: 0,
    easing: 'linear',
    reverse: false,
    type: 'amount',
    integer: undefined,
  });
});

test(`22. Test math expression for incident exists in case of math props`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@expression(100 + index*20)px',
        test: 12,
      },
    },
    {
      selector: '.test',
      duration: '@expression(100 + index*20)',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(1);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.expressionProps).toEqual({
    unit: '',
    expression: '(100+index*20)',
  });
});

test(`23. Test pattern expression for incident exists in case of pattern props`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@pattern(100px, 200px, 300px)',
        test: 12,
      },
    },
    {
      selector: '.test',
      duration: '@pattern(200, 400, 600)',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(1);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.patternProps).toEqual({
    type: 'amount',
    pattern: [200, 400, 600],
  });
});

test(`24 Test attribute expression for incident exists in case of attribute attr`, () => {
  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        stagger: '@attribute(data-attr)',
        test: 12,
      },
    },
    {
      selector: '.test',
      duration: 1000,
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(1);
  expect(newMPInc.attributesStaggers[0].path).toBe('animatedAttrs.stagger');
  expect(newMPInc.attributesStaggers[0].stagger.expressionProps).toEqual({
    attribute: 'data-attr',
  });
});

// ************************* Animation staggers ************************* //
test(`25. Test stagger for Animation exists in case of stagger props`, () => {
  const newMPInc = new TestPlugin.MPClip({
    selector: '.test',
    duration: '@stagger(100, 200)',
  });

  expect(newMPInc.attributesStaggers.length).toBe(0);
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.staggerProps).toEqual({
    mode: 'linear',
    from: 100,
    to: 200,
    unit: '',
    fraction: 0,
    easing: 'linear',
    reverse: false,
    type: 'amount',
    integer: undefined,
  });
});

test(`26. Test math expression for Animation exists in case of math props`, () => {
  const newMPInc = new TestPlugin.MPClip({
    selector: '.test',
    duration: '@expression(100 + index*20)',
  });

  expect(newMPInc.attributesStaggers.length).toBe(0);
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.expressionProps).toEqual({
    unit: '',
    expression: '(100+index*20)',
  });
});

test(`27. Test pattern expression for Animation exists in case of pattern props`, () => {
  const newMPInc = new TestPlugin.MPClip({
    selector: '.test',
    duration: '@pattern(200, 400, 600)',
  });

  expect(newMPInc.attributesStaggers.length).toBe(0);
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.patternProps).toEqual({
    type: 'amount',
    pattern: [200, 400, 600],
  });
});

test(`28. Test behaviour of @expression when parsed value is invalid`, () => {
  /* TODO right now when the parsed dynamic value is incompatible with the expected type MC doesn't
   handle it. May we can revisit that in the future */

  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
      <div id="my-root-div">
          <div data-attr="100px" class="a"></div>
      </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
    initParams: {
      string: 'string',
      number: 12,
    },
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: {
        test: '@expression(initParams.string)',
      },
    },
    {
      selector: '.a',
      duration: 1000,
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);
});

test(`29. Test that CASI containing @expressions entering another Clip gets parsed properly`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
      <div id="my-root-div">
          <div class="a" data-motorcortex2-id="a-1"></div>
          <div class="a" data-motorcortex2-id="a-2"></div>
      </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
    initParams: {
      string: 'string',
      number: 12,
      color: '#FFF',
    },
  });

  const newMPInc = new TestPlugin.MPClip2(
    {
      text: '@expression(initParams.string)',
      number: '@expression(index + 1)',
      color: '@expression(initParams.color)',
    },
    {
      selector: '.a',
      duration: '@pattern(200, 400, 600)',
      id: 'casi',
    },
  );

  expect(newMPInc.attributesStaggers.length).toBe(3);
  expect(newMPInc.propsStaggers.length).toBe(1);
  expect(newMPInc.propsStaggers[0].path).toBe('duration');
  expect(newMPInc.propsStaggers[0].stagger.patternProps).toEqual({
    type: 'amount',
    pattern: [200, 400, 600],
  });

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);
  const casis = myRootClip.realClip.children.casi.leaf.children;
  for (const casi_key in casis) {
    const casi = casis[casi_key];
    const rootElement =
      casi.leaf.contexts['my-root-clip'].ownClip.context.rootElement;
    expect(rootElement.innerHTML).toBe(
      '<div data-motorcortex2-id="123">string 1 #FFF</div>',
    );
  }
});

test(`30. Test removing a CASI with @expression from a Clip restores it back to NullClip realClip state`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
      <div id="my-root-div">
          <div class="a" data-motorcortex2-id="a-1"></div>
          <div class="a" data-motorcortex2-id="a-2"></div>
      </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
    initParams: {
      string: 'string',
      number: 12,
    },
  });

  const newMPInc = new TestPlugin.MPClip2(
    {
      text: '@expression(initParams.string)',
      number: '@expression(index + 1)',
    },
    {
      selector: '.a',
      duration: '@pattern(200, 400, 600)',
      id: 'casi',
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);
  expect(newMPInc.realClip).not.toBeInstanceOf(NullClip);
  const delres = myRootClip.removeIncident(newMPInc);
  expect(delres.result).toBe(true);
  expect(newMPInc.realClip).toBeInstanceOf(NullClip);
});

test(`31. Test object pass as initParam`, () => {
  document.body.innerHTML = `<div>
        <div id="clip-container"></div>
    </div>
    `;

  // ************* root Clip creation *******************
  const myRootClip = new HTMLClip({
    html: `
            <div id="my-root-div">
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
                <div class="a"></div>
            </div>`,
    css: ``,
    host: document.querySelector('#clip-container'),
    id: 'my-root-clip',
    initParams: {
      animatedAttrs: {
        stagger: '110px',
        test: 12,
      },
    },
  });

  const newMPInc = new TestPlugin.MPInc(
    {
      animatedAttrs: '@initParams.animatedAttrs',
    },
    {
      selector: '.a',
      duration: '@pattern(200, 400, 600)',
    },
  );

  const res = myRootClip.addIncident(newMPInc, 0);
  expect(res.result).toBe(true);

  const animatedAttributesSplitters =
    myRootClip.realClip.children[Object.keys(myRootClip.realClip.children)[0]]
      .leaf.children;

  let i = 0;
  for (let id in animatedAttributesSplitters) {
    expect(
      animatedAttributesSplitters[id].leaf.data.attrs.animatedAttrs.stagger,
    ).toEqual(['110px', '110px', '110px'][i % 3]);
    expect(animatedAttributesSplitters[id].leaf.data.props.duration).toEqual(
      [200, 400, 600][i % 3],
    );

    const CAIkeys = Object.keys(animatedAttributesSplitters[id].leaf.children);
    const staggerCAI =
      animatedAttributesSplitters[id].leaf.children[CAIkeys[0]];
    expect(staggerCAI.leaf.originalAnimatedAttributeValue).toBe(
      ['110px', '110px', '110px'][i % 3],
    );
    expect(staggerCAI.leaf.constructionIngredients.props.duration).toBe(
      [200, 400, 600][i % 3],
    );
    i++;
  }
});
