# Dynamic Values Development
Implementing a Dynamic Value is defining a regex pattern that will be validated, parsed and that it will calculate
the specific value of each element according it.

In order to create a new type of Dynamic Value you need to follow these steps:
1. Create a new folder to host your DV in `this` folder (`dynamicValues`)
2. Create 4 files:
    * conf.js
    * Handler.js
    * validation.js
    * index.js
   
    and we proceed with our Dynamic Value development
3. **conf.js** This file should export a conf object defining:
    * `preface` (mandatory): the preface identifier of your DV (e.g. "stagger" or "expression" will reserve the
    expressions "@stagger" and "@expression" respectively)
    * `supportedTypes` (mandatory): DVs are meant to be applied as attrs or props fields' values. 
    The supported types of fields by MC are: `amount`, `array`, `boolean`, `color`, `css`, `currency`, `date`, 
    `email`, `enum`, `html`, `measurement`, `number`, `object`, `string`, `tuple`, `url`. Each DVs might apply
    to different types. For example @stagger is great for numbers but has no meaning for strings or objects,
    @expression is great for numbers but has absolutely no meaning for objects, etc. On the `supportedTypes`
    property the developer must define an array of all the supported types by the DV
4. **validation.js** This file should expose one method that takes as input the following arguments: 
   1. `expression`: The provided string / expression by the user. E.g. "@stagger(0px, 100px)" or "@initParams.x". 
   In other words is the expression literal you need to validate (most probably by a regex)
   2. `logError`: If your code finds that the provided expression is invalid you use this method to log the error.
   This method takes just one argument, the error text that will be logged on the console of the user, e.g. 
   `logError('Invalid expression'')`
   3. `checkValues`: Creating Dynamic Values is creating regular expressions. By these regular expressions you
   define your Dynamic Value pattern, and then you extract the data you need in out of it. For example the string
   "@stagger(0px, 100px, 0.4, linear)" is been read by stagger implementation and the startValue ("0px"), endValue("100px")
   center (0.4) and easing ("linear") are been extracted out of the provided string. During validation a DV implementation
   might want to check some of its extracted values against the original schema of the field.
   4. `schema`: the validation schema of the entry. The purpose of this schema is strictly informative, and it should
   not be used for compiling or using validator directly.
   Check the following example:
   ```javascript
    // schema
    {
      num: {
        type: "number",
        min: 10,
      }
    }
   
    // provided value
    {
      num: "@stagger(5, 15)"
    }
    
    /*
    Our stagger implementation on this example wants to make sure that both the start and the end value
    must conform to the rest of the rules of the filed. In our example, all numbers must be min:10. On our validation
    method we can use the checkValues method provided as the third argument, and pass to it an array of values that
    we want to be checked against the original schema. On stagger implementation and on the specific example
    the values [5, 15] are passed to checkValues and value 5 gets rejected
    */
    ```
5. **Handler.js** This file should export a class which implements at least the following methods:
   * constructor(expressionParams): where `expressionParams` and object that has two keys:
     * `value` which is the actual value passed by the user (e.g. "@stagger(0, 200)")
     * `integer`: indicates whether the returned value must be an integer. Of course this information only has
     meaning when working on number or measurement - specific Dynamic Values
   * calculateValues(elements, initParams): where `elements` is an array of the elements that the DV will be applied while
   `initParams` is the initParams object of the Clip the Incident belongs to. It should return an array with the value 
   each element should take
   * resize(fraction): where fraction defines the resize factor (e.g. 2 for double duration and 0.5 for half). The method
   should return a new string for the DV that adapts this resize.
    