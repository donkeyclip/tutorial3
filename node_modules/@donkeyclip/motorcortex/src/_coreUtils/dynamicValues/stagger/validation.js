/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { staggerAnalyser } from './Handler';
import conf from './conf';
import _easings from '../../../_configuration/easings';
const easings = Object.keys(_easings);
import { numberPartRegexp, removeWhitespace } from '../../helper';

function validateStagger(staggerExpression, logError, checkValues, schema) {
  staggerExpression = removeWhitespace(staggerExpression);
  const staggerRegex =
    /^@stagger\(([A-z0-9.%-]+?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+))\)$/;
  // TODO dynamically get @stagger expression from conf
  if (!staggerRegex.test(staggerExpression)) {
    logError('Invalid @stagger expression');
    return false;
  }

  const analysis = staggerAnalyser(staggerExpression);

  if (analysis.startFraction < 0 || analysis.startFraction > 1) {
    logError(`The ${conf.preface} fraction must be a number >=0 and <=1`);
    return false;
  }
  if (!easings.includes(analysis.easing)) {
    logError(
      `The ${conf.preface} easing (${analysis.easing}) is not supported by the system`,
    );
    return false;
  }

  if (analysis.mode !== 'linear' && analysis.mode !== 'omni') {
    logError(`The ${conf.preface} mode should be either "linear" or "omni"`);
    return false;
  }
  if (analysis.reverse !== true && analysis.reverse !== false) {
    logError(`The ${conf.preface} reverse should be either true or false`);
    return false;
  }

  const startNumberPartMatches = analysis.start.match(numberPartRegexp);
  const endNumberPartMatches = analysis.end.match(numberPartRegexp);
  if (startNumberPartMatches === null || endNumberPartMatches === null) {
    logError(
      `The start and end units of a @stagger should always be the same. This doesn't stand for the couple ${analysis.start}, ${analysis.end}`,
    );
    return false;
  }

  const startNumberPart = startNumberPartMatches[0];
  const endNumberPart = endNumberPartMatches[0];
  const startUnits = analysis.start
    .toString()
    .substring(startNumberPart.length);
  const endUnits = analysis.end.toString().substring(endNumberPart.length);
  if (startUnits !== endUnits) {
    logError(
      `The start and end units of a @stagger should always be the same. ${startUnits}, ${endUnits} provided`,
    );
    return false;
  }

  // TODO if analysis start or end are not helper.isNumeric log and schema.type === 'number' logError & return false
  const start =
    schema.type === 'number' ? parseFloat(analysis.start) : analysis.start;
  const end =
    schema.type === 'number' ? parseFloat(analysis.end) : analysis.end;
  return checkValues([start, end]);
}

export default validateStagger;
