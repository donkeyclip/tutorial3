import Stagger, {
  staggerAnalyser,
  stagger,
  calcStaggerDistances,
} from '../Handler';
import validation from '../validation';

let errors = [];
const logError = (err) => {
  errors.push(err);
};

const errorTxt = 'Invalid @stagger expression';

const path = 'path.to.key';

test('ST 01. Linear test on stagger / middle', () => {
  const res = stagger(100, 200, 0.5);
  expect(res).toBe(150);
});

test('ST 02.Linear test on stagger / start', () => {
  const res = stagger(100, 200, 0);
  expect(res).toBe(100);
});

test('ST 03. Linear test on stagger / end', () => {
  const res = stagger(100, 200, 1);
  expect(res).toBe(200);
});

test('ST 04. StaggerAnalyser with only start and end value', () => {
  const res = staggerAnalyser('@stagger(100%, 300%)');
  expect(res).toEqual({
    start: '100%',
    end: '300%',
    startFraction: 0,
    easing: 'linear',
    mode: 'linear',
    reverse: false,
  });
});

test('ST 05. StaggerAnalyser with only start and end value and with multiple spaces', () => {
  const res = staggerAnalyser('  @stagger ( 100, 300 ) ');
  expect(res).toEqual({
    start: '100',
    end: '300',
    startFraction: 0,
    easing: 'linear',
    mode: 'linear',
    reverse: false,
  });
});

test('ST 06. Validation with invalid expression', () => {
  const res = validation('  stagger ( 100, 300 ) ', logError);
  expect(res).toBe(false);
  expect(errors[0]).toBe(errorTxt);
});

test('ST 07. Validation with only one parameter', () => {
  errors = [];
  const res = validation('  @stagger ( 100 ) ', logError);
  expect(res).toBe(false);
  expect(errors[0]).toBe(errorTxt);
});

test('ST 08. Validation with missing parenthesis', () => {
  errors = [];
  const res = validation('  @stagger ( 100, 200  ', logError);
  expect(res).toBe(false);
  expect(errors[0]).toBe(errorTxt);
});

test('ST 09. StaggerAnalyser with start value, end value and fraction', () => {
  const res = staggerAnalyser('  @stagger ( 100, 300, 0.5 ) ');
  expect(res).toEqual({
    start: '100',
    end: '300',
    startFraction: 0.5,
    easing: 'linear',
    mode: 'linear',
    reverse: false,
  });
});

test('ST 10. StaggerAnalyser with start, end, fraction and easing parameters passed', () => {
  const res = staggerAnalyser('  @stagger ( 100px, 300px, 0.5, elastic ) ');
  expect(res).toEqual({
    start: '100px',
    end: '300px',
    startFraction: 0.5,
    easing: 'elastic',
    mode: 'linear',
    reverse: false,
  });
});

test('ST 11. Resizing a stagger set should result to the exact same set with applying stagger with resized start and end values', () => {
  const staggered = [];
  const start = 122;
  const end = 345.6;
  for (let i = 0; i < 8; i++) {
    staggered[i] = stagger(start, end, i / 7, 'easeInQuart');
  }
  const multiplier = 0.87;
  for (let i = 0; i < 8; i++) {
    staggered[i] = (multiplier * staggered[i]).toFixed(4);
  }
  const staggered2 = [];
  for (let i = 0; i < 8; i++) {
    staggered2[i] = stagger(
      start * multiplier,
      end * multiplier,
      i / 7,
      'easeInQuart',
    ).toFixed(4);
  }
  expect(staggered).toEqual(staggered2);
});

/*
Test the new stagger expressions supporting mode and reverse
Also, test getStaggerDistances
*/
test('ST 12. Invalid stagger expression / too many arguments (7)', () => {
  errors = [];
  const res = validation(
    '  @stagger ( 100, 200, 0.5, test, test, test, test ) ',
    logError,
  );
  expect(res).toBe(false);
  expect(errors[0]).toBe(errorTxt);
});

test('ST 13. Valid stagger expression with start, end, fraction, easing and mode params', () => {
  const res = staggerAnalyser(
    '  @stagger ( 100px, 300px, 0.5, elastic, omni ) ',
  );
  expect(res).toEqual({
    start: '100px',
    end: '300px',
    startFraction: 0.5,
    easing: 'elastic',
    mode: 'omni',
    reverse: false,
  });
});

test('ST 14. Valid stagger expression with start, end, fraction, easing, mode and reverse', () => {
  const res = staggerAnalyser(
    '  @stagger ( 100px, 300px, 0.5, elastic, omni, true ) ',
  );
  expect(res).toEqual({
    start: '100px',
    end: '300px',
    startFraction: 0.5,
    easing: 'elastic',
    mode: 'omni',
    reverse: true,
  });
});

test('ST 15. staggerDistances on 11 elements/fraction=0/linear/linear/not reversed', () => {
  const res = calcStaggerDistances(11);
  expect(res).toEqual([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]);
});

test('ST 16. staggerDistances on 11 elements/fraction=0/linear/omni/not reversed', () => {
  const res = calcStaggerDistances(11, 0, 'omni', false);
  expect(res).toEqual([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]);
});

test('ST 17. staggerDistances on 11 elements/fraction=0/linear/linear/reversed', () => {
  const res = calcStaggerDistances(11, 0, 'linear', true);
  for (let i = 1, j = 0; i >= 0; i -= 0.1, j++) {
    expect(res[j]).toBeCloseTo(i);
  }
});

test('ST 18. staggerDistances on 11 elements/fraction=0/linear/omni/reversed', () => {
  const res = calcStaggerDistances(11, 0, 'omni', true);
  for (let i = 1, j = 0; i >= 0; i -= 0.1, j++) {
    expect(res[j]).toBeCloseTo(i);
  }
});

test('ST 19. staggerDistances on 11 elements/fraction=0.4/linear/linear/not reversed', () => {
  const res = calcStaggerDistances(11, 0.4, 'linear', false);
  const expected = [0.7, 0.8, 0.9, 1, 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6];
  for (let i = 0; i < 11; i++) {
    expect(res[i]).toBeCloseTo(expected[i]);
  }
});

test('ST 20. staggerDistances on 11 elements/fraction=0.4/linear/omni/not reversed', () => {
  const res = calcStaggerDistances(11, 0.4, 'omni', false);
  const expected = [
    4 / 6,
    3 / 6,
    2 / 6,
    1 / 6,
    0,
    1 / 6,
    2 / 6,
    3 / 6,
    4 / 6,
    5 / 6,
    // eslint-disable-next-line sonarjs/no-identical-expressions
    6 / 6,
  ];
  for (let i = 0; i < 11; i++) {
    expect(res[i]).toBeCloseTo(expected[i]);
  }
});

test('ST 21. staggerDistances on 11 elements/fraction=0.4/linear/linear/reversed', () => {
  const res = calcStaggerDistances(11, 0.4, 'linear', true);
  const expected = [0.3, 0.2, 0.1, 0, 1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4];
  for (let i = 0; i < 11; i++) {
    expect(res[i]).toBeCloseTo(expected[i]);
  }
});

test('ST 22. staggerDistances on 11 elements/fraction=0.4/linear/omni/reversed', () => {
  const res = calcStaggerDistances(11, 0.4, 'omni', true);
  const expected = [
    1 - 4 / 6,
    1 - 3 / 6,
    1 - 2 / 6,
    1 - 1 / 6,
    1,
    1 - 1 / 6,
    1 - 2 / 6,
    1 - 3 / 6,
    1 - 4 / 6,
    1 - 5 / 6,
    // eslint-disable-next-line sonarjs/no-identical-expressions
    1 - 6 / 6,
  ];
  for (let i = 0; i < 11; i++) {
    expect(res[i]).toBeCloseTo(expected[i]);
  }
});

test('ST 23. Stagger Class -> calculateValues', () => {
  const stagger = new Stagger({
    incidentId: 'incidentId',
    path: path,
    value: '@stagger(100px, 200px)',
  });
  const res = stagger.calculateValues([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  expect(res).toEqual([
    '100px',
    '110px',
    '120px',
    '130px',
    '140px',
    '150px',
    '160px',
    '170px',
    '180px',
    '190px',
    '200px',
  ]);
});

test('ST 24. Test stagger calculateValues for amounts always returns numbers', () => {
  const stagger = new Stagger({
    incidentId: 'incidentId',
    path: path,
    value: '@stagger(100, 200)',
  });
  const res = stagger.calculateValues([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  expect(res).toEqual([100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]);
});

test('ST 25. Test stagger calculateValues for measurement, which has integer=true, always returns integer', () => {
  const stagger = new Stagger({
    incidentId: 'incidentId',
    path: path,
    value: '@stagger(1px, 2px)',
    integer: true,
  });
  const res = stagger.calculateValues([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  expect(res).toEqual([
    '1px',
    '1px',
    '1px',
    '1px',
    '1px',
    '2px',
    '2px',
    '2px',
    '2px',
    '2px',
    '2px',
  ]);
});

test('ST 26. Test stagger resize', () => {
  const stagger = new Stagger({
    dynamicType: 'stagger',
    path: path,
    value: '@stagger(1000px, 2000px, 0.4)',
  });
  const res = stagger.resize(0.5);
  expect(res).toBe('@stagger(500px, 1000px, 0.4, linear, linear, false)');
});

test('ST 27. Test unitless stagger resize', () => {
  const stagger = new Stagger({
    incidentId: 'incidentId',
    path: path,
    value: '@stagger(1000, 2000, 0.4)',
  });
  const res = stagger.resize(0.5);
  expect(res).toBe('@stagger(500, 1000, 0.4, linear, linear, false)');
});

test(`ST 28. Test stagger on only one element`, () => {
  const stagger = new Stagger({
    incidentId: 'incidentId',
    path: path,
    value: '@stagger(0, 1000)',
    integer: true,
  });
  const res = stagger.calculateValues([0]);
  expect(res).toEqual([0]);
});
