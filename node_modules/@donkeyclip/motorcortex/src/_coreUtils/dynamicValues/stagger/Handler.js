/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import easings from '../../../_configuration/easings';
import { numberPartRegexp, removeWhitespace } from '../../helper';

/**
 * @param {string} staggerExpression: a stagger expression such as @stagger(300px, 500px, 0.5, linear)
 * @retuns {object}: the staggerExpression analysed into its ingredients:
 *  {start, end, startFraction, easing}
 **/
export function staggerAnalyser(staggerExpression) {
  staggerExpression = removeWhitespace(staggerExpression);

  const onlyWithinParenthesesRegexp = /.*\((.*)\).*/;
  const content = onlyWithinParenthesesRegexp.exec(staggerExpression)[1];
  const staggerParams = content.split(',');
  return {
    start: staggerParams[0],
    end: staggerParams[1],
    startFraction: 1 * staggerParams[2] || 0,
    easing: staggerParams[3] || 'linear',
    mode: staggerParams[4] || 'linear',
    reverse: staggerParams[5] === 'true',
  };
}

/**
 * @param {number} start: the start (minimum) value of the range
 * @param {number} end: the end (maximum) value of the range
 * @param {number} distanceFromStart: the distance of the element from the start (from 0 to 1)
 * @param {string} easing: the easing we want to apply
 **/
export function stagger(start, end, distanceFromStart, easing) {
  if (!easing) {
    easing = 'linear';
  }

  // the position of the element on the range from 0 to 1
  const easedPositionOnSet = easings[easing](distanceFromStart);
  return easedPositionOnSet * (end - start) + start;
}

/**
 * Given the stagger params: totalElements, startPoint, mode, and reverse this method calculates the distance of each
 * element of the set (from 0 to 1) from the starting stagger point.
 * @param {integer} totalElements: the number of elements of the set
 * @param {number} startPoint: the starting point of the stagger (0 to 1)
 * @param {string} mode: (defaults to "linear") one of "linear" and "omni"
 * @param {boolean} reverse: (defaults to false). If is set to reverse the stagger will be applied in reverse sequence
 * @returns {array}: an array containing the distance of each element from the starting point (from 0 to 1)
 **/
export function calcStaggerDistances(
  totalElements,
  startPoint = 0,
  mode = 'linear',
  reverse = false,
) {
  const distances = [];
  if (mode === 'linear') {
    for (let i = 0; i < totalElements; i++) {
      const position = i / (totalElements - 1);
      let distance =
        position < startPoint
          ? position + 1 - startPoint + 1 / (totalElements - 1)
          : position - startPoint;

      if (reverse) {
        distance = 1 - distance;
      }
      distances.push(distance);
    }
  } else if (mode === 'omni') {
    const maxDistance = 1 - startPoint;
    for (let i = 0; i < totalElements; i++) {
      const absDistance = Math.abs(i / (totalElements - 1) - startPoint);
      let position = absDistance / maxDistance;
      if (reverse) {
        position = 1 - position;
      }
      distances.push(position);
    }
  }
  return distances;
}

export default class StaggerClass {
  constructor(staggerProps) {
    const analysis = staggerAnalyser(staggerProps.value);

    const startNumberPart = analysis.start.match(numberPartRegexp)[0];
    const endNumberPart = analysis.end.match(numberPartRegexp)[0];

    const units = analysis.start.toString().substring(startNumberPart.length);

    this.staggerProps = {
      from: startNumberPart * 1,
      to: endNumberPart * 1,
      mode: analysis.mode,
      unit: units,
      fraction: analysis.startFraction,
      easing: analysis.easing,
      reverse: analysis.reverse,
      type: units === '' ? 'amount' : 'measurement',
      integer: staggerProps.integer,
    };
  }

  /* resizes the stagger to the given fraction */
  resize(fraction) {
    this.staggerProps.from *= fraction;
    this.staggerProps.to *= fraction;
    if (this.staggerProps.integer === true) {
      this.staggerProps.from = Math.round(this.staggerProps.from);
      this.staggerProps.to = Math.round(this.staggerProps.to);
    }
    return `@stagger(${this.staggerProps.from}${this.staggerProps.unit}, ${
      this.staggerProps.to
    }${this.staggerProps.unit}, ${this.staggerProps.fraction || 0}, ${
      this.staggerProps.easing || 'linear'
    }, ${this.staggerProps.mode || 'linear'}, ${
      this.staggerProps.reverse || false
    })`;
  }

  calculateValues(elements) {
    const totalElements = elements.length;
    if (totalElements < 2) {
      return [this.staggerProps.from];
    }
    const distances = calcStaggerDistances(
      totalElements,
      this.staggerProps.fraction,
      this.staggerProps.mode,
      this.staggerProps.reverse,
    );
    const values = [];
    for (let i = 0; i < distances.length; i++) {
      let value = stagger(
        this.staggerProps.from,
        this.staggerProps.to,
        distances[i],
        this.staggerProps.easing,
      );
      if (this.staggerProps.integer === true) {
        value = Math.round(value);
      }
      if (this.staggerProps.type === 'measurement') {
        value += this.staggerProps.unit;
      }
      values.push(value);
    }

    return values;
  }
}
