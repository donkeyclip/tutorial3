import IPDV from '../index';
import conf from '../conf';
const path = 'path.to.attr',
  expression = '@initParams.x';

test('InitParams 01. Test calculateValues for valid measurement pattern', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: expression,
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], { x: 4 });
  expect(values).toEqual([4, 4, 4, 4, 4]);
});

test('InitParams 02. Test object type initParam', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: expression,
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], { x: { a: 'b' } });
  expect(values).toEqual([
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
  ]);
});

test('InitParams 03. Test array type initParam', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: expression,
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], { x: [1] });
  expect(values).toEqual([[1], [1], [1], [1], [1]]);
});

test('InitParams 04. Invalid initParams', () => {
  let errors = '';
  function logError(txt) {
    errors = txt;
  }
  expect(IPDV.validation('@initParams.x.', logError)).toBe(false);
  expect(errors).toBe(`Invalid ${conf.preface} expression`);
});

test('InitParams 05. Valid initParams', () => {
  let errors = '';
  function logError(txt) {
    errors = txt;
  }
  expect(IPDV.validation('@initParams.x', logError)).toBe(true);
  expect(errors).toBe(``);
});

test('InitParams 06. Test array type initParam', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: '@initParams.items[0]',
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], {
    items: [{ a: 'b' }],
  });
  expect(values).toEqual([
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
    { a: 'b' },
  ]);
});

test('InitParams 07. Test array type initParam with use of index', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: '@initParams.items[index]',
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], {
    items: [{ a: 'a' }, { a: 'b' }, { a: 'c' }, { a: 'd' }, { a: 'e' }],
  });
  expect(values).toEqual([
    { a: 'a' },
    { a: 'b' },
    { a: 'c' },
    { a: 'd' },
    { a: 'e' },
  ]);
});

test('InitParams 08. Test array type initParam with use of index', () => {
  const expressionParams = {
    dynamicType: 'initParams',
    value: '@initParams.items[index%2]',
    path: path,
  };
  const pattern = new IPDV.Handler(expressionParams);
  const values = pattern.calculateValues([0, 1, 2, 3, 4], {
    items: [{ a: 'a' }, { a: 'b' }, { a: 'c' }, { a: 'd' }, { a: 'e' }],
  });
  expect(values).toEqual([
    { a: 'a' },
    { a: 'b' },
    { a: 'a' },
    { a: 'b' },
    { a: 'a' },
  ]);
});
