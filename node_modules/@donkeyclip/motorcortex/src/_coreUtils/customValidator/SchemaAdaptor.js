/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import createProxy from '../proxies/ObjectProxy/ObjectProxy';
import { dynamicValuesChecker } from './dynamicValuesCheck';

function entryName(path) {
  return path[path.length - 1];
}

/**
 * SchemaAdaptor Class does exactly what its name implies. It adapts the schema (targeting the fastest-validator library)
 * so it better serves the special needs of MotorCortex validation mechanism. In order to keep the initial schema untouched
 * SchemaAdaptor uses the ObjectProxy class (of MC)
 * In more details what our Adaptor does is:
 *  - change all type: 'measurement' attrs to type: 'custom' with 'check' method the custom measurement method of ours
 *  - change all type: 'amount' attrs to type: 'custom' with 'check' method the custom amount method of ours
 *  - change all other types so they have dual check (in fastest-validator this is supported by passing an array as schema
 *      each element of which defines the alternative check). The first check is the one defined by the user while the
 *      second is a check that we add so we validate expressions of type "@initParams.<x>.<y>" and support @initParams
 *      dynamic value everywhere.
 * - The same (multiple checks via array) technique is applied on array .items value
 */
export default class SchemaAdaptor {
  constructor(schema) {
    this.schema = schema;
    this.adapted = createProxy(schema);
  }

  /**
   * It changes the provided entry in the provided path
   * @param (array) path: The path of the entry in array format
   * @param (object) entry: The entry itself
   */
  entryChange(path, entry) {
    const pathToPass = path.join('.');

    // fastest-validator supports array values for multiple alternative schemas for
    // the same attribute
    if (Array.isArray(entry)) {
      for (let i = 0; i < entry.length; i++) {
        this.entryChange(path.concat([`${i}`]), entry[i]);
      }
      return;
    }

    switch (entry.type) {
      case 'object':
        this.adapted.setValue(
          pathToPass,
          this.createObject(entry, entryName(path)),
        );
        break;
      case 'array':
        this.adapted.setValue(
          pathToPass,
          this.createArray(entry, entryName(path)),
        );
        break;
      default:
        this.adapted.setValue(pathToPass, [
          entry,
          {
            type: 'custom',
            optional: entry.optional !== false,
            check: dynamicValuesChecker(entry, entryName(path)),
          },
        ]);
    }
  }

  /**
   * @param {object} obj: The schema of the array (starting from root)
   * @param {string} name: The name of the entry to be checked
   * @returns {array}: A Proxied representation of the original schema
   */
  createArray(arr, name) {
    const propsLikeShcema = {
      items: arr.items,
    };
    const localAdaptor = new SchemaAdaptor(propsLikeShcema);
    const adaptedItems = localAdaptor.adaptSchema();

    return [
      { ...arr, items: adaptedItems.items },
      {
        type: 'custom',
        optional: arr.optional !== false,
        check: dynamicValuesChecker(arr, name),
      },
    ];
  }

  /**
   *
   * @param {object} obj: The schema of the object (starting from root)
   * @param {string} name: The name of the entry to be checked
   * @returns {array}: A Proxied representation of the original schema
   */
  createObject(obj, name) {
    const localAdaptor = new SchemaAdaptor(obj.props ?? {});
    const adapted = localAdaptor.adaptSchema();

    return [
      { ...obj, props: adapted },
      {
        type: 'custom',
        optional: obj.optional !== false,
        check: dynamicValuesChecker(obj, name),
      },
    ];
  }

  adaptSchema() {
    this.objectPropsChange([], this.schema);
    return this.adapted;
  }

  /**
   *
   * @param {array} path: The path of the keys set to analyse
   * @param {object} obj: This object represents the `props` object of an `object`
   */
  objectPropsChange(path, obj) {
    // for each key of the object
    for (let key in obj) {
      // take the entry
      this.entryChange(path.concat([key]), obj[key]);
    }
  }
}
