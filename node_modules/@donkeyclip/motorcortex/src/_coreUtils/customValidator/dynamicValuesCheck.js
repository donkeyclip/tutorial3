/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import helper, { isString } from '../helper';
import { getDVs } from '../dynamicValues/DVRegistry';
const dvs = getDVs();

import { validator } from './core';
import { unsupportedDVTypesSchemaCheck } from '../../_configuration/generalConf';

/**
 * Method checkDynamicValues is the one that is called on runtime in order to check any property for dynamic values
 * This method should:
 * - identify whether or not there is a dynamic value expression present
 * - if it is it should execute the corresponding validation method of the corresponding dynamic value implementation
 * - all validation methods provided by the dynamic values implementations will take in the following arguments:
 * -- value
 * -- logError: function to log errors. The only thing that it'll take as argument is what to log
 * @param value
 * @param errors
 * @param key
 * @param schema
 * @param entryName
 * @param compiledCheckFunct
 * @returns {*}
 */
function checkDynamicValues(
  value,
  errors,
  key,
  schema,
  entryName,
  compiledCheckFunct,
) {
  const logError = function (txt) {
    errors.push({
      type: schema.type,
      message: txt,
      actual: value,
    });
  };

  // if the value it's not a string we just pass
  if (!isString(value)) {
    logError('Not a dynamic value expression');
    return;
  }

  /**
   * This method accepts one argument of type array which enums all vals that should be checked against the original
   * definition schema of the property. The only property types that support this method are numbers and measurements
   * @param {array} vals
   * @return {boolean}
   */
  const checkVals = function (vals) {
    if (unsupportedDVTypesSchemaCheck.indexOf(schema.type) >= 0) {
      helper.warning(
        `${schema.type} does not support checkValues method. Returning true without validation`,
      );
      return true;
    }
    let valid = true;
    for (let i = 0; i < vals.length; i++) {
      const check = compiledCheckFunct({ [entryName]: vals[i] });
      if (check !== true) {
        valid = false;
        errors.push(...check);
      }
    }
    return valid;
  };

  for (let i = 0; i < dvs.length; i++) {
    const dv = dvs[i];
    if (value.trim().startsWith(`@${dv.preface}`)) {
      const staggerValid = dv.validation(value, logError, checkVals, schema);
      if (staggerValid) {
        return value;
      }
    }
  }

  logError('Not a valid dynamic value expression');
}

export const dynamicValuesChecker = (schema, entryName) => {
  const compiledCheckFunct = validator.compile({ [entryName]: schema }); // fastest-validator's schema must be an object's keys
  return function _checkDynamicValues(value, errors, key) {
    return checkDynamicValues(
      value,
      errors,
      key,
      schema,
      entryName,
      compiledCheckFunct,
    );
  };
};
