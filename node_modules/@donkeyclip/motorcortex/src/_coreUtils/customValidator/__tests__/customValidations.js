import { analyseContainerParams, originalDimsCheck } from '../../helper';
import v from '../index';

const wrongStagger = '@stagger(edo exo lathos';
const invalidStaggerMessage = 'Invalid @stagger expression';
const invalidDVMessage = 'Not a valid dynamic value expression';
const patternMinus6_2 = '@pattern(-6, 2)';
const pattern100 = '@pattern(100)';
const am_must_be_a_number = "The 'am' field must be a number.";
const amAdv_min_message =
  "The 'amAdv' field must be greater than or equal to -1.";
const amAdv_max_message = "The 'amAdv' field must be less than or equal to 12.";
const amAdv_int_message = "The 'amAdv' field must be an integer.";
const amAdv_number_message = "The 'amAdv' field must be a number.";
const stagger_zero_string = '@stagger(0, abc)';
const stagger_minus7_8 = '@stagger(-7, 8)';
const stagger_30_0 = '@stagger(30, 0)';
const stagger_2point3_6 = '@stagger(2.3, 6)';
const higherThanMax = `measurement - The provided value of measure (15%) is bigger than the schema's max`;

const colorValidation = {
  colorA: {
    type: 'color',
  },
};

const numberValidation = {
  num: {
    type: 'number',
  },
};

const measurementValidation = {
  measure: {
    type: 'measurement',
    units: ['px', '%', 'pt', ''],
  },
};

const measurementAdvancedValidation = {
  measure: {
    type: 'measurement',
    units: ['px', '%', 'pt'],
    min: -4,
    max: 10,
    integer: true,
  },
};

const amountValidation = {
  am: {
    type: 'amount',
    optional: true,
  },
  amAdv: {
    type: 'amount',
    min: -1,
    max: 12,
    integer: true,
    optional: true,
  },
};

test(`AV.1 Valid hex color`, () => {
  expect(v.validate({ colorA: '#FFFFFF' }, colorValidation)).toBe(true);
});
test(`AV.2 Invalid hex color`, () => {
  expect(v.validate({ colorA: '#ff00f' }, colorValidation)).not.toBe(true);
});
test(`AV.3 Valid rgb color`, () => {
  expect(v.validate({ colorA: 'rgb(0, 0, 0)' }, colorValidation)).toBe(true);
});
// TODO: reanble this once jest supports the full css spec
// test(`AV.4 Valid rgb color`, () => {
//   expect(v.validate({ colorA: 'rgb(-100, -10, 0 )' }, colorValidation)).toBe(
//     true,
//   );
// });
test(`AV.5 Invalid rgb color`, () => {
  expect(v.validate({ colorA: 'rgb(-100, -10 0 )' }, colorValidation)).not.toBe(
    true,
  );
});
// TODO: reanble this once jest supports the full css spec
// test(`AV.6 Valid rgb color`, () => {
//   expect(
//     v.validate(
//       { colorA: 'rgb(0,       0  , 0                          )' },
//       colorValidation,
//     ),
//   ).toBe(true);
// });
test(`AV.7 Invalid hls color`, () => {
  expect(
    v.validate({ colorA: 'hsl(100%, 100%, 100%, 1009)' }, colorValidation),
  ).not.toBe(true);
});
// TODO: reanble this once jest supports the full css spec
// test(`AV.8 Valid hsla color`, () => {
//   expect(
//     v.validate({ colorA: 'hsla(100%, 100%, 100%, 1)' }, colorValidation),
//   ).toBe(true);
// });

test(`AV.9 Valid rgba color`, () => {
  expect(
    v.validate({ colorA: 'rgba(100%, 100%, 100%, 1)' }, colorValidation),
  ).toBe(true);
});
test(`AV.10 Invalid rgba color`, () => {
  expect(v.validate({ colorA: 'rgba(0,0,0, a)' }, colorValidation)).toBe(true);
});
test(`AV.11 Valid keyword color`, () => {
  expect(v.validate({ colorA: 'AliceBlue' }, colorValidation)).toBe(true);
});
test(`AV.12 Invalid keyword color`, () => {
  expect(v.validate({ colorA: '_white' }, colorValidation)).not.toBe(true);
});
test(`AV.13 Valid measurement`, () => {
  expect(v.validate({ measure: '800px' }, measurementValidation)).toBe(true);
});
test(`AV.14 Valid measurement`, () => {
  expect(v.validate({ measure: '-2%' }, measurementValidation)).toBe(true);
});
test(`AV.15 Invalid measurement`, () => {
  expect(v.validate({ measure: '-2 pt' }, measurementValidation)).not.toBe(
    true,
  );
});
test(`AV.16 Valid measurement`, () => {
  expect(v.validate({ measure: '-0.2pt' }, measurementValidation)).toBe(true);
});
test(`AV.17 Valid min/max/integer measurement`, () => {
  expect(v.validate({ measure: '-2pt' }, measurementAdvancedValidation)).toBe(
    true,
  );
});
test(`AV.18 Invalid min measurement`, () => {
  expect(
    v.validate({ measure: '-12pt' }, measurementAdvancedValidation),
  ).not.toBe(true);
});
test(`AV.19 Invalid max measurement`, () => {
  expect(
    v.validate({ measure: '200pt' }, measurementAdvancedValidation),
  ).not.toBe(true);
});
test(`AV.20 Valid integer measurement`, () => {
  expect(
    v.validate({ measure: '-0.2pt' }, measurementAdvancedValidation),
  ).not.toBe(true);
});
test(`AV.21 Pass a number as measurement`, () => {
  expect(v.validate({ measure: 12 }, measurementAdvancedValidation)).not.toBe(
    true,
  );
});
test(`AV.22 Pass a number on color`, () => {
  expect(v.validate({ colorA: 112 }, colorValidation)).not.toBe(true);
});
test(`AV.23 Helper originalDimsCheck, not an object`, () => {
  const toCheck = 4;
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.24 Helper originalDimsCheck, not containing width`, () => {
  const toCheck = { height: '12px' };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.25 Helper originalDimsCheck, not containing heigth`, () => {
  const toCheck = { width: '12px' };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.26 Helper originalDimsCheck containing invalid width value`, () => {
  const toCheck = { width: '12apx', height: '15%' };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.27 Helper originalDimsCheck containing invalid height value`, () => {
  const toCheck = { width: '12px', height: '15f%' };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.28 Helper originalDimsCheck containing valid width & height values`, () => {
  const toCheck = { width: '12px', height: '15%' };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(true);
  expect(result.analysis).toEqual({
    width: {
      number: 12,
      unit: 'px',
    },
    height: {
      number: 15,
      unit: '%',
    },
  });
});
test(`AV.29 Helper originalDimsCheck containing non-string values of width and height`, () => {
  const toCheck = { width: 12, height: 15 };
  const result = originalDimsCheck(toCheck);
  expect(result.result).toBe(false);
});
test(`AV.30 Helper containerParams check containing only a valid width and no height`, () => {
  const toCheck = { width: '12px' };
  const result = analyseContainerParams(toCheck);
  expect(result).toEqual({
    width: {
      number: 12,
      unit: 'px',
    },
    height: null,
  });
});
test(`AV.31 Helper containerParams check containing only a valid height and no width`, () => {
  const toCheck = { height: '12px' };
  const result = analyseContainerParams(toCheck);
  expect(result).toEqual({
    height: {
      number: 12,
      unit: 'px',
    },
    width: null,
  });
});

test(`AV.32 Invalid measurement stagger expression`, () => {
  const res = v.validate({ measure: wrongStagger }, measurementValidation);
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(edo exo lathos",
  );
  expect(res[1].message).toBe(invalidStaggerMessage);
});

test(`AV.33 Invalid measurement stagger expression because of wrong number of params (only 1)`, () => {
  const res = v.validate({ measure: '@stagger(100px)' }, measurementValidation);
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(100px)",
  );
  expect(res[1].message).toBe(invalidStaggerMessage);
});

test('AV 34. Valid measurement stagger expression with start, end and fraction params passed', () => {
  const res = v.validate(
    { measure: '@stagger(100px, 200px, 0.5)' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test(`AV.35 Invalid measurement stagger expression because of wrong easing`, () => {
  const res = v.validate(
    { measure: '@stagger(100px, 200px, 0.4, non existing)' },
    measurementValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    `The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(100px, 200px, 0.4, non existing)`,
  );
  expect(res[1].message).toBe(
    'The stagger easing (nonexisting) is not supported by the system',
  );
});

test('AV.36 Valid measurement stagger expression with all parameters passed', () => {
  const res = v.validate(
    { measure: '@stagger(100px, 200px, 0.5, linear)' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test('AV 37. Valid measurement stagger expression with only start and end', () => {
  const res = v.validate(
    { measure: '@stagger(100px, 200px)' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test('AV 38. Invalid measurement stagger expression because of fraction < 0', () => {
  const res = v.validate(
    { measure: '@stagger(100px, 200px, -2)' },
    measurementValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(100px, 200px, -2)",
  );
  expect(res[1].message).toBe(
    'The stagger fraction must be a number >=0 and <=1',
  );
});

test(`AV.39 Invalid measurement stagger expression because of invalid start value`, () => {
  const res = v.validate(
    { measure: '@stagger(abc, 200px)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(abc, 200px)",
  );
  expect(res[1].message).toBe(
    "The start and end units of a @stagger should always be the same. This doesn't stand for the couple abc, 200px",
  );
});

test(`AV.40 Invalid measurement stagger expression because of invalid end value`, () => {
  const res = v.validate(
    { measure: '@stagger(-2pt, abc)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(-2pt, abc)",
  );
  expect(res[1].message).toBe(
    "The start and end units of a @stagger should always be the same. This doesn't stand for the couple -2pt, abc",
  );
});

test(`AV.41 Valid measurement stagger expression on advanced measurement configuration`, () => {
  const res = v.validate(
    { measure: '@stagger(-2pt, 6pt)' },
    measurementAdvancedValidation,
  );
  expect(res).toBe(true);
});

test(`AV.42 Invalid measurement stagger start on advanced measurement configuration / min`, () => {
  const res = v.validate(
    { measure: '@stagger(-7pt, 8pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(-7pt, 8pt)",
  );
  expect(res[1].message).toBe(
    "measurement - The provided value of measure (-7pt) is smaller than the schema's min",
  );
});

test(`AV.43 Invalid measurement stagger start on advanced measurement configuration / max`, () => {
  const res = v.validate(
    { measure: '@stagger(23pt, 6pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(23pt, 6pt)",
  );
  expect(res[1].message).toBe(
    "measurement - The provided value of measure (23pt) is bigger than the schema's max",
  );
});

test(`AV.44 Invalid measurement stagger start on advanced measurement configuration / integer`, () => {
  const res = v.validate(
    { measure: '@stagger(2.3pt, 6pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(2.3pt, 6pt)",
  );
  expect(res[1].message).toBe(
    'measurement - The provided value of measure (2.3pt) is not an integer',
  );
});

test(`AV.45 Invalid measurement stagger end on advanced measurement configuration / min`, () => {
  const res = v.validate(
    { measure: '@stagger(0pt, -19pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(0pt, -19pt)",
  );
  expect(res[1].message).toBe(
    "measurement - The provided value of measure (-19pt) is smaller than the schema's min",
  );
});

test(`AV.46 Invalid measurement stagger end on advanced measurement configuration / max`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 60pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(2pt, 60pt)",
  );
  expect(res[1].message).toBe(
    "measurement - The provided value of measure (60pt) is bigger than the schema's max",
  );
});

test(`AV.47 Invalid measurement stagger end on advanced measurement configuration / integer`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 6.5pt)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(2pt, 6.5pt)",
  );
  expect(res[1].message).toBe(
    'measurement - The provided value of measure (6.5pt) is not an integer',
  );
});

test(`AV.48 Invalid measurement stagger due to different start and end units`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 6px)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(2pt, 6px)",
  );
  expect(res[1].message).toBe(
    'The start and end units of a @stagger should always be the same. pt, px provided',
  );
});

test(`AV.49 Invalid measurement stagger due to wrong mode parameter`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 6pt, 0.5, linear, wrong)' },
    measurementAdvancedValidation,
  );
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(
    "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @stagger(2pt, 6pt, 0.5, linear, wrong)",
  );
  expect(res[1].message).toBe(
    'The stagger mode should be either "linear" or "omni"',
  );
});

test(`AV.50 Invalid measurement stagger reverse parameter results to reverse=false`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 6pt, 0.5, linear, omni, wrong)' },
    measurementAdvancedValidation,
  );
  expect(res).toBe(true);
});

test(`AV.51 Valid unitless measurement`, () => {
  expect(v.validate({ measure: '800' }, measurementValidation)).toBe(true);
});

test('AV 52. Valid measurement stagger expression with unitless start, unitless end and fraction params passed', () => {
  const res = v.validate(
    { measure: '@stagger(100, 200, 0.5)' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test(`AV.53 Valid measurement stagger with all 6 params passed`, () => {
  const res = v.validate(
    { measure: '@stagger(2pt, 6pt, 0.5, easeOutCubic, linear, true)' },
    measurementAdvancedValidation,
  );
  expect(res).toBe(true);
});

test('AV.54 Valid simple amount', () => {
  const res = v.validate({ am: 2 }, amountValidation);
  expect(res).toBe(true);
});

test('AV.55 Invalid amount (string)', () => {
  const res = v.validate({ am: 'test' }, amountValidation);
  expect(res).not.toBe(true);
  expect(res[0]).toEqual({
    type: 'number',
    message: am_must_be_a_number,
    field: 'am',
    actual: 'test',
  });
});

test('AV 56. Invalid amount (min)', () => {
  const res = v.validate({ amAdv: -6 }, amountValidation);
  expect(res).not.toBe(true);
  expect(res[0]).toEqual({
    type: 'numberMin',
    message: amAdv_min_message,
    field: 'amAdv',
    actual: -6,
    expected: -1,
  });
});

test('AV 57. Invalid amount (max)', () => {
  const res = v.validate({ amAdv: 100 }, amountValidation);
  expect(res).not.toBe(true);
  expect(res[0]).toEqual({
    type: 'numberMax',
    message: amAdv_max_message,
    field: 'amAdv',
    actual: 100,
    expected: 12,
  });
});

test('AV.58 Integer amount directive)', () => {
  const res = v.validate({ amAdv: 4.3 }, amountValidation);
  expect(res).not.toBe(true);
  expect(res[0]).toEqual({
    type: 'numberInteger',
    message: amAdv_int_message,
    field: 'amAdv',
    actual: 4.3,
  });

  const res2 = v.validate({ amAdv: 4 }, amountValidation);
  expect(res2).toBe(true);
});

test(`AV.59 Invalid amount stagger expression`, () => {
  const res = v.validate({ amAdv: wrongStagger }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      actual: wrongStagger,
      field: 'amAdv',
      message: amAdv_number_message,
      type: 'number',
    },
    {
      actual: wrongStagger,
      field: 'amAdv',
      message: invalidStaggerMessage,
      type: 'number',
    },
    {
      actual: wrongStagger,
      field: 'amAdv',
      message: invalidDVMessage,
      type: 'number',
    },
  ]);
});

test(`AV.60 Invalid amount stagger expression because of wrong number of params (only 1)`, () => {
  const res = v.validate({ amAdv: '@stagger(0)' }, amountValidation);
  expect(res).not.toBe(true);
  expect(res[0].message).toBe(amAdv_number_message);
});

test('AV 61. Valid amount stagger expression with start, end and fraction params passed', () => {
  const res = v.validate({ am: '@stagger(100, 200, 0.5)' }, amountValidation);
  expect(res).toBe(true);
});

test(`AV.62 Invalid amount stagger expression because of wrong easing`, () => {
  const stagger = '@stagger(100, 200, 0.4, non existing)';
  const res = v.validate({ am: stagger }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: stagger,
    },
    {
      message:
        'The stagger easing (nonexisting) is not supported by the system',
      field: 'am',
      type: 'number',
      actual: stagger,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test('AV.63 Valid amount stagger expression with all parameters passed', () => {
  const res = v.validate(
    { am: '@stagger(100, 200, 0.5, linear)' },
    amountValidation,
  );
  expect(res).toBe(true);
});

test('AV 64. Valid amount stagger expression with only start and end', () => {
  const res = v.validate({ am: '@stagger(100, 200)' }, amountValidation);
  expect(res).toBe(true);
});

test('AV 65. Invalid amount stagger expression because of fraction < 0', () => {
  const stagger = '@stagger(100, 200, -2)';
  const res = v.validate({ am: stagger }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: stagger,
    },
    {
      message: 'The stagger fraction must be a number >=0 and <=1',
      field: 'am',
      type: 'number',
      actual: stagger,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.66 Invalid amount stagger expression because of invalid start value`, () => {
  const stagger = '@stagger(abc, 200)';
  const res = v.validate({ am: '@stagger(abc, 200)' }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: stagger,
    },
    {
      message:
        "The start and end units of a @stagger should always be the same. This doesn't stand for the couple abc, 200",
      field: 'am',
      type: 'number',
      actual: stagger,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.67 Invalid amount stagger expression because of not same start and end values`, () => {
  const res = v.validate({ am: stagger_zero_string }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: stagger_zero_string,
    },
    {
      message:
        "The start and end units of a @stagger should always be the same. This doesn't stand for the couple 0, abc",
      field: 'am',
      type: 'number',
      actual: stagger_zero_string,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: stagger_zero_string,
    },
  ]);
});

test(`AV.68 Valid amount stagger expression on advanced amount configuration`, () => {
  const res = v.validate({ amAdv: '@stagger(0, 6)' }, amountValidation);
  expect(res).toBe(true);
});

test(`AV.69 Invalid amount stagger start on advanced amount configuration / min`, () => {
  const res = v.validate({ amAdv: stagger_minus7_8 }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger_minus7_8,
    },
    {
      message: amAdv_min_message,
      field: 'amAdv',
      type: 'numberMin',
      expected: -1,
      actual: -7,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger_minus7_8,
    },
  ]);
});

test(`AV.70 Invalid amount stagger start on advanced amount configuration / max`, () => {
  const res = v.validate({ amAdv: stagger_30_0 }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger_30_0,
    },
    {
      message: amAdv_max_message,
      field: 'amAdv',
      type: 'numberMax',
      expected: 12,
      actual: 30,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger_30_0,
    },
  ]);
});

test(`AV.72 Invalid amount stagger start on advanced amount configuration / integer`, () => {
  const res = v.validate({ amAdv: stagger_2point3_6 }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger_2point3_6,
    },
    {
      message: amAdv_int_message,
      field: 'amAdv',
      type: 'numberInteger',
      actual: 2.3,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger_2point3_6,
    },
  ]);
});

test(`AV.73 Invalid measurement stagger end on advanced amount configuration / min`, () => {
  const stagger = '@stagger(0, -19)';
  const res = v.validate({ amAdv: stagger }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger,
    },
    {
      message: amAdv_min_message,
      field: 'amAdv',
      type: 'numberMin',
      expected: -1,
      actual: -19,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.74 Invalid amount stagger end on advanced amount configuration / max`, () => {
  const stagger = '@stagger(2, 60)';
  const res = v.validate({ amAdv: stagger }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger,
    },
    {
      message: amAdv_max_message,
      field: 'amAdv',
      type: 'numberMax',
      expected: 12,
      actual: 60,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.75 Invalid amount stagger end on advanced amount configuration / integer`, () => {
  const stagger = '@stagger(2, 6.5)';
  const res = v.validate({ amAdv: stagger }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger,
    },
    {
      message: amAdv_int_message,
      field: 'amAdv',
      type: 'numberInteger',
      actual: 6.5,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.76 Invalid amount stagger due to wrong mode parameter`, () => {
  const stagger = '@stagger(2, 6, 0, linear, wrong mode)';
  const res = v.validate({ amAdv: stagger }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: stagger,
    },
    {
      message: 'The stagger mode should be either "linear" or "omni"',
      field: 'amAdv',
      type: 'number',
      actual: stagger,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: stagger,
    },
  ]);
});

test(`AV.77 Invalid amount stagger reverse parameter results to reverse=false`, () => {
  const res = v.validate(
    { amAdv: '@stagger(2, 6, 0.5, linear, omni, wrong)' },
    amountValidation,
  );
  expect(res).toBe(true);
});

test(`AV.78 Valid amount stagger with all 6 params passed`, () => {
  const res = v.validate(
    { amAdv: '@stagger(2, 6, 0.5, easeOutCubic, linear, true)' },
    amountValidation,
  );
  expect(res).toBe(true);
});

test('AV.79. Valid amount attribute value', () => {
  const res = v.validate({ am: '@attribute(data-height)' }, amountValidation);
  expect(res).toBe(true);
});

test('AV.80 Invalid amount attribute value', () => {
  const attrexp = '@attribute(data-height';
  const res = v.validate({ am: attrexp }, amountValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: attrexp,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: attrexp,
    },
  ]);
});

test('AV.81. Valid measurement attribute value', () => {
  const res = v.validate(
    { measure: '@attribute(data-height)' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test('AV.82 Invalid measurement attribute value', () => {
  const attrexp = '@attribute(data-attr';
  const res = v.validate({ measure: attrexp }, measurementValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @attribute(data-attr",
      field: 'measure',
      actual: attrexp,
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: attrexp,
    },
  ]);
});
//
// /////////////////////////////////////////////////////////////////
test('AV.83. Valid pattern measurement attribute value', () => {
  const res = v.validate(
    { measure: '  @pattern(  20px , 15% ) ' },
    measurementValidation,
  );
  expect(res).toBe(true);
});

test('AV.84. Invalid pattern measurement value', () => {
  const exp = '@pattern(20px, 15%';
  const res = v.validate({ measure: exp }, measurementValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @pattern(20px, 15%",
      field: 'measure',
      actual: exp,
    },
    {
      message: 'The pattern expression is not valid',
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
  ]);
});

test('AV.85. Invalid pattern measurement on value units', () => {
  const exp = '@pattern(20p, 15%)';
  const res = v.validate({ measure: exp }, measurementValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @pattern(20p, 15%)",
      field: 'measure',
      actual: exp,
    },
    {
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: 20p",
      field: 'measure',
      type: 'measurement',
      actual: '20p',
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
  ]);
});

test('AV.86. Invalid pattern measurement (lower than min allowed)', () => {
  const exp = '@pattern(-20px, 15%)';
  const res = v.validate({ measure: exp }, measurementAdvancedValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @pattern(-20px, 15%)",
      field: 'measure',
      actual: exp,
    },
    {
      message:
        "measurement - The provided value of measure (-20px) is smaller than the schema's min",
      field: 'measure',
      type: 'measurementMin',
      actual: '-20px',
    },
    {
      message: higherThanMax,
      field: 'measure',
      type: 'measurementMax',
      actual: '15%',
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
  ]);
});

test('AV.87. Invalid pattern measurement (bigger than max allowed)', () => {
  const exp = '@pattern(300px, 15%)';
  const res = v.validate({ measure: exp }, measurementAdvancedValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @pattern(300px, 15%)",
      field: 'measure',
      actual: exp,
    },
    {
      message:
        "measurement - The provided value of measure (300px) is bigger than the schema's max",
      field: 'measure',
      type: 'measurementMax',
      actual: '300px',
    },
    {
      message: higherThanMax,
      field: 'measure',
      type: 'measurementMax',
      actual: '15%',
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
  ]);
});

test('AV.88. Invalid pattern measurement (not an integer)', () => {
  const exp = '@pattern(3.5px, 15%)';
  const res = v.validate({ measure: exp }, measurementAdvancedValidation);
  expect(res).not.toBe(true);
  expect(res).toEqual([
    {
      type: 'measurement',
      message:
        "The 'measure' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: @pattern(3.5px, 15%)",
      field: 'measure',
      actual: exp,
    },
    {
      message:
        'measurement - The provided value of measure (3.5px) is not an integer',
      field: 'measure',
      type: 'measurementInt',
      actual: '3.5px',
    },
    {
      message: higherThanMax,
      field: 'measure',
      type: 'measurementMax',
      actual: '15%',
    },
    {
      message: invalidDVMessage,
      field: 'measure',
      type: 'measurement',
      actual: exp,
    },
  ]);
});
//
// ///////////////////////////////////////////////////////////
test('AV.89 Valid pattern amount', () => {
  const res = v.validate({ am: '@pattern(2, 3, 6)' }, amountValidation);
  expect(res).toBe(true);
});

test('AV.90 Invalid amount pattern (string)', () => {
  const exp = '@pattern(2, test, 6)';
  const res = v.validate({ am: exp }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: am_must_be_a_number,
      field: 'am',
      actual: exp,
    },
    {
      message: 'The @pattern value at index 1 is not numeric',
      field: 'am',
      type: 'number',
      actual: exp,
    },
    {
      message: invalidDVMessage,
      field: 'am',
      type: 'number',
      actual: exp,
    },
  ]);
});

test('AV 91. Invalid amount pattern (min)', () => {
  const res = v.validate({ amAdv: patternMinus6_2 }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: patternMinus6_2,
    },
    {
      message: amAdv_min_message,
      field: 'amAdv',
      type: 'numberMin',
      expected: -1,
      actual: -6,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: patternMinus6_2,
    },
  ]);
});

test('AV 92. Invalid amount pattern (max)', () => {
  const res = v.validate({ amAdv: pattern100 }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: pattern100,
    },
    {
      message: amAdv_max_message,
      field: 'amAdv',
      type: 'numberMax',
      expected: 12,
      actual: 100,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: pattern100,
    },
  ]);
});

test('AV.93 Integer amount directive on pattern)', () => {
  const exp = '@pattern(2, 4.3)';
  const res = v.validate({ amAdv: exp }, amountValidation);
  expect(res).not.toBe(true);

  expect(res).toEqual([
    {
      type: 'number',
      message: amAdv_number_message,
      field: 'amAdv',
      actual: exp,
    },
    {
      message: amAdv_int_message,
      field: 'amAdv',
      type: 'numberInteger',
      actual: 4.3,
    },
    {
      message: invalidDVMessage,
      field: 'amAdv',
      type: 'number',
      actual: exp,
    },
  ]);
});

test('AV.94 Passing an initParam as @expression to number should pass', () => {
  const res = v.validate(
    { num: '@expression(initParams.x)' },
    numberValidation,
  );
  expect(res).toBe(true);
});
