/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import {
  elementsDataAttributeName,
  lanesMCIDattrsSeparator,
  logLevel as defaultLogLevel,
  logTypes,
  testMode,
} from '../_configuration/generalConf';

// audio context initialisation
window.AudioContext ||= window.webkitAudioContext;
export const audioContext = new window.AudioContext();

export function isInteger(number) {
  return number === parseInt(number, 10);
}

export function isNumber(value) {
  return typeof value === 'number' && isFinite(value);
}

export function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

export function isString(test) {
  return typeof test === 'string' || test instanceof String;
}

export function isObject(test) {
  return typeof test === 'object';
}

export function isFunction(functionToCheck) {
  return (
    functionToCheck && {}.toString.call(functionToCheck) === '[object Function]'
  );
}

export function hasOwnProp(obj = {}, prop = null) {
  if (prop === null || !isObject(obj)) {
    return false;
  }

  return Object.prototype.hasOwnProperty.call(obj, prop);
}

export function deepCopy(value) {
  return JSON.parse(JSON.stringify(value));
}

export function jsUcfirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

export const numberPartRegexp = /^[+-]?(\d+([.]\d*)?|[.]\d+)/gi;

/**
 * A function that takes an object and a key an extracts the number
 * and the unit from the value of the key, returns null if the value isn't
 * properly formatted or if the key doesn't exist
 * @typedef {Object} ObjectWithNumberAndUnits
 * @property {number} number - The number of the value
 * @property {string} unit- The unit of the value
 * @param  {object} object
 * @param  {string} key
 * @returns {(null|ObjectWithNumberAndUnits)}
 */
function extractNumberValueFromObject(object, key) {
  const value = object?.[key];
  if (!isString(value)) {
    return null;
  }

  let number = value.match(numberPartRegexp)[0];
  const unit = value.substring(number.length);
  number = Number(number);
  if (!isNumber(number) || (unit !== '%' && unit !== 'px')) {
    return null;
  }
  return { number, unit };
}

const noWidthAndHeightKeysError = [
  'originalDims should be an object containing both the "width" and "height" keys',
];

export function originalDimsCheck(originalDims) {
  if (originalDims == null) {
    return {
      result: true,
      analysis: {
        width: null,
        height: null,
      },
    };
  }

  if (!isObject(originalDims)) {
    return {
      result: false,
      errors: noWidthAndHeightKeysError,
    };
  }

  if (
    !hasOwnProp(originalDims, 'width') ||
    !hasOwnProp(originalDims, 'height')
  ) {
    return {
      result: false,
      errors: noWidthAndHeightKeysError,
    };
  }

  if (extractNumberValueFromObject(originalDims, 'width') == null) {
    return {
      result: false,
      errors: ['originalDims.width should be defined either on px or %.'],
    };
  }

  if (extractNumberValueFromObject(originalDims, 'height') == null) {
    return {
      result: false,
      errors: ['originalDims.height should be defined either on px or %.'],
    };
  }

  return {
    result: true,
    analysis: analyseContainerParams(originalDims),
  };
}

export function analyseContainerParams(containerParams) {
  if (!isObject(containerParams) || containerParams == null) {
    return {
      width: null,
      height: null,
    };
  }

  return {
    width: extractNumberValueFromObject(containerParams, 'width'),
    height: extractNumberValueFromObject(containerParams, 'height'),
  };
}

/**
 * extracts the arguments that exist within the parenthesis of a given expression.
 * E.g. the @stagger(0px, 10px) will give the array ["0px", "10px'] etc
 *
 * @param {string} expression
 * @returns {*|string[]}
 */
export function extractParenthesisAttrsAsArray(expression) {
  const tempValue = removeWhitespace(expression);
  const onlyWithinParenthesesRegexp = /.*\((.*)\).*/;
  const content = onlyWithinParenthesesRegexp.exec(tempValue)[1];
  return content.split(',');
}

/**
  subdivision might be rounding the number to its:
    units (subdivision = 1)
    tenths (subdivision = 10)
    hundreds (subdivision = 100)
    thousands (subdivision = 1000)
  @param {number} number
  @param {number} subdivision
  @returns {number} the rounded number
 */
export function roundNumberTo(number, subdivision) {
  return Math.round(number / subdivision) * subdivision;
}

export function getMCIDandAttrOutOfLaneKey(laneKey) {
  const laneArray = laneKey.split(lanesMCIDattrsSeparator);
  return {
    mcid: laneArray[0],
    attribute: laneArray[1],
  };
}

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
    .toString(16)
    .substring(1);
}
/**
 * @returns {string} in the form "1bc45f78-ab23-jl59"
 */
export function getAnId(underscore = false) {
  let specialChar = underscore ? '_' : '-';
  return `${s4()}${s4()}${specialChar}${s4()}${specialChar}${s4()}`;
}

export function getLaneKey(mcid, attribute) {
  return `${mcid}${lanesMCIDattrsSeparator}${attribute}`;
}

/**
 * This function always returns false,
 * it's used to overwrite other functions
 * @returns {false}
 */
export function alwaysReturnFalse() {
  return false;
}

/**
 * given an object, a path in string format and a value the method will assign
 * to the given path of the object the provided value. If the path does not exist
 * it will return false, otherwise it'll return true
 * @param {object} obj
 * @param {string} path: a string representatio of the path, e.g. "path.to.key"
 * @param {any} value: the new value of the given key
 **/
export function assignValueToPath(obj, path, value) {
  const arrayPath = path.split('.');
  let currentObject = obj;
  for (let i = 0; i < arrayPath.length - 1; i++) {
    if (!hasOwnProp(currentObject, arrayPath[i])) {
      return false;
    }
    currentObject = currentObject[arrayPath[i]];
  }

  if (!hasOwnProp(currentObject, arrayPath[arrayPath.length - 1])) {
    return false;
  }

  currentObject[arrayPath[arrayPath.length - 1]] = value;
  return true;
}

export function sortByIndexes(collection, by) {
  const test_with_index = [];
  for (let i = 0; i < collection.length; i++) {
    test_with_index.push([collection[i], i]);
  }
  test_with_index.sort(function (left, right) {
    return left[0][by] < right[0][by] ? -1 : 1;
  });
  var indexes = [];
  for (var j in test_with_index) {
    indexes.push(test_with_index[j][1]);
  }
  return indexes;
}

export function doNothing() {
  /* This function is intentionally empty*/
}

/** @classdesc Helper maintains a number of helpful functions in a single point  */
class Helper {
  constructor(configuration) {
    let logLevel = defaultLogLevel;

    if (hasOwnProp(configuration, 'logLevel')) {
      logLevel = configuration.logLevel;
    }

    for (let i = 0; i < logTypes.length; i++) {
      const logType = logTypes[i];
      if (logLevel >= logType.level) {
        this[logType.key] = testMode
          ? window.console[logType.consoleMethod].bind(
              window.console,
              `MotorCortex - ${logType.key}: `,
            )
          : window.console[logType.consoleMethod].bind(
              window.console,
              'MotorCortex - %c%s',
              logType.style,
            );
      } else this[logType.key] = doNothing;
    }

    if (logLevel >= 3) {
      this.log = window.console.log.bind(window.console, 'MotorCortex - ');
      return;
    }

    this.log = doNothing;
  }
}
const helper = new Helper();

export function validateProps(props, rules, constructor) {
  const validationResult = rules(props);
  if (validationResult.length > 0) {
    let errorMessage = `Error on plugin's "${constructor.plugin_npm_name}" "${constructor.ClassName}" instantiation. Errors (op props):`;
    for (let i = 0; i < validationResult.length; i++) {
      errorMessage += `\n - ${validationResult[i].message}. ${validationResult[i].actual} provided`;
    }
    helper.error(errorMessage);
    return {
      result: false,
      errors: validationResult,
    };
  }
  return { result: true };
}

export function getElementByMCID(context, mcid) {
  return context.rootElement.querySelectorAll(
    `[${elementsDataAttributeName}="${mcid}"]`,
  )[0];
}

export function buildInitialValuesValidationRules(attributeRules) {
  let initialValuesRules = deepCopy(attributeRules);
  function makeOptional(attr) {
    if (isString(attr)) {
      attr = { type: attr };
    }
    attr.optional = true;
    if (attr.type === 'object') {
      for (let key in attr.props) {
        makeOptional(attr.props[key]);
      }
    }
  }
  makeOptional(initialValuesRules);
  return initialValuesRules;
}

/**
 * Escape a string for HTML interpolation.
 * @param {string} string
 */
export function htmlEscape(string) {
  // List of HTML entities for escaping.
  const htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;',
  };

  // Regex containing the keys listed immediately above.
  const htmlEscaper = /[&<>"'/]/g;

  return `${string}`.replace(htmlEscaper, function (match) {
    return htmlEscapes[match];
  });
}

/**
 * systole / diastole of the projections
 * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
 * */
export function systoleDiastoleProjections(
  projections,
  durationFraction,
  anchorPoint,
) {
  const alteredProjections = [];

  for (let i = 0; i < projections.length; i++) {
    const projectedIncident = projections[i];

    let start = projectedIncident.parentMillisecond - anchorPoint;
    start = start * durationFraction + anchorPoint;
    if (durationFraction !== 1) {
      alteredProjections.push({
        id: projectedIncident.incident.id,
        start,
        end: start + projectedIncident.incident.duration * durationFraction,
        startDelta: start - projectedIncident.millisecond,
      });
    }
  }

  return alteredProjections;
}

export function validateGoogleFontUrl(url) {
  return url.trimStart().startsWith('https://fonts.googleapis.com/css');
}

export default helper;

export function removeWhitespace(str) {
  return str.replace(/\s/g, '');
}
