/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import helper, {
  buildInitialValuesValidationRules,
  deepCopy,
  hasOwnProp,
  isObject,
  originalDimsCheck,
} from './helper';
import DescriptiveGroup from '../DescriptiveIncidents/DescriptiveGroup';
import HTMLDescriptiveClip from '../Clip/Browser/Descriptive/HTMLDescriptiveClip';
import MonoIncident from '../RealIncidents/MonoIncident';
import MediaPlayback from '../RealIncidents/MediaPlayIncident';
import validator from './customValidator';
import AttributeChannel from '../Channels/Attribute/AttributeChannel';
import DescriptiveIncident from '../DescriptiveIncidents/DescriptiveIncident';
import AudioPlaybackChannel from '../Channels/Media/AudioPlaybackChannel';

// eslint-disable-next-line sonarjs/cognitive-complexity
export function checkPlugin(main) {
  if (hasOwnProp(main, 'default')) {
    main = main.default;
  }

  const plugin_name = main.npm_name;
  if (!hasOwnProp(main, 'name')) {
    helper.notice(
      `Notice on plugin ${plugin_name}. A plugin should have its name under the key "name". It's missing from this plugin`,
    );
  }

  // TODO this might turn into a mandatory field in future versions
  if (!hasOwnProp(main, 'version')) {
    helper.notice(`Notice on ${plugin_name}. Plugin should always expose its version number.
      Plugin version is missing`);
  }

  if (!hasOwnProp(main, 'incidents')) {
    if (!hasOwnProp(main, 'Clip')) {
      helper.error(`Error on plugin ${plugin_name}. A plugin must expose at least one Incident or a Clip.
        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file while Clips on the "Clip".`);
      return false;
    }
    return true;
  }

  if (!Array.isArray(main.incidents)) {
    helper.error(`Error on plugin ${plugin_name}. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.
    Please refer to the documentation`);
    return false;
  }

  // We don't exit early here so we can provide warnings for all of the incidents
  let check = true;
  for (let i = 0; i < main.incidents.length; i++) {
    const exposedIncidentDefinition = main.incidents[i];

    if (
      isObject(exposedIncidentDefinition.exportable) &&
      hasOwnProp(exposedIncidentDefinition.exportable, 'default')
    ) {
      exposedIncidentDefinition.exportable =
        exposedIncidentDefinition.exportable.default;
    }

    const exposedIncidentPrototype =
      exposedIncidentDefinition.exportable.prototype;
    if (
      !(
        exposedIncidentPrototype instanceof DescriptiveGroup ||
        exposedIncidentPrototype instanceof HTMLDescriptiveClip ||
        exposedIncidentPrototype instanceof MonoIncident ||
        exposedIncidentPrototype instanceof MediaPlayback
      )
    ) {
      helper.error(
        `Error on plugin ${plugin_name}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex. ${exposedIncidentDefinition.exportable.constructor.name} doesn't.\nPlease refer to documentation`,
      );
      check = false;
      continue;
    }

    // check if there are originalDims present and if yes, check their validity
    if (exposedIncidentPrototype instanceof HTMLDescriptiveClip) {
      if (!hasOwnProp(exposedIncidentDefinition, 'originalDims')) {
        helper.log(
          `Warning on plugin ${plugin_name}. It's always good to provide originalDims\nwhen exposing Incidents extending DOMClip. By defining their original dims the users\nof your plugin will be able to define the desired dimensions of your Incident by\nthe "containerParams object"`,
        );
        continue;
      }

      const odc = originalDimsCheck(exposedIncidentDefinition.originalDims);
      if (!odc.result) {
        helper.error(
          `Error on plugin ${plugin_name}. Invalid originalDims value passed on ${exposedIncidentDefinition.name}`,
        );
        check = false;
      }
    }

    if (!hasOwnProp(exposedIncidentDefinition, 'name')) {
      helper.error(
        `Error on plugin ${plugin_name}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.\nPlease refer to documentation`,
      );
      check = false;
    }
  }

  return check;
}

// plugin_name is the unique name of the plugin
// eslint-disable-next-line sonarjs/cognitive-complexity
export function loadPlugin(plugin) {
  if (hasOwnProp(plugin, 'default')) {
    plugin = plugin.default;
  }

  if (!hasOwnProp(plugin, 'npm_name')) {
    plugin.npm_name = `plugin_${new Date().getTime()}`;
  }

  if (!checkPlugin(plugin)) {
    return false;
  }

  // thePlugin is the plugin object which will hold on its keys
  // the names of the exposed Incidents of its. The keys of this object
  // are going to be identical with the names of the classes exposed
  const thePlugin = {};

  if (hasOwnProp(plugin, 'Clip')) {
    if (!hasOwnProp(plugin.Clip, 'exportable')) {
      const DynamicDescriptiveClip = class extends HTMLDescriptiveClip {
        static Incident = plugin.Clip;
        static plugin = plugin.npm_name;
        static version = plugin.version || '*';

        static audio = plugin.audio || 'off';

        static customClip = true;
      };
      helper.warning(
        `It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name}.Clip doesn't provide it`,
      );
      thePlugin.Clip = DynamicDescriptiveClip;
    } else {
      const DynamicDescriptiveClip = class extends HTMLDescriptiveClip {
        static Incident = plugin.Clip.exportable;
        static plugin = plugin.npm_name;
        static version = plugin.version || '*';

        static audio = plugin.audio || 'off';

        static customClip = true;
      };

      let validationMethod;
      if (hasOwnProp(plugin.Clip, 'attributesValidationRules')) {
        validationMethod = validator.compile(
          plugin.Clip.attributesValidationRules,
        );
      }

      class WrapperClass {
        constructor(_attrs, _props) {
          let attrs = _attrs;
          let props = _props;
          if (_props == undefined) {
            props = attrs;
            attrs = {};
          }

          let instantiatedIncident;
          if (hasOwnProp(plugin.Clip, 'attributesValidationRules')) {
            const validationResult = validationMethod(attrs);
            if (validationResult.length > 0) {
              let errorMessage = `Error on plugin's "${plugin.npm_name}" Clip instantiation. Errors:`;
              for (let j = 0; j < validationResult.length; j++) {
                errorMessage += `\n - ${validationResult[j].message}. ${validationResult[j].actual} provided`;
              }
              helper.error(errorMessage);
              helper.log('breaking');
              return {
                result: false,
                errors: validationResult,
              };
            } else {
              helper.log('instantiating');
              instantiatedIncident = new DynamicDescriptiveClip(attrs, props);
              instantiatedIncident.attrsValidationRules =
                plugin.Clip.attributesValidationRules;
              instantiatedIncident.attrsValidationMethod = validationMethod;
            }
          } else {
            helper.log('instantiating');
            instantiatedIncident = new DynamicDescriptiveClip(attrs, props);
            instantiatedIncident.attrsValidationRules = null;
            helper.warning(
              `It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name}.${instantiatedIncident.constructor.name} doesn't provide it`,
            );
          }
          return instantiatedIncident;
        }
      }

      thePlugin.Clip = WrapperClass;
    }
  }

  // if the plugin definition has compositeAttributes then we dynamically
  // create a new Channel class extending AttributeChannel setting the
  // composite Attributes on the fly. We can then use this Channel class
  // for all Incidents exposed by the plugin
  let AttributeChannelToUse = AttributeChannel;
  if (hasOwnProp(plugin, 'compositeAttributes')) {
    AttributeChannelToUse = class extends AttributeChannel {
      constructor(props) {
        props.comboAttributes = plugin.compositeAttributes;
        super(props);
      }
    };
  }

  // for each of the exposed Incidents
  if (!hasOwnProp(plugin, 'incidents')) {
    return thePlugin;
  }

  for (let i = 0; i < plugin.incidents.length; i++) {
    Object.defineProperty(
      thePlugin,
      plugin.incidents[i].name,
      prepareIncident(plugin, i, AttributeChannelToUse),
    );
  }
  return thePlugin;
}

// eslint-disable-next-line sonarjs/cognitive-complexity
function prepareIncident(plugin, i, AttributeChannelToUse) {
  const incidentClass = plugin.incidents[i].exportable;

  let validationMethod = null,
    validationRules = null;
  let hasValidationRules = false;
  if (hasOwnProp(plugin.incidents[i], 'attributesValidationRules')) {
    hasValidationRules = true;
    const validationRulesToUse = deepCopy(
      plugin.incidents[i].attributesValidationRules,
    );
    if (
      hasOwnProp(plugin.incidents[i].attributesValidationRules, 'animatedAttrs')
    ) {
      // make all initialValues optional and store it on the validationRulesToUse
      validationRulesToUse.initialValues = buildInitialValuesValidationRules(
        validationRulesToUse.animatedAttrs,
      );
    }
    validationRules = validationRulesToUse;
    validationMethod = validator.compile(validationRulesToUse);
  }

  let DynamicDescriptiveIncident;
  // the exportable Incident can be either a Clip, a Group or an Incident
  // if it is an Incident
  if (incidentClass.prototype instanceof MonoIncident) {
    DynamicDescriptiveIncident = class extends DescriptiveIncident {
      static Incident = incidentClass;

      // the plugin_npm_name key is used internally by MC to distribute Incidents
      // to the proper plugins Channels. Sometimes Incidents coming from third-party
      // plugins should be categorised to internal MC plugins such as media-playback or
      // self-contained-incidents. In order to keep a reference to the real plugin
      // that the incidents have been exposed from we use a second key with the
      // name "plugin"
      static plugin_npm_name = plugin.npm_name;

      static plugin = plugin.npm_name;

      static version = plugin.version || '*';

      static ClassName = plugin.incidents[i].name;

      static Channel = AttributeChannelToUse; // Channels are static properties of Descriptive Incidents. MonoIncident
      // belongs to the real world and here we define a Descriptive Incident to wrap it. We create and pass a Channel

      static audio = plugin.audio || 'off';
    };
  } else if (incidentClass.prototype instanceof MediaPlayback) {
    DynamicDescriptiveIncident = class extends DescriptiveIncident {
      static Incident = incidentClass;
      static audio = plugin.audio || 'off';
      static plugin_npm_name = '@donkeyclip/media-playback';

      static plugin = plugin.npm_name;

      static version = plugin.version || '*';

      static ClassName = plugin.incidents[i].name;

      static Channel = AudioPlaybackChannel; // Channels are static properties of Descriptive Incidents. MonoIncident
      // belongs to the real world and here we define a Descriptive Incident to wrap it. We create and pass a Channel
    };
  } else if (incidentClass.prototype instanceof HTMLDescriptiveClip) {
    DynamicDescriptiveIncident = class extends incidentClass {
      // This Class extends a Descriptive Incident which already has the static property "channel" we don't need
      // to define it again. We only need to add the plugin's information
      static audio = plugin.audio || 'on';

      static originalDims = originalDimsCheck(plugin.incidents[i].originalDims)
        .analysis;

      static isAnimation = true;
    };
  } else if (incidentClass.prototype instanceof DescriptiveGroup) {
    // This Class extends a Descriptive Incident which already has the static property "channel" we don't need
    // to define it again. We only need to add the plugin's information
    DynamicDescriptiveIncident = incidentClass;
  }

  DynamicDescriptiveIncident.plugin = plugin.npm_name;
  DynamicDescriptiveIncident.version = plugin.version || '*';
  DynamicDescriptiveIncident.ClassName = plugin.incidents[i].name;
  DynamicDescriptiveIncident.attrsValidationRules = validationRules;
  DynamicDescriptiveIncident.attrsValidationMethod = validationMethod;

  return {
    enumerable: true,
    get() {
      // the getter will construct a wrapper class which on the constructor will instantiate an object of the
      // exposed class, set to it the plugin name and channel class parameters and return
      // it from the constructor
      class WrapperClass {
        // we transfer some basic information of the DescriptiveIncident to our
        // Wrapper Class as well
        static targetClass = DynamicDescriptiveIncident;

        constructor(attrs, props) {
          let instantiatedIncident;
          if (hasValidationRules) {
            const validationResult = validationMethod(attrs);
            if (validationResult.length > 0) {
              let errorMessage = `Error on plugin's "${plugin.npm_name}" "${plugin.incidents[i].name}" instantiation. Errors:`;
              for (let j = 0; j < validationResult.length; j++) {
                errorMessage += `\n - ${validationResult[j].message}. ${validationResult[j].actual} provided`;
              }
              helper.error(errorMessage);
              return {
                result: false,
                errors: validationResult,
              };
            }
          }

          instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

          if (instantiatedIncident.result && !hasValidationRules) {
            helper.warning(
              `It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name} doesn't provide it`,
            );
          }

          return instantiatedIncident;
        }
      }
      return WrapperClass;
    },
  };
}
