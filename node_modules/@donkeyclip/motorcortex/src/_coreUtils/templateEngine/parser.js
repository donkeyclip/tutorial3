/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/* eslint-disable sonarjs/no-duplicated-branches */

import {
  curlyBracketsOpenCloseRegexp,
  fullStringRegexp,
  stringComparisonRegexp,
  singleQuotesRegexp,
  itemsIdentifierRegexp,
  keysIdentifierRegexp,
  ofAttributeValueRegexp,
  integerRegexp,
  dynamicExpressionsRegexp,
  dynamicExpressionsOnlyIfRegexp,
} from './regexp';
import { getFromNameSpace } from '../proxies/nameSpaceHandler/nameSpaceHandler';
import helper, { isString, isObject, htmlEscape, isInteger } from '../helper';
import { Parser } from 'expr-eval';
import { createProxy } from '../proxies/ObjectProxy/ObjectProxy';

const parser = new Parser();
const mcifRegex = / *mc-if *= *" */g;

// expr: a complete string expression ready to parsed to string
// e.g. 'test' + ' another string ' + 3 will be turned to "test another string 3"
function createString(dexp) {
  const strings = dexp.split(/ *\+ */);
  for (let i = 0; i < strings.length; i++) {
    strings[i] = strings[i].trim();
    // it starts and ends in double quotes
    if (strings[i].match(singleQuotesRegexp)) {
      // remove first and last character
      strings[i] = strings[i].substring(1, strings[i].length - 1);
    }
  }
  return strings.join('');
}

function compareNumbers(val1, val2, operator) {
  switch (operator) {
    case '==':
    case '===':
      return val1 === val2;
    case '!=':
    case '!==':
      return val1 !== val2;
    case '>':
      return val1 > val2;
    case '>=':
      return val1 >= val2;
    case '<':
      return val1 < val2;
    case '<=':
      return val1 <= val2;
    default:
      helper.error('Not supported operator ' + operator);
      return false;
  }
}

/*
1. find all {{ }} except the ones that have the off= {{ sthg }}. Leave \}} and \{{ untouched
2. On each, find and replace the items and the keys on them
3. And then decide if they are final and if so...
final:
- either "string" + "string" + number + "string" -> parses the string concat
- or string [!=, !==, ==, ===] string -> parses strings, compares them and returns boolean
- or can get parsed by expr-eval and gets parsed
- if it contains undefined -- ?? --
4. Replace them with their final value. Turn \{{ to {{ and \}} to }}
if isHTML is true all parsed values will be html escaped
 */

// eslint-disable-next-line sonarjs/cognitive-complexity
export function parseKnownParams(template, params, isHTML) {
  // eslint-disable-next-line sonarjs/cognitive-complexity
  function replacer(dynamicExpression) {
    // as backwards lookup on regxp is not supported by safari on the replacer function we might have as input strings
    // that are directly the expression to evaluate and replace or expressions that start with / *mc-if *= *" */
    // We need to know if our expression starts with mc-if and if so to initially remove it and then restore it on the
    // string we'll provide back
    const mcifResults = dynamicExpression.match(mcifRegex);
    const mcif = Array.isArray(mcifResults);
    dynamicExpression = dynamicExpression.replaceAll(/ *mc-if *= *" */g, '');
    function customReturn(toReturn) {
      if (mcif) {
        toReturn = ` mc-if="${toReturn}`;
      }
      return toReturn;
    }

    dynamicExpression = dynamicExpression.replaceAll(/ *mc-if *= *" */g, '');
    const hasCurly = dynamicExpression.match(curlyBracketsOpenCloseRegexp);
    let expression = dynamicExpression.replaceAll(
      curlyBracketsOpenCloseRegexp,
      '',
    );
    // itemsIdentifierRegexp returns either a regular expression of boolean false if there are no items present
    const itemsRegex = itemsIdentifierRegexp(params.items);
    // same stands for keysIdentifierRegexp
    const keysRegex = keysIdentifierRegexp(params.keys);
    // itemRegex === false means no items are present
    if (itemsRegex !== false) {
      expression = expression.replaceAll(itemsRegex, (exp) => {
        if (exp === 'initParams' || exp === 'attrs') {
          return customReturn('undefined');
        }

        let value = getFromNameSpace(exp, '', params.items);
        if (isString(value)) {
          value = `'${isHTML ? htmlEscape(value) : value}'`;
        }
        return value;
      });
    }

    // keysRegex === false means there are no keys present
    if (keysRegex !== false) {
      expression = expression.replaceAll(keysRegex, (exp) => {
        let value = params.keys[exp];
        if (isString(value)) {
          value = `'${isHTML ? htmlEscape(value) : value}'`;
        }
        return value;
      });
    }

    if (expression.match(stringComparisonRegexp)) {
      // if it is a string comparison
      const comparedParts = expression.split(/===|==/);
      comparedParts[0] = createString(comparedParts[0]);
      comparedParts[1] = createString(comparedParts[1]);
      return customReturn((comparedParts[0] === comparedParts[1]).toString());
    }

    // first we will try to parse it by expr-eval
    try {
      const expr = parser.parse(expression);
      const parserArgs = Object.assign({}, params.keys, params.items);
      const value = expr.evaluate(parserArgs);
      if (value !== undefined && !isNaN(value)) {
        return customReturn(value);
      }
    } catch (e) {
      // eslint-disable-line no-empty
    }
    // then we will try to parse it as a string
    if (expression.match(fullStringRegexp)) {
      // if it is a full string
      return customReturn(createString(expression));
    }

    // a final try: parse potential valid numeric comparison
    const operatorRegex = /===|==|>=|>|<=|<|!==|!=/g;
    const comparedParts = expression.split(operatorRegex);
    if (comparedParts.length === 2) {
      const operator = expression.match(operatorRegex)[0];
      try {
        const expr1 = parser.parse(comparedParts[0]);
        const expr2 = parser.parse(comparedParts[1]);
        const parserArgs = Object.assign({}, params.keys, params.items);
        const value1 = expr1.evaluate(parserArgs);
        const value2 = expr2.evaluate(parserArgs);
        return customReturn(
          compareNumbers(value1, value2, operator).toString(),
        );
      } catch (e) {
        // eslint-disable-line no-empty
      }
    }

    /*
    at this point several things have happened:
    - the parser has turned all known values inside the expressions to their corresponding values
    - the parser has identified all valid complete expression and turned them to their final value
      removing curly brackets. These cases have already been returned, so here we are talking about
      not final expressions
    so, at this point we have expressions that have their know values parsed but still, the expressions
    are not final yet.
    We need to maintain the curly brackets on these expressions so the following iterations (potential
    mc-for children) can try to parse them, as they'll hold more data (items / keys).
    expression here is the expression (without curly brackets) will all know attributes already parsed.
     */
    if (hasCurly !== null) {
      return customReturn(`{{${expression}}}`);
    }
    return customReturn(expression);
  }

  // first match all params.items expressions matched (within {{ }} )
  let stepOne = template.replaceAll(dynamicExpressionsRegexp, replacer);
  // then the mc-if
  return stepOne.replaceAll(dynamicExpressionsOnlyIfRegexp, replacer);
}

export function resolveIfs(rootElement) {
  const ifs = rootElement.querySelectorAll('[mc-if]');
  for (const element of ifs) {
    const mcif = element.getAttribute('mc-if');
    if (mcif === 'true') {
      element.removeAttribute('mc-if');
    } else if (mcif === 'false') {
      element.remove();
    }
  }
}

export function getOfValue(element, items) {
  if (!element.hasAttribute('mc-for') || !element.hasAttribute('mc-of')) {
    helper.warning('Either mc-for and mc-of is missing from element');
    return false;
  }
  if (
    !element.getAttribute('mc-for').match(/^ *[a-zA-Z_]\w* *, *[a-zA-Z_]\w* *$/)
  ) {
    // TODO investigate false warning on CASIs and restore the warning
    // helper.warning('mc-for attribute is not a valid expression');
    return false;
  }

  const exp = ofAttributeValueRegexp(items);
  const mcof = element.getAttribute('mc-of');
  const res = mcof.match(exp);
  const integerRes = mcof.match(integerRegexp);
  if (res?.length !== 1 && integerRes === null) {
    helper.warning('mc-of attribute is not a valid expression');
    return false;
  }
  if (integerRes !== null) {
    return new Array(parseInt(mcof)).fill('');
  }
  const value = getFromNameSpace(res[0].trim(), '', items);
  if (value === undefined) {
    helper.warning('mc-of value is undefined');
    return false;
  } else if (!isObject(value) && !isString(value) && !isInteger(value)) {
    helper.warning(
      'mc-of value should be either a string, an object or an array',
    );
    return false;
  }
  if (isInteger(value)) {
    return new Array(value).fill('');
  }
  return value;
}

/**
 *
 * @param {object} props: contains the keys:
 *  - template
 *  - keys
 *  - items
 *  - params
 */
export function parseForLoop(props) {
  const blocks = [];
  const paramsProxy = createProxy(props.params);
  for (const key in props.items) {
    paramsProxy.setValue(`keys.${props.keys.key}`, key);
    paramsProxy.setValue(`items.${props.keys.item}`, props.items[key]);
    blocks.push(parse(props.template, paramsProxy.exportFlattened(), true));
  }
  return blocks;
}

/**
 *
 * @param {HTMLDOMElement} rootElement: the Browser element to resolve its direct mc-for loops
 * @param params: consists of two keys, the "items" and the "keys"
 *  keys are expected to be strings (or numbers) while items are treated as
 *  objects (or arrays)
 * @return {HTMLDOMElement}: return the same element only with its mc-for elements either
 *  parsed or discarded
 */
export function parseForLoops(rootElement, params) {
  const fors = rootElement.querySelectorAll('[mc-for]');
  for (const element of fors) {
    const items = getOfValue(element, params.items);
    if (items === false) {
      element.remove();
      continue;
    }
    // get the key and item keys from mc-for attribute
    const keysAr = element.getAttribute('mc-for').split(',');
    const keys = {
      key: keysAr[0].trim(),
      item: keysAr[1].trim(),
    };
    // cleanup the mc-for and mc-of attributes from the element
    element.removeAttribute('mc-for');
    element.removeAttribute('mc-of');
    // get the outerHTML to be used as our template
    const template = element.outerHTML;
    // get the parsed Browser for the for
    const forDOMBlocks = parseForLoop({
      template,
      keys,
      params,
      items,
    });
    // insert the for blocks in place of the original element
    // if the resolved items is empty just remove the original element
    if (forDOMBlocks.length === 0) {
      element.remove();
      continue;
    }
    // otherwise loop into results and gradually replace element with the resolved Browser blocks
    let currentElement = element;
    for (let i = 0; i < forDOMBlocks.length; i++) {
      const insertedNode = currentElement.parentNode.insertBefore(
        forDOMBlocks[i],
        currentElement.nextSibling,
      );
      currentElement = insertedNode;
    }
    element.remove();
  } // ends loop within the mc-for elements
}

/**
 *
 * @param {string} template
 * @param {object} params: consists of two keys, the "items" and the "keys"
 *  keys are expected to be strings (or numbers) while items are treated as
 *  objects (or arrays)
 * @param {boolean} isHTML: defines if the parser will parse html
 */
export function parse(template, params, isHTML = false) {
  template = template.replace(/^\s+|\s+$/g, '');
  template = parseKnownParams(template, params, isHTML);
  if (!isHTML) {
    return template;
  }
  const containerElement = document.createElement('div');
  containerElement.innerHTML = template;
  resolveIfs(containerElement);
  parseForLoops(containerElement, params);
  // prevent non-rooted Browser trees to get parsed
  if (containerElement.childElementCount !== 1) {
    helper.warning(
      'parser only accepts close Browser trees (always contained on a single element). The root element can not have mc-for applied to it. Returning empty div',
    );
    return document.createElement('div');
  }
  return containerElement.firstChild;
}
