/* eslint no-prototype-builtins: 0 */
import createProxy from '../ObjectProxy/ObjectProxy';
import { getFromNameSpace } from '../nameSpaceHandler/nameSpaceHandler';

const testData = {
  alpha: 'alpha',
  nestedObj: {
    nested_alpha: 'nested_alpha',
    secondNestedObj: {
      nested_x2_alpha: 'nested_x2_alpha',
      nested_x2_beta: 'nested_x2_beta',
    },
  },
};

const altered = '!!altered!!';
const nestedObj_nested_alpha = 'nestedObj.nested_alpha';

test(`OP.01 Add a value to a first level attribute on a proxy`, () => {
  const proxy = createProxy(testData);
  proxy.setValue('alpha', 'proxy_alpha');
  expect(proxy.alpha).toBe('proxy_alpha');
  expect(testData.alpha).toBe('alpha');
});

test(`OP.02 Add a value to a first level attribute on two proxies and make sure they don't share the same data`, () => {
  const proxy = createProxy(testData);
  proxy.setValue('alpha', 'proxy_alpha');

  const proxy2 = createProxy(testData);
  proxy2.setValue('alpha', 'proxy2_alpha');

  expect(proxy.alpha).toBe('proxy_alpha');
  expect(proxy2.alpha).toBe('proxy2_alpha');
  expect(testData.alpha).toBe('alpha');
});

test(`OP.03 Add a value to a deep level attribute on a proxy`, () => {
  const proxy = createProxy(testData);

  // eslint-disable-next-line sonarjs/no-duplicate-string
  proxy.setValue('nestedObj.secondNestedObj.nested_x2_alpha', altered);
  expect(proxy.nestedObj.secondNestedObj.nested_x2_alpha).toBe(altered);

  expect(testData.nestedObj.secondNestedObj.nested_x2_alpha).toBe(
    'nested_x2_alpha',
  );
});

test(`OP.04 Get a value that has not been set`, () => {
  const proxy = createProxy(testData);

  proxy.setValue('nestedObj.secondNestedObj.nested_x2_alpha', altered);
  expect(proxy.nestedObj.secondNestedObj.nested_x2_beta).toBe('nested_x2_beta');

  expect(testData.nestedObj.secondNestedObj.nested_x2_beta).toBe(
    'nested_x2_beta',
  );
});

test(`OP.05 Set a value and ask for another one bypassing the same parent`, () => {
  const proxy = createProxy(testData);

  proxy.setValue(nestedObj_nested_alpha, altered);
  expect(proxy.nestedObj.secondNestedObj.nested_x2_beta).toBe('nested_x2_beta');

  expect(testData.nestedObj.secondNestedObj.nested_x2_beta).toBe(
    'nested_x2_beta',
  );
});

test(`OP.05 Test push value on array on first level`, () => {
  const data = { arr: ['test'] };
  const proxy = createProxy(data);
  proxy.pushValue('arr', 'test2');
  expect(proxy.arr.length).toBe(2);
  expect(data.arr.length).toBe(1);
  expect(proxy.arr[1]).toBe('test2');
});

test('OP.06 Test push value on array, on nested array', () => {
  const data = { obj: { arr: ['test'] } };
  const proxy = createProxy(data);
  proxy.pushValue('obj.arr', 'test2');
  expect(proxy.obj.arr.length).toBe(2);
  expect(data.obj.arr.length).toBe(1);
  expect(proxy.obj.arr[1]).toBe('test2');
});

test('OP.07 Remove key', () => {
  const proxy = createProxy(testData);
  proxy.removePathKey(nestedObj_nested_alpha);
  expect(proxy.nestedObj.nested_alpha).toBe(undefined);
  expect(testData.nestedObj.nested_alpha).toBe('nested_alpha');
});

test('OP.08 Has own property', () => {
  const proxy = createProxy(testData);
  expect(proxy.nestedObj.hasOwnProperty('nested_alpha')).toBe(true);
  expect(proxy.hasOwnProperty('not')).toBe(false);

  proxy.removePathKey(nestedObj_nested_alpha);
  expect(proxy.nestedObj.hasOwnProperty('nested_alpha')).toBe(false);
  expect(testData.nestedObj.hasOwnProperty('nested_alpha')).toBe(true);

  proxy.setValue(nestedObj_nested_alpha, 'test');
  expect(proxy.nestedObj.hasOwnProperty('nested_alpha')).toBe(true);
  expect(testData.nestedObj.hasOwnProperty('nested_alpha')).toBe(true);
});

test('OP.09 getKeys', () => {
  const proxy = createProxy(testData);
  proxy.removePathKey(nestedObj_nested_alpha);
  const proxyKeys = proxy.nestedObj.getKeys();
  expect(proxyKeys).toEqual(['secondNestedObj']);
});

test('OP.10 export', () => {
  const proxy = createProxy(testData);
  // add something
  proxy.setValue('beta', 'beta');
  // alter something
  proxy.setValue('nestedObj.secondNestedObj.nested_x2_alpha', altered);
  // remove something
  proxy.removePathKey('nestedObj.secondNestedObj.nested_x2_beta');
  const res = proxy.exportFlattened();
  expect(res).toEqual({
    alpha: 'alpha',
    beta: 'beta',
    nestedObj: {
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: altered,
      },
    },
  });
});

test('OP.11 export including arrays', () => {
  const tmpData = {
    alpha: 'alpha',
    nestedObj: {
      arr: [1, 2],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  };

  const proxy = createProxy(tmpData);
  proxy.exportFlattened();
  // add something
  proxy.setValue('beta', 'beta');
  // alter something
  proxy.setValue('nestedObj.secondNestedObj.nested_x2_alpha', altered);
  // remove something
  proxy.removePathKey('nestedObj.secondNestedObj.nested_x2_beta');
  proxy.pushValue('nestedObj.arr', 3);
  const res = proxy.exportFlattened();
  expect(res).toEqual({
    alpha: 'alpha',
    beta: 'beta',
    nestedObj: {
      arr: [1, 2, 3],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: altered,
      },
    },
  });
});

test('OP.12 Working on and export objects dynamically defined via pushValue', () => {
  const tmpData = {
    alpha: 'alpha',
    nestedObj: {
      arr: [1, 2],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  };

  const proxy = createProxy(tmpData);
  proxy.pushValue('nestedObj.arr', { sthg: 12 });
  let res = proxy.exportFlattened();
  expect(res).toEqual({
    alpha: 'alpha',
    nestedObj: {
      arr: [1, 2, { sthg: 12 }],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  });

  proxy.setValue('nestedObj.arr.2.sthg', 9);
  res = proxy.exportFlattened();
  expect(res).toEqual({
    alpha: 'alpha',
    nestedObj: {
      arr: [1, 2, { sthg: 9 }],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  });
});

test('OP.13 Working on and export objects dynamically defined via setValue', () => {
  const tmpData = {
    alpha: 'alpha',
    nestedObj: {
      arr: [1, 2],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  };

  const proxy = createProxy(tmpData);
  proxy.setValue('beta', { gamma: { delta: 'delta' } });
  proxy.setValue('beta.gamma.delta', 'delta-2');
  const res = proxy.exportFlattened();
  expect(res).toEqual({
    alpha: 'alpha',
    beta: {
      gamma: {
        delta: 'delta-2',
      },
    },
    nestedObj: {
      arr: [1, 2],
      nested_alpha: 'nested_alpha',
      secondNestedObj: {
        nested_x2_alpha: 'nested_x2_alpha',
        nested_x2_beta: 'nested_x2_beta',
      },
    },
  });
});

test('OP.14 Working on a first-level arrays', () => {
  const tmpData = [
    {
      alpha: 'a0',
      beta: {
        gamma: 'g0',
      },
    },
    {
      alpha: 'a1',
      beta: {
        gamma: 'g1',
      },
    },
  ];

  const proxy = createProxy(tmpData);
  const res = proxy.pushValue('', {
    alpha: 'a1',
    beta: {
      gamma: 'g1',
    },
  });

  expect(res).toBe(true);
  expect(proxy[2]).toEqual({ alpha: 'a1', beta: { gamma: 'g1' } });

  const res2 = proxy.setValue('0.beta.gamma', 'g00');
  expect(res2).toBe(true);
  expect(proxy[0].beta.gamma).toBe('g00');
  expect(tmpData[0].beta.gamma).toBe('g0');
  expect(proxy.length).toBe(3);
  expect(tmpData.length).toBe(2);
});

test('OP.15 sortB and findIndex', () => {
  const collection = [
    {
      ms: 3, // becomes 2 after edit
    },
    {
      ms: 0.5, // becomes 1 after edit
    },
  ];
  const proxy = createProxy(collection);
  proxy.setValue('0.ms', 2);
  proxy.setValue('1.ms', 1);
  proxy.sortBy('ms');
  expect(proxy[0]).toEqual({ ms: 1 });
  expect(proxy[1]).toEqual({ ms: 2 });
  expect(collection[0]).toEqual({ ms: 3 });
  expect(collection[1]).toEqual({ ms: 0.5 });

  proxy.pushValue('', { ms: 4 });
  proxy.pushValue('', { ms: 0 });
  proxy.sortBy('ms');
  expect(proxy[0]).toEqual({ ms: 0 });
  expect(proxy[1]).toEqual({ ms: 1 });
  expect(proxy[2]).toEqual({ ms: 2 });
  expect(proxy[3]).toEqual({ ms: 4 });
  expect(collection[0]).toEqual({ ms: 3 });
  expect(collection[1]).toEqual({ ms: 0.5 });
  expect(collection.length).toBe(2);
  const res = proxy.exportFlattened();
  expect(res).toEqual([
    {
      ms: 0,
    },
    {
      ms: 1,
    },
    {
      ms: 2,
    },
    {
      ms: 4,
    },
  ]);

  const index = proxy.findIndex((item) => {
    return item.ms === 2;
  });
  expect(index).toBe(2);

  proxy.setValue('0.ms', 7);
  expect(proxy[0].ms).toBe(7);
  expect(collection[0].ms).toBe(3);
  const res2 = proxy.exportFlattened();
  expect(res2).toEqual([
    {
      ms: 7,
    },
    {
      ms: 1,
    },
    {
      ms: 2,
    },
    {
      ms: 4,
    },
  ]);
  proxy.sortBy('ms');
  const res3 = proxy.exportFlattened();
  const index2 = proxy.findIndex((item) => {
    return item.ms === 1;
  });
  expect(index2).toBe(0);
  expect(res3).toEqual([
    {
      ms: 1,
    },
    {
      ms: 2,
    },
    {
      ms: 4,
    },
    {
      ms: 7,
    },
  ]);
  expect(collection).toEqual([
    {
      ms: 3,
    },
    {
      ms: 0.5,
    },
  ]);
});

test('OP.16 getValue', () => {
  const collection = [
    {
      ms: 3, // becomes 2 after edit
    },
    {
      ms: 0.5,
    },
  ];
  const proxy = createProxy(collection);
  proxy.setValue('0.ms', 2);

  const two = getFromNameSpace('0.ms', '', proxy);
  const half = getFromNameSpace('1.ms', '', proxy);
  expect(two).toBe(2);
  expect(half).toBe(0.5);
});
