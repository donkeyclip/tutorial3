/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import {
  alwaysReturnFalse,
  hasOwnProp,
  isObject,
  sortByIndexes,
} from '../../helper';

const keywords = new Set([
  'getValue',
  'setValue',
  '_getFromProxy',
  '__createPathProxies',
  'hasOwnProperty',
  'pushValue',
  'removePathKey',
  'removeKey',
  'restoreKey',
  'getKeys',
  'exportFlattened',
  'isArray',
  'push',
  'sortBy',
  'findIndex',
]);

// eslint-disable-next-line sonarjs/cognitive-complexity
export function createProxy(originalObject) {
  let proxy = {};
  const removedKeys = new Set();
  let isArray = Array.isArray(originalObject);
  let length = isArray ? originalObject.length : 0;
  // indexesMap maps the real indexes of our proxy to virtual indexes that can be
  // produced by custom array-like & array-specific methods such as sortBy or slice
  let indexesMap = null;

  const overlay = {
    get: function (obj, prop) {
      if (prop === 'length' && isArray) {
        return length;
      }
      if (keywords.has(prop)) {
        return this[prop];
      }
      if (removedKeys.has(prop)) {
        return undefined;
      }

      if (isArray && indexesMap !== null) {
        prop = indexesMap[prop];
      }
      if (hasOwnProp(proxy, prop)) {
        return proxy[prop];
      }
      return originalObject[prop];
    },

    isArray() {
      return isArray;
    },

    _getFromProxy(prop) {
      return hasOwnProp(proxy, prop) ? proxy[prop] : undefined;
    },

    set: alwaysReturnFalse,

    sortBy(what) {
      indexesMap = null;
      if (!isArray) {
        return false;
      }
      indexesMap = sortByIndexes(this, what);
    },

    __createPathProxies(arrayPath) {
      let currentObject = proxy;
      let currentRealObect = originalObject;

      // if they don't already exist, create Proxies all the way down the path
      for (let i = 0; i < arrayPath.length - 1; i++) {
        // if our current object doesn't already have the specific key
        const key =
          isArray && indexesMap !== null
            ? indexesMap[arrayPath[i]]
            : arrayPath[i];

        const decision =
          i === 0
            ? currentObject[key] === undefined
            : currentObject._getFromProxy(key) === undefined;

        if (decision) {
          // we create a new proxy passing as originalData the data of our originalData
          const childProxy = createProxy(
            currentRealObect !== undefined ? currentRealObect[key] || {} : {},
          );
          if (i === 0) {
            currentObject[key] = childProxy; // our proxy now points to the new proxy on the specific key
          } else {
            currentObject.setValue(key, childProxy);
          }
        }

        currentObject = currentObject[key];
        currentRealObect =
          currentRealObect !== undefined ? currentRealObect[key] : {};
      }
      return { currentObject, currentRealObect };
    },

    /* a method that accepts the array element and if it returns true the element's index is returned */
    findIndex(method) {
      if (!isArray) {
        return null;
      }
      for (let i = 0; i < length; i++) {
        if (method(this[i])) {
          return i;
        }
      }
      return null;
    },

    setValue(path, value) {
      const arrayPath = path.split('.');
      const currentObject = this.__createPathProxies(arrayPath).currentObject;
      let valueToSet = value;
      if (isObject(value)) {
        valueToSet = createProxy(value);
      }
      if (arrayPath.length === 1) {
        currentObject[arrayPath[arrayPath.length - 1]] = valueToSet;
        // sets only delete an element if it exists, otherwise they return false
        removedKeys.delete(valueToSet);
      } else {
        currentObject.setValue(arrayPath[arrayPath.length - 1], valueToSet);
        currentObject.restoreKey(arrayPath[arrayPath.length - 1]);
      }
      return true;
    },

    pushValue(path, value) {
      let arrayPath = path.split('.');
      const { currentObject, currentRealObect } =
        this.__createPathProxies(arrayPath);
      if (currentRealObect === undefined) {
        return false;
      }

      const lastKey = arrayPath[arrayPath.length - 1];
      let currentObjectTarget = currentObject[lastKey];
      let originalObjectTarget = originalObject[lastKey];

      if (path === '') {
        // if it refers directly to our proxy
        currentObjectTarget = this;
        originalObjectTarget = originalObject;
      }

      if (arrayPath.length !== 1) {
        return currentObject.pushValue(lastKey, value);
      }
      // if the target array is an attribute directly of our proxy
      // first check if our target (either belonging on the proxy or on the original data) is an array
      let existsOnProxy = false;
      if (currentObjectTarget !== undefined) {
        // if the key already exists on our proxy
        existsOnProxy = true;
        if (!currentObjectTarget.isArray()) {
          return false;
        }
      } else {
        if (!Array.isArray(originalObjectTarget)) {
          return false;
        }
      }

      // then, if the array is not already implemented as proxy, create a proxy for it
      if (!existsOnProxy) {
        const arrayProxy = createProxy(originalObjectTarget);
        currentObject[lastKey] = arrayProxy;
        currentObjectTarget = currentObject[lastKey];
      }

      // finally, push the new entry on the proxy array
      currentObjectTarget.push(value);

      return true;
    },

    push(value) {
      if (!this.isArray()) {
        return false;
      }
      proxy[length] = isObject(value) ? createProxy(value) : value;

      length += 1;
      return true;
    },

    removePathKey(path) {
      const arrayPath = path.split('.');
      const { currentObject } = this.__createPathProxies(arrayPath);

      currentObject.removeKey(arrayPath[arrayPath.length - 1]);
      return true;
    },

    removeKey(key) {
      removedKeys.add(key);
    },

    restoreKey(key) {
      removedKeys.delete(key);
    },

    hasOwnProperty(key) {
      return !(removedKeys.has(key) || this[key] === undefined);
    },

    getKeys() {
      if (isArray) {
        return [];
      }

      let allKeys = Object.keys(originalObject);
      allKeys.push(...Object.keys(proxy));
      allKeys = allKeys.filter((item) => !removedKeys.has(item));

      return allKeys;
    },
    exportFlattened() {
      let toReturn;
      if (isArray) {
        toReturn = [];
        if (indexesMap !== null) {
          for (let i = 0; i < indexesMap.length; i++) {
            const key = indexesMap[i];
            if (hasOwnProp(proxy, key)) {
              // if it exists in our proxy
              const value = proxy[key];
              if (isObject(value)) {
                // if it's an object
                try {
                  toReturn[i] = proxy[key].exportFlattened(); // get the flattened version
                } catch (e) {
                  toReturn[i] = value;
                }
              } else {
                toReturn[i] = value; // else just copy the value of the proxy to our output
              }
            } else {
              toReturn[i] = originalObject[key];
            }
          }
        } else {
          toReturn = [...originalObject];
          for (const [key, value] of Object.entries(proxy)) {
            if (isObject(value)) {
              // if it's an object
              try {
                toReturn[key] = proxy[key].exportFlattened(); // get the flattened version
              } catch (e) {
                toReturn[key] = value;
              }
            } else {
              toReturn[key] = value; // else just copy the value of the proxy to our output
            }
          }
        }
      } else {
        toReturn = {};
        const keys = this.getKeys();
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (proxy[key] !== undefined) {
            // if it's on the proxy side
            toReturn[key] = isObject(proxy[key])
              ? proxy[key].exportFlattened() // if it's an object get the flattened version
              : proxy[key];
          } else {
            // if it resides on the real array
            toReturn[key] = originalObject[key];
          }
        }
      }
      return toReturn;
    },
  };

  return new Proxy(originalObject, overlay);
}

export default createProxy;
