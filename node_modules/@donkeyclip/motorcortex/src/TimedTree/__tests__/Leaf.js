import Leaf from '../Leaf';
import Node from '../Node';
import { _DIRECTIONS } from '../_CONST';

const fooTarget = 'foo-target';

const plainLeaf = new Leaf({ id: 'plain-leaf' });
const node = new Node();
class HandlerLeaf extends Leaf {
  handleTestMessage(target, payload) {
    if (payload === 1 && target === 'foo-target') {
      return true;
    }

    return this.bypass();
  }
}
const handlerLeaf = new HandlerLeaf({ duration: 1000 });

test('should generate an id if it is not provided on the props', () => {
  expect(handlerLeaf.id).toHaveLength(18);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, fooTarget, {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    }),
  ).toEqual({
    response: false,
    responder: null,
  });
});

test('should return an empty payload for _DOWN messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, fooTarget, {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN,
    }),
  ).toEqual([]);
});

// eslint-disable-next-line sonarjs/no-identical-functions
test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, fooTarget, {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    }),
  ).toEqual({
    response: false,
    responder: null,
  });
});

// eslint-disable-next-line sonarjs/no-identical-functions
test('should return an empty array for _DOWN messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, fooTarget, {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN,
    }),
  ).toEqual([]);
});

test('should return true for _UP messages for a message it (conditionally) handles and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, fooTarget, {
    selfExecute: true,
    direction: _DIRECTIONS._UP,
  });
  expect(res.responder).toEqual(handlerLeaf);
  expect(res.response).toBe(true);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 0, fooTarget, {
    selfExecute: true,
    direction: _DIRECTIONS._UP,
  });
  expect(res).toEqual({
    response: false,
    responder: null,
  });
});

test('should return a response array for _DOWN messages for a message it (conditionally) handles and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, fooTarget, {
    selfExecute: true,
    direction: _DIRECTIONS._DOWN,
  });
  expect(res).toHaveLength(1);
  expect(res[0].responder).toEqual(handlerLeaf);
  expect(res[0].response).toBe(true);
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 0, fooTarget, {
    selfExecute: true,
    direction: _DIRECTIONS._DOWN,
  });
  expect(res).toEqual([]);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) hanldes when selfExecute=false', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, fooTarget, {
    selfExecute: false,
    direction: _DIRECTIONS._UP,
  });
  expect(res).toEqual({
    response: false,
    responder: null,
  });
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) hanldes but selfExecute=false', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, fooTarget, {
    selfExecute: false,
    direction: _DIRECTIONS._DOWN,
  });
  expect(res).toEqual([]);
});

test('should assign its parent when added to a Node', () => {
  node.addChild(plainLeaf, 2000);
  expect(plainLeaf.parentNode).toBe(node);
  expect(plainLeaf.hasParent).toBe(true);
});

test('should release its parent when removed from a Node', () => {
  node.removeChild(plainLeaf.id);
  expect(plainLeaf.parentNode).toBe(null);
  expect(plainLeaf.hasParent).toBe(false);
});

test('A single Node should return 0 positionOnPyramidion', () => {
  const tmpNode = new Node();
  expect(tmpNode.positionOnPyramidion).toBe(0);
});

test('A Leaf positioned directly on a Node should return its position on positionOnPyramidion', () => {
  const tmpNode = new Node();
  const tmpLeaf = new Leaf({ id: 'tmp-leaf' });
  tmpNode.addChild(tmpLeaf, 2000);
  expect(tmpLeaf.positionOnPyramidion).toBe(2000);
});

test('A second layer Leaf positioned on a Node should return its position on positionOnPyramidion', () => {
  const tmpNode = new Node();
  const tmpNode2 = new Node();
  const tmpLeaf = new Leaf({ id: 'tmp-leaf' });
  tmpNode.addChild(tmpLeaf, 2000);
  tmpNode2.addChild(tmpNode, 1500);
  expect(tmpLeaf.positionOnPyramidion).toBe(3500);
  expect(tmpNode.positionOnPyramidion).toBe(1500);
  expect(tmpNode2.positionOnPyramidion).toBe(0);
});

test('Initialise a Leaf with name', () => {
  const leaf = new Leaf({
    id: 'test-leaf',
    name: 'name of the leaf',
  });
  expect(leaf.name).toBe('name of the leaf');
});

test('Initialise a Leaf without name should return name=null', () => {
  const leaf = new Leaf({
    id: 'test-leaf',
  });
  expect(leaf.name).toBe(null);
});

test('Setting the name of a Leaf', () => {
  const leaf = new Leaf({
    id: 'test-leaf',
  });
  leaf.name = 'test';
  expect(leaf.name).toBe('test');
});
