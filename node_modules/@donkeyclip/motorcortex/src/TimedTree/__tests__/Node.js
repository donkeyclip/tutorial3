/* eslint-disable sonarjs/no-duplicate-string */
import Leaf from '../Leaf';
import Node from '../Node';
import { _DIRECTIONS, _TARGETTYPES } from '../_CONST';
import {
  _LEAFALREADYASSIGNED,
  _LEAFNOTFOUND,
  _NEGATIVEPOSITIONNOTALLOWED,
} from '../_copy';

class TestNode extends Node {
  handleRootRequest(target) {
    // eslint-disable-line no-unused-vars
    if (target === _TARGETTYPES._ROOTOFTREE) {
      return this.id;
    }
  }
}

const testNode = new TestNode({ id: 'test-node' });
const node = new Node();
const plainNode = new Node({ id: 'plain-node' });
const plainNodeTwo = new Node({ id: 'plain-node-two' });

class TestLeaf extends Leaf {
  handleGather() {
    // eslint-disable-line no-unused-vars
    if (this.isEligible !== true) {
      return this.bypass();
    }

    return this.id;
  }
}
const _leafA = new TestLeaf({ id: '_leafA' });
_leafA.isEligible = true;
const _leafB = new TestLeaf({ id: '_leafB' });
_leafB.isEligible = true;
const leafA = new TestLeaf({ id: 'leafA' });
const leafB = new TestLeaf({ id: 'leafB' });

/** ************************* ID ASSIGNMENT ************************************ */
test('should generate an id if it is not provided on the props', () => {
  expect(node.id).toHaveLength(18);
});

/** ********************* NULL TARGET WHILE BEING FREE ****************************** */
test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainNode.putMessageOnPipe('foo', {}, 'foo-target', {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    }),
  ).toEqual({
    response: false,
    responder: null,
  });
});

test('should return an empty payload for _DOWN messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainNode.putMessageOnPipe('foo', {}, 'foo-target', {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN,
    }),
  ).toEqual([]);
});

// eslint-disable-next-line sonarjs/no-identical-functions
test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainNode.putMessageOnPipe('foo', {}, 'foo-target', {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    }),
  ).toEqual({
    response: false,
    responder: null,
  });
});

// eslint-disable-next-line sonarjs/no-identical-functions
test('should return an empty array for _DOWN messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainNode.putMessageOnPipe('foo', {}, 'foo-target', {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN,
    }),
  ).toEqual([]);
});

/** ************************ ADDING LEAFS TO NODES *************************** */
test('check addition should pass', () => {
  expect(node.checkAddition(plainNode, 2000)).toEqual({
    result: true,
  });
});

test('should assign its parent when added to a Node. Also, parent should add the leaf in its children', () => {
  node.addChild(plainNode, 2000);
  expect(node.children[plainNode.id].leaf).toBe(plainNode);
  expect(node.children[plainNode.id]).toEqual({
    id: plainNode.id,
    leaf: plainNode,
    position: 2000,
  });
});

test('check addition should not pass because leaf already belongs to parent', () => {
  expect(node.checkAddition(plainNode, 2000)).toEqual({
    result: false,
    reason: _LEAFALREADYASSIGNED,
  });
});

test('check addition should not pass because of a negative position', () => {
  plainNodeTwo.id = 'plain-node-two';
  expect(node.checkAddition(plainNodeTwo, -200)).toEqual({
    result: false,
    reason: _NEGATIVEPOSITIONNOTALLOWED,
  });
});

/** ************************ _DOWN MESSAGE *************************************** */
test('Gather responses from eligible Leafs', () => {
  plainNode.addChild(leafA, 1000);
  plainNode.addChild(leafB, 2000);
  plainNode.addChild(_leafA, 3000);
  plainNode.addChild(_leafB, 4000);

  const res = node.putMessageOnPipe(
    'gather',
    {},
    {},
    { selfExecute: true, direction: _DIRECTIONS._DOWN },
  );
  expect(res).toEqual([
    {
      response: '_leafA',
      responder: _leafA,
      positionDelta: 5000,
    },
    {
      response: '_leafB',
      responder: _leafB,
      positionDelta: 6000,
    },
  ]);
});

/** *********************** UP MESSAGE TARGETING ROOT *************************** */
test('should not get back an answer as the root is not eligible to handle the root request', () => {
  const res = leafA.putMessageOnPipe(
    'rootRequest',
    {},
    _TARGETTYPES._ROOTOFTREE,
    {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    },
  );
  expect(res).toEqual({
    response: false,
    responder: null,
  });
});

test('should get back an answer as the root is now eligible to handle the root request', () => {
  testNode.addChild(node, 2000);
  const res = leafA.putMessageOnPipe(
    'rootRequest',
    {},
    _TARGETTYPES._ROOTOFTREE,
    {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    },
  );
  expect(res).toEqual({
    response: 'test-node',
    responder: testNode,
  });
});

/** ************************ GET LEAF BY ID ************************************** */
test('should return the leaf by ID', () => {
  const res = testNode.getLeafById('_leafA');
  expect(res).toEqual(_leafA);
});

/** ************************ REMOVING LEAFS FROM NODES *************************** */
test('should return error when trying to remove a Leaf that does not exist', () => {
  expect(node.checkRemoveChild('not-existing-id')).toEqual({
    result: false,
    reason: _LEAFNOTFOUND,
  });
});

test('should release its parent when removed from a Node. Also, parent should remove the leaf from its children', () => {
  node.removeChild(plainNode.id);
  expect(plainNode.parentNode).toBe(null);
  expect(plainNode.hasParent).toBe(false);
});

/** ********************* EDIT POSITION ****************************** */
test('should not allow position edit when negative position is provided', () => {
  const res = plainNode.checkEditPosition('leafA', -150);
  expect(res).toEqual({
    result: false,
    reason: _NEGATIVEPOSITIONNOTALLOWED,
  });
});

test('trying to edit position on an non-existing id should return error', () => {
  const res = plainNode.checkEditPosition('non-existing', 150);
  expect(res).toEqual({
    result: false,
    reason: _LEAFNOTFOUND,
  });
});

test('successful editing position', () => {
  const check = plainNode.checkEditPosition('leafB', 5000);
  const res = plainNode.editPosition('leafB', 5000);
  expect(check).toEqual({
    result: true,
  });

  expect(res).toEqual({
    result: true,
  });

  expect(plainNode.children.leafB).toEqual({
    id: 'leafB',
    leaf: leafB,
    position: 5000,
  });
});

test('getLeafPosition', () => {
  const node0 = new Node({ id: 'node0' });
  const node1 = new Node({ id: 'node1' });
  const node2 = new Node({ id: 'node2' });
  const leaf0 = new Leaf({ id: 'leaf0' });

  node0.addChild(node1, 1000);
  node1.addChild(node2, 1500);
  node2.addChild(leaf0, 600);

  expect(node0.getLeafPosition('node1')).toBe(1000);
  expect(node0.getLeafPosition('node2')).toBe(2500);
  expect(node0.getLeafPosition('leaf0')).toBe(3100);
  expect(node2.getLeafPosition('leaf0')).toBe(600);
});

/** ********************* DURATION ****************************** */
test('test duration of an empty Node that has hiatus and delay', () => {
  const node0 = new Node({
    id: 'node0',
    delay: 1000,
    hiatus: 1600,
  });
  expect(node0.calculatedDuration).toBe(0);
  expect(node0.duration).toBe(2600);
});

test('test duration of a Node that has hiatus, delay and repeats', () => {
  const node0 = new Node({
    id: 'node0',
    delay: 1000,
    hiatus: 1600,
    repeats: 3,
  });
  const leaf0 = new Leaf({ id: 'leaf0', duration: 1350 });
  node0.addChild(leaf0, 150);
  expect(node0.duration).toBe((1000 + 1600 + 1500) * 3);
  expect(node0.calculatedDuration).toBe(1500);
  node0.removeChild('leaf0');
  expect(node0.calculatedDuration).toBe(0);
  expect(node0.duration).toBe(3 * 2600);
});
