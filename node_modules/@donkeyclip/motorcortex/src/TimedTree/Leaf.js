/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import constructIncident from '../IncidentFromDefinition/clipFromDefinition';
import {
  _CantBeResized,
  _SizeBiggerThanZero,
} from '../_configuration/rejectionReasons';
import { identifyDynamicValues } from '../_coreUtils/dynamicValues/dynamicValueIdentifier';
import {
  getAnId,
  jsUcfirst,
  hasOwnProp,
  validateProps,
} from '../_coreUtils/helper';
import { addToNameSpace } from '../_coreUtils/proxies/nameSpaceHandler/nameSpaceHandler';

import { _BYPASS, _DIRECTIONS, _TARGETTYPES } from './_CONST';

class Leaf {
  constructor(props = {}) {
    // parentNode is a reference to the parent Node the Leaf is attached to (if any)
    this.parentNode = null;
    this.isNode = false;

    this.id = hasOwnProp(props, 'id') ? props.id : getAnId();

    this.props = props;
    this.resetDuration();
  }

  get name() {
    return hasOwnProp(this.props, 'name') ? this.props.name : null;
  }

  set name(newName) {
    this.props.name = newName;
  }

  get delay() {
    return hasOwnProp(this.props, 'delay') ? this.props.delay : 0;
  }

  set delay(val) {
    if (val !== 0) {
      this.props.delay = val;
    }
    this.resetDuration();
  }

  get hiatus() {
    return hasOwnProp(this.props, 'hiatus') ? this.props.hiatus : 0;
  }

  set hiatus(val) {
    if (val !== 0) {
      this.props.hiatus = val;
    }
    this.resetDuration();
  }

  get repeats() {
    return hasOwnProp(this.props, 'repeats') ? this.props.repeats : 1;
  }

  set repeats(val) {
    this.props.repeats = val;
    this.resetDuration();
  }

  /**
   *
   * @param {boolean} triggerUp - if provided to true the reset triggers reset duration on the
   * Leaf's parents too. Defaults to false
   */
  resetDuration(triggerUp = false) {
    this._duration =
      this.repeats * (this.delay + this.props.duration + this.hiatus);
    if (triggerUp) {
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP,
      });
    }
  }

  /**
   * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and
   * repeats factor
   * */
  get duration() {
    return this._duration;
  }

  /**
   * the setter sets the overall duration of the Leaf by altering all
   * delay, duration and hiatus properties of it
   * */
  set duration(milliseconds) {
    const fraction = milliseconds / this.duration;
    this.props.duration *= fraction;
    this.hiatus *= fraction;
    this.delay *= fraction;
    this.resetDuration();
  }

  /**
   * setNewDuration method sets the new FULL duration as it derives from the
   * delay, duration, hiatus and repeats factors
   * */
  setNewDuration(newDuration) {
    this.duration = newDuration;
    this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    });
  }

  systoleDiastole(durationFraction) {
    this.duration *= durationFraction;
  }

  get hasParent() {
    return this.parentNode !== null;
  }

  attachToNode(node) {
    this.parentNode = node;
  }

  detachFromParent() {
    this.parentNode = null;
  }

  /**
  @param {string} name - the name of the message
  @param {object} payload - the payload of the message
  @param {object} target - specifies the target of the message in a key-value pairs object
  @param {object} options - in the form:
  {
      direction (either _UP or _DOWN)
      selfExecute (either true which means the Leaf should try to handle the message itself or
          false which means the Leaf should directly forward the message to its parent)
  }
  @returns The expected result of this method is on the form:
  {
      response: an object the structure of which depends on the name of the message
          and maybe even on the payload
      responder: a direct reference to the lead that actually responded
      (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester
  }
  * */
  putMessageOnPipe(name, payload, target, options = {}) {
    // default direction: _DOWN
    if (!hasOwnProp(options, 'direction')) {
      options.direction = _DIRECTIONS._DOWN;
    }

    // default positionDelta = 0
    if (
      options.direction === _DIRECTIONS._DOWN &&
      !hasOwnProp(options, 'positionDelta')
    ) {
      options.positionDelta = 0;
    }

    if (options.selfExecute) {
      // if the Leaf has a "handle<name>" method with the first letter of
      // name in Capital it runs it
      const handlingMethodName = `handle${jsUcfirst(name)}`;
      const capable = typeof this[handlingMethodName] === 'function';

      if (capable) {
        const response = this[handlingMethodName](target, payload);
        if (response !== _BYPASS) {
          const result = {
            response,
            responder: this,
          };
          if (options.direction === _DIRECTIONS._UP) {
            return result;
          }

          return [{ ...result, positionDelta: options.positionDelta }];
        }
      }
    }

    if (options.direction !== _DIRECTIONS._UP) {
      return [];
    }
    if (this.hasParent) {
      return this.parentNode.putMessageOnPipe(name, payload, target, {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      });
    }
    // if the message reaches the top of the tree without finding any liable target
    return {
      response: false,
      responder: null,
    };
  }

  bypass() {
    return _BYPASS;
  }

  // Postion on Pyramidion
  // "Pyramidion" is the uppermost piece or capstone of an Egyptian pyramid.
  // To us "Pyramidion" is the top Node of the TimedTree to which this Leaf belongs to
  // and the following infrastructure implements it
  get positionOnPyramidion() {
    return this.getPositionOnPyramidion();
  }

  getPositionOnPyramidion(delta = 0) {
    if (!this.hasParent) {
      return delta;
    }
    const result = this.putMessageOnPipe(
      'getPositionOnPyramidion',
      { delta, id: this.id },
      'Parent',
      {
        selfExecute: false,
        direction: _DIRECTIONS._UP,
      },
    );
    return result.response;
  }

  editAttributes(newAttrs) {
    if (this.constructor.attrsValidationRules !== null) {
      const validationResult = this.constructor.attrsValidationMethod(newAttrs);
      if (validationResult.length > 0) {
        return {
          result: false,
          errors: validationResult,
        };
      }
    }

    const checkIfBelongsToClip = this.putMessageOnPipe(
      'checkForClip',
      {},
      _TARGETTYPES._DECISIONAUTHORITY,
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    );
    if (checkIfBelongsToClip.response) {
      // if the Group belongs on a Clip
      return this.manageEditAttrProps(newAttrs, 'attrs');
    }

    this.attrs = newAttrs;
    return {
      result: true,
    };
  }

  editProperties(newProps) {
    const validation = validateProps(
      newProps,
      this.constructor.propsValidationRules,
      this.constructor,
    );
    if (!validation.result) {
      return validation;
    }
    const checkIfBelongsToClip = this.putMessageOnPipe(
      'checkForClip',
      {},
      _TARGETTYPES._DECISIONAUTHORITY,
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    );
    if (checkIfBelongsToClip.response) {
      // if the Group belongs on a Clip
      return this.manageEditAttrProps(newProps, 'props');
    }

    this.props = newProps;
    return {
      result: true,
    };
  }

  resize(newSize, options = { check: true }) {
    if (this.duration === 'dynamic') {
      return {
        result: false,
        reason: _CantBeResized,
      };
    }

    if (newSize === this.duration) {
      return {
        result: true,
        meta: {
          unprocessed: true,
        },
      };
    }

    if (newSize <= 0) {
      return {
        result: false,
        reason: _SizeBiggerThanZero,
      };
    }

    if (options.check && this.hasParent) {
      const mcCheck = this.putMessageOnPipe(
        'checkResize',
        { id: this.id, newSize, fraction: newSize / this.duration },
        _TARGETTYPES._DECISIONAUTHORITY,
        { selfExecute: false, direction: _DIRECTIONS._UP },
      );

      if (!mcCheck.response.result) {
        return mcCheck.response;
      }
    }

    this.setNewDuration(newSize);

    return {
      result: true,
    };
  }

  clone(attrs = {}, props = {}) {
    let def = this.exportLiveDefinition();
    for (let path in attrs) {
      addToNameSpace(path, attrs[path], true, 'attrs', def);
    }
    for (let path in props) {
      addToNameSpace(path, props[path], true, 'props', def);
    }
    return constructIncident(def);
  }

  selector() {
    if (this.inheritedSelector === null) {
      // if the Incident has no parent selector inherited
      return !hasOwnProp(this.props, 'selector') ? null : this.props.selector; // else, if it has a selector that's its final selector
    }
    // else if there is an inherited selector
    if (!hasOwnProp(this.props, 'selector')) {
      // and does not have a selector of its own
      return this.inheritedSelector; // then its selector is equal to the inherited selector
    }
    // else, if it both has an inherited and an own selector
    if (this.props.selector.charAt(0) === '&') {
      return this.inheritedSelector + this.props.selector.substring(1);
    }

    return `${this.inheritedSelector} ${this.props.selector}`;
  }

  getElements() {
    if (this.props.host !== null && this.props.host !== undefined) {
      return [this.props.host];
    }

    if (!this.hasParent) {
      return [];
    }

    const checkIfBelongsToClip = this.putMessageOnPipe(
      'checkForClip',
      {},
      _TARGETTYPES._DECISIONAUTHORITY,
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    );
    if (!checkIfBelongsToClip.response) {
      return [];
    }

    const elementsResponse = this.putMessageOnPipe(
      'getElements',
      { selector: this.selector() },
      _TARGETTYPES._DECISIONAUTHORITY,
      { selfExecute: false, direction: _DIRECTIONS._UP },
    );
    return elementsResponse.response;
  }

  setupDynamicValues() {
    /**
     * report is what this method returns. It actually holds for attrs and props
     * the information of how many dynamic values have been identified by type.
     * For example if attrs have two "stagger" and one "expression" dynamic values
     * on the report props would be: {stagger: 2, expression: 1}
     */
    const report = {
      attrs: {},
      props: {},
    };

    for (const key of ['attrs', 'props']) {
      const incidentPropsStaggers = identifyDynamicValues(this[key]);
      for (const stagger of incidentPropsStaggers) {
        const DVHanlder = stagger.Handler;
        const propsToPass = {
          value: stagger.value,
          integer: stagger.integer,
        };
        this[`${key === 'attrs' ? 'attributes' : 'props'}Staggers`].push({
          path: stagger.path,
          stagger: new DVHanlder(propsToPass),
        });
        // if the dynamic value type is undefined on report.props initialise it as 0
        if (!hasOwnProp(report[key], stagger.dynamicType)) {
          report[key][stagger.dynamicType] = 1;
          continue;
        }
        report[key][stagger.dynamicType] += 1;
      }
    }

    return report;
  }
}

export default Leaf;
