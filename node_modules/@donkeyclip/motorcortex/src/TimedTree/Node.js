/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Leaf from './Leaf';
import { _DIRECTIONS } from './_CONST';
import {
  _LEAFALREADYASSIGNED,
  _LEAFNOTFOUND,
  _NEGATIVEPOSITIONNOTALLOWED,
} from './_copy';
import { hasOwnProp } from '../_coreUtils/helper';
class Node extends Leaf {
  constructor(props = {}) {
    super(props);

    this.isNode = true;

    /**
    The object holds the Incidents of the Scene on the format:
    {
        <id>: {
              id // the id of the Incident object
              leaf // the incident object
              position // the position of the incident
        },
        ...
    }
     */
    this.children = {};

    this.calculatedDuration = 0;
    this.resetDuration();
  }

  /**
   * We want to keep our duration as number and avoid getter because of performance.
   * For this each time the duration must be recalculated we can call this method
   */
  resetDuration() {
    this._duration =
      this.repeats * (this.delay + this.calculatedDuration + this.hiatus);
  }

  get duration() {
    return this._duration;
  }

  set duration(milliseconds) {
    if (this.duration === 0) {
      return;
    }
    const fraction = milliseconds / this.duration;
    this.calculatedDuration *= fraction;
    this.hiatus *= fraction;
    this.delay *= fraction;
    this.resetDuration();
    for (const childKey in this.children) {
      const child = this.children[childKey];
      this.editPosition(child.id, child.position * fraction, true);
      child.leaf.systoleDiastole(fraction);
    }
  }

  /**
   *
   * @param {object} payload - an object with the childId key. This object is provided on addition actions
   * so it executes recalc with better performance
   * @returns {boolean}
   * @private
   */
  _calculateDuration(payload) {
    if (!payload || payload.childId != null) {
      const child = this.children[payload.childId];
      const childEnd = child.leaf.duration + child.position;
      if (childEnd > this.calculatedDuration) {
        this.calculatedDuration = childEnd;
        this.resetDuration();
        return true;
      }
      return false;
    }

    // plain handling with no input provided
    let duration = 0;
    for (const childKey in this.children) {
      const child = this.children[childKey];
      if (child.position + child.leaf.duration > duration) {
        duration = child.position + child.leaf.duration;
      }
    }

    if (duration === this.calculatedDuration) {
      return false;
    }

    this.calculatedDuration = duration;
    this.resetDuration();
    return true;
  }

  // eslint-disable-next-line no-unused-vars
  handleRecalcDuration(target, payload) {
    if (this._calculateDuration(payload)) {
      return this.putMessageOnPipe(
        'recalcDuration',
        payload.childId ? { childId: this.id } : {}, // if there is childId in the payload we are handling an addition. Only in additions we pass the childId further up
        'Groups',
        {
          selfExecute: false,
          direction: _DIRECTIONS._UP,
        },
      );
    }
    return true;
  }

  getLeafById(id, onlyDirectChild = false) {
    if (hasOwnProp(this.children, id)) {
      return this.children[id].leaf;
    }
    if (!onlyDirectChild) {
      for (const child in this.children) {
        const childLeaf = this.children[child].leaf;
        if (childLeaf.isNode) {
          const leaf = childLeaf.getLeafById(id);
          if (leaf != null) {
            return leaf;
          }
        }
      }
    }

    return null;
  }

  getLeafPosition(id) {
    if (hasOwnProp(this.children, id)) {
      return this.children[id].position;
    }

    const res = this.putMessageOnPipe('getLeafPosition', { id }, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._DOWN,
    });
    if (res.length > 0) {
      return res[0].positionDelta + res[0].response;
    }
  }

  handleGetLeafPosition(target, payload) {
    return this.getLeafPosition(payload.id);
  }

  checkAddition(leaf, position) {
    if (leaf.hasParent) {
      return {
        result: false,
        reason: _LEAFALREADYASSIGNED,
      };
    }

    if (position < 0) {
      return {
        result: false,
        reason: _NEGATIVEPOSITIONNOTALLOWED,
      };
    }

    return {
      result: true,
    };
  }

  addChild(leaf, position) {
    // this hasParent check occurs here as an extra security check so it
    // gets executed regardless if the user wants to perform checks or not
    if (leaf.hasParent) {
      return {
        result: false,
        reason: _LEAFALREADYASSIGNED,
      };
    }

    this.children[leaf.id] = {
      id: leaf.id,
      leaf,
      position,
    };

    leaf.attachToNode(this);
    return this.putMsgOnPipeWithResult(
      'recalcDuration',
      { childId: leaf.id },
      'Groups',
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    );
  }

  checkRemoveChild(id) {
    if (!hasOwnProp(this.children, id)) {
      return {
        result: false,
        reason: _LEAFNOTFOUND,
      };
    }

    return {
      result: true,
    };
  }

  removeChild(id) {
    this.children[id].leaf.detachFromParent();
    delete this.children[id];

    return this.putMsgOnPipeWithResult('recalcDuration', {}, 'Groups', {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    });
  }

  checkEditPosition(id, position) {
    if (position < 0) {
      return {
        result: false,
        reason: _NEGATIVEPOSITIONNOTALLOWED,
      };
    }

    if (!hasOwnProp(this.children, id)) {
      return {
        result: false,
        reason: _LEAFNOTFOUND,
      };
    }

    return {
      result: true,
    };
  }

  editPosition(id, position, bypassRecalcDuration = false) {
    if (!hasOwnProp(this.children, id)) {
      return;
    }

    this.children[id].position = position;
    if (!bypassRecalcDuration) {
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      });
    }

    return {
      result: true,
    };
  }

  /**
    The expected result of this method depends on the direction of the message
    The direction might either be _UP or _DOWN.
    In the case of _UP the expected result is identical as on Leaf:
    {
        response: an object the structure of which depends on the name of the message
            and maybe even on the payload
        responder: a direct reference to the lead that actually responded
    }
    In the case of _DOWN though, where multiple Leafs might be eligible in the tree
    for handling the message the result is on the form:
    [
        {
            response: an object the structure of which depends on the name of the message
                and maybe even on the payload
            responder: a direct reference to the lead that actually responded
            positionDelta: the position delta of the responder compared to the requester
        }
    ]
    */
  putMessageOnPipe(name, payload, target, options = {}) {
    // default direction: _DOWN
    if (!hasOwnProp(options, 'direction')) {
      options.direction = _DIRECTIONS._DOWN;
    }

    // default positionDelta = 0
    if (
      options.direction === _DIRECTIONS._DOWN &&
      !hasOwnProp(options, 'positionDelta')
    ) {
      options.positionDelta = 0;
    }

    if (options.direction === _DIRECTIONS._UP) {
      // if the direction is up
      return super.putMessageOnPipe(name, payload, target, options); // act exactly as any other Leaf
    }

    let result = super.putMessageOnPipe(name, payload, target, options);
    if (result.length > 0) {
      return result;
    }

    for (const child in this.children) {
      const { leaf } = this.children[child];
      const newOptions = {
        ...options,
        selfExecute: true,
        positionDelta: options.positionDelta + this.children[child].position,
      };
      result.push(...leaf.putMessageOnPipe(name, payload, target, newOptions));
    }

    return result;
  }

  putMsgOnPipeWithResult(name, payload, target, options = {}) {
    this.putMessageOnPipe(name, payload, target, options);
    return {
      result: true,
    };
  }

  handleGetPositionOnPyramidion(target, payload) {
    const delta = payload.delta + this.getLeafPosition(payload.id);
    return this.getPositionOnPyramidion(delta);
  }
}

export default Node;
