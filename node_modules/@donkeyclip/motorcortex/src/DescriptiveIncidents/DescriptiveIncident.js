/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/*
Descriptive Incident is the Descriptive representation of the MonoIncident. It is the holder of the following info:
  static Incident // the real MonoIncident Class
  static plugin_npm_name // the name of the plugin the Incident belongs to. Defaults to 'motor-cortex-js-attribute'
  static version // the version of the plugin it belongs to
  static Channel // the Channel of the Incident
  static ClassName // the name of the Class
  static attrsValidationRules // compiled rules for attrs validation (added by pluginLoader)
  static propsValidationRules // compiled rules for props validation  (compiled here)
 */

import AttributeChannel from '../Channels/Attribute/AttributeChannel';
import MonoIncident from '../RealIncidents/MonoIncident';
import Leaf from '../TimedTree/Leaf';
import version from '../version';
import { incidentPropsRule } from '../_configuration/propsValidationRules';
import { _MC_Attribute } from '../_configuration/_CONST';
import {
  assignValueToPath,
  deepCopy,
  hasOwnProp,
  validateProps,
} from '../_coreUtils/helper';

class DescriptiveIncident extends Leaf {
  constructor(attrs, props) {
    if (props === undefined) {
      props = attrs;
      attrs = {};
    }

    super(props);

    const propsValidation = validateProps(
      props,
      incidentPropsRule,
      this.constructor,
      this.id,
    );
    if (!propsValidation.result) {
      return propsValidation;
    }

    this.inheritedSelector = null;

    this.attrs = attrs;
    if (!hasOwnProp(props, 'duration')) {
      props.duration = 0;
    }
    this.props = props;
    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class.
    Similarly, propsStaggers hold the same info only this time for props
    */
    this.attributesStaggers = [];
    this.propsStaggers = [];

    this.setupDynamicValues();

    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */
    this.dynamicDurationValue = null;

    // the passive flag (when true) indicates that the Descriptive Group has been created
    // and passively added to a Clip or a Combo via buildTree method.
    // Defaults to false
    this.passive = false;
  }

  static Incident = MonoIncident;

  static plugin_npm_name = _MC_Attribute;

  static version = version;

  static Channel = AttributeChannel;

  static ClassName = 'Incident';

  static attrsValidationRules = null;

  static propsValidationRules = incidentPropsRule;

  get duration() {
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    }
    if (this.propsStaggers.length > 0) {
      return 'dynamic';
    }
    return super.duration;
  }

  /*
  Overwrites set duration of Leaf in order to support stagger props
  */
  set duration(milliseconds) {
    if (this.propsStaggers.length > 0) {
      for (let i = 0; i < this.propsStaggers.length; i++) {
        if (this.propsStaggers[i].path === 'repeats') {
          continue;
        }
        const newStaggerExpression = this.propsStaggers[i].stagger.resize(
          milliseconds / this.duration,
        );
        assignValueToPath(
          this.props,
          this.propsStaggers[i].path,
          newStaggerExpression,
        );
      }
      this.dynamicDurationValue = milliseconds;
      return;
    }
    super.duration = milliseconds;
  }

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const { parentNode, id } = this;
    // get the position of the Incident within its parent
    const position = parentNode.getLeafPosition(id);
    // first detach the Incident from its parent
    parentNode.removeIncident(id);
    // keep a backup of the current attrs/props
    const oldAttrs = deepCopy(this[type]);
    this[type] = newAttrs;
    const res = parentNode.addIncident(this, position);
    this.resetDuration(true);
    if (!res.result) {
      parentNode.removeIncident(id);
      this[type] = oldAttrs;
      this.resetDuration();
      parentNode.addIncident(this, position);
    }
    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  handleCheckForInvalidSelectors() {
    const selector = this.selector();
    if (selector === null) {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'null selector',
      };
    }
    if (selector.charAt(0) === '&') {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'relative selector with no inherited selector',
        selector,
      };
    }
    return this.bypass();
  }

  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */
  exportDefinition() {
    return {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props,
    };
  }

  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */
  exportLiveDefinition(includeId = true) {
    let propsToReturn = deepCopy(this.props);
    if (!includeId) {
      delete propsToReturn.id;
    }
    return {
      Class: this.constructor,
      attrs: deepCopy(this.attrs),
      props: propsToReturn,
    };
  }
}

export default DescriptiveIncident;
