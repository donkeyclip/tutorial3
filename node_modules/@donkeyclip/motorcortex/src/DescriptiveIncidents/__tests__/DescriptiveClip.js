/* eslint-disable */
import TesterClass from '../../../tester/Tester';
import * as MotorCortex from '../../main';
import { _CantBeResized } from '../../_configuration/rejectionReasons';
import MCDI from '../DescriptiveIncident';
import {
  descriptiveTree as descriptiveTree32,
  lanes as lanes32,
  realTree as realTree32,
} from './states/clean_state';
import { realTree as realTree33 } from './states/combo_state_1';
import {
  descriptiveTree as descriptiveTree10,
  lanes as lanes10,
  realTree as realTree10,
} from './states/dc10';
import {
  descriptiveTree as descriptiveTree11,
  lanes as lanes11,
  realTree as realTree11,
} from './states/dc11';
import {
  descriptiveTree as descriptiveTree12,
  lanes as lanes12,
  realTree as realTree12,
} from './states/dc12';
import {
  descriptiveTree as descriptiveTree13,
  lanes as lanes13,
  realTree as realTree13,
} from './states/dc13';
import {
  descriptiveTree as descriptiveTree14,
  lanes as lanes14,
  realTree as realTree14,
} from './states/dc14';
import {
  descriptiveTree as descriptiveTree15,
  lanes as lanes15,
  realTree as realTree15,
} from './states/dc15';
import {
  descriptiveTree as descriptiveTree16,
  lanes as lanes16,
  realTree as realTree16,
} from './states/dc16';
import {
  descriptiveTree as descriptiveTree17,
  lanes as lanes17,
  realTree as realTree17,
} from './states/dc17';
import {
  descriptiveTree as descriptiveTree18,
  lanes as lanes18,
  realTree as realTree18,
} from './states/dc18';
import {
  descriptiveTree as descriptiveTree19,
  lanes as lanes19,
  realTree as realTree19,
} from './states/dc19';
import {
  descriptiveTree as descriptiveTree1,
  lanes as lanes1,
  realTree as realTree1,
} from './states/dc2';
import {
  descriptiveTree as descriptiveTree20,
  lanes as lanes20,
  realTree as realTree20,
} from './states/dc20';
import {
  descriptiveTree as descriptiveTree21,
  lanes as lanes21,
  realTree as realTree21,
} from './states/dc21';
import {
  descriptiveTree as descriptiveTree22,
  lanes as lanes22,
  realTree as realTree22,
} from './states/dc22';
import {
  descriptiveTree as descriptiveTree23,
  lanes as lanes23,
  realTree as realTree23,
} from './states/dc23';
import {
  descriptiveTree as descriptiveTree24,
  lanes as lanes24,
  realTree as realTree24,
} from './states/dc24';
import {
  descriptiveTree as descriptiveTree25,
  lanes as lanes25,
  realTree as realTree25,
} from './states/dc25';
import {
  descriptiveTree as descriptiveTree26,
  lanes as lanes26,
  realTree as realTree26,
} from './states/dc26';
import {
  descriptiveTree as descriptiveTree27,
  lanes as lanes27,
  realTree as realTree27,
} from './states/dc27';
import {
  descriptiveTree as descriptiveTree28,
  lanes as lanes28,
  realTree as realTree28,
} from './states/dc28';
import {
  descriptiveTree as descriptiveTree29,
  lanes as lanes29,
  realTree as realTree29,
} from './states/dc29';
import {
  descriptiveTree as descriptiveTree3,
  lanes as lanes3,
  realTree as realTree3,
} from './states/dc3';
import {
  descriptiveTree as descriptiveTree30,
  lanes as lanes30,
  realTree as realTree30,
} from './states/dc30';
import {
  descriptiveTree as descriptiveTree31,
  lanes as lanes31,
  realTree as realTree31,
} from './states/dc31';
import {
  descriptiveTree as descriptiveTree4,
  lanes as lanes4,
  realTree as realTree4,
} from './states/dc4';
import {
  descriptiveTree as descriptiveTree5,
  lanes as lanes5,
  realTree as realTree5,
} from './states/dc5';
import {
  descriptiveTree as descriptiveTree7,
  lanes as lanes7,
  realTree as realTree7,
} from './states/dc7';
import {
  descriptiveTree as descriptiveTree8,
  lanes as lanes8,
  realTree as realTree8,
} from './states/dc8';
import {
  descriptiveTree as descriptiveTree9,
  lanes as lanes9,
  realTree as realTree9,
} from './states/dc9';

const DC = MotorCortex.HTMLClip;
const DG = MotorCortex.Group;
const DCb = MotorCortex.Combo;
const loadPlugin = MotorCortex.loadPlugin;

const Tester = new TesterClass();

const dg = new DG({ id: 'test-group-1' });

/** ************************* PLUGIN DEFINITION ************************ */
/** ******************************************************************* */
class MyPluginIncident extends MotorCortex.Effect {
  onGetContext() {}

  onProgress(ms) {
    const fraction = this.getFraction(ms);
    // eslint-disable-line no-unused-vars
    const { initialValue } = this;
    const { targetValue } = this;
    const value = initialValue + (targetValue - initialValue) * fraction;

    this.element.setAttribute(this.attributeKey, value);
  }

  getScratchValue() {
    // eslint-disable-line no-unused-vars
    if (this.attributeKey === 'alpha') {
      return 1;
    }

    return 0;
  }
}

class MyPluginCASI extends MotorCortex.HTMLClip {
  get html() {
    return `<div>
      <div class="a"></div>
    </div>`;
  }

  get css() {
    return `div{width:40px; height:40px;}`;
  }

  buildTree() {
    for (let i = 0; i < this.attrs.number; i++) {
      const myIncident = new MCDI(
        {
          animatedAttrs: {
            test: 200,
          },
        },
        {
          duration: 2000,
          selector: '.a',
        },
      );
      this.addIncident(myIncident, i * 2000);
    }
  }
}

class MyPluginCombo extends MotorCortex.Combo {
  get incidents() {
    return [
      {
        incidentClass: DI,
        attrs: {
          animatedAttrs: {
            alpha: '@expression(index*2)',
          },
        },
        props: {
          duration: this.attrs.duration1000,
          delay: '@expression(index*30)',
        },
        position: '@expression(index*100)',
      },
      {
        incidentClass: DI,
        attrs: {
          animatedAttrs: {
            alpha: 3,
          },
        },
        props: {
          selector: '.stagger',
          duration: 1000,
          delay: '@expression(index*100)',
        },
        position: '@expression(index*500 + 1000)',
      },
    ];
  }
}

/** ************************* PLUGIN LOADING ************************** */
/** ******************************************************************* */
const testPlugin0 = {
  npm_name: '@donkeyclip/test-plugin-0',
  name: 'Test Plugin 0',
  incidents: [
    {
      exportable: MyPluginIncident,
      name: 'MPInc',
      attributesValidationRules: {
        animatedAttrs: {
          optional: false,
          type: 'object',
          props: {
            alpha: {
              type: 'amount',
              optional: true,
            },
          },
        },
      },
    },
    {
      exportable: MyPluginCASI,
      name: 'MPCASI',
    },
    {
      exportable: MyPluginCombo,
      name: 'MPCombo',
    },
  ],
};

const TestPlugin0 = loadPlugin(testPlugin0);
const DI = TestPlugin0.MPInc;
const MPCombo = TestPlugin0.MPCombo;

const myGroup = new DG({ id: 'my-group' });
let myClip;
let clone;
let cfdHost;

test('DC1. creating a real clip', () => {
  document.body.innerHTML = `<div id="clip-container"></div>
        <div id="clip-clone-container"></div>
        <div id="clip-from-definition-container"></div>`;

  cfdHost = document.getElementById('clip-from-definition-container');

  myClip = new DC({
    html: (initParams) =>
      `<div id="my-root-div">
        <div
          id="element-1"
          class="my-class"
          data-motorcortex2-id="my-class-1"
        ></div>
        <div id="element-2" class="my-class" data-motorcortex2-id="my-class-2">
          ${initParams.test}
        </div>
        <div
          class="stagger"
          data-attr="100"
          id="stagger-1"
          data-motorcortex2-id="stagger-1"
        ></div>
        <div
          class="stagger"
          data-attr="200"
          id="stagger-2"
          data-motorcortex2-id="stagger-2"
        ></div>
        <div
          class="stagger"
          data-attr="300"
          id="stagger-3"
          data-motorcortex2-id="stagger-3"
        ></div>
        <div
          class="stagger"
          data-attr="400"
          id="stagger-4"
          data-motorcortex2-id="stagger-4"
        ></div>
        <div
          class="stagger"
          data-attr="500"
          id="stagger-5"
          data-motorcortex2-id="stagger-5"
        ></div>
        <div
          class="stagger"
          data-attr="600"
          id="stagger-6"
          data-motorcortex2-id="stagger-6"
        ></div>
        <div id="casi-container"></div>
      </div>`,
    css: () => `
            #my-root-div {
                width: 800px;
                height: 400px;
            }
            .my-class {
                display: inline-block;
                width: 50%;
                height: 100%;
            }
        `,
    fonts: [
      {
        type: 'google-font',
        src: 'https://fonts.googleapis.com/css?family=Tangerine:bold,bolditalic|Inconsolata:italic|Droid+Sans',
      },
      {
        type: 'google-font',
        src: 'https://wrong.domain.com/css?family=Tangerine:bold,bolditalic|Inconsolata:italic|Droid+Sans',
      },
    ],
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    initParamsValidationRules: {
      test: { type: 'string' },
    },
    initParams: {
      test: '------------------------------',
    },
    containerParams: {
      width: '500px',
      height: '500px',
    },
  });

  clone = myClip.paste(document.getElementById('clip-clone-container'));
  const res = myClip.addIncident(myGroup, 200);

  expect(res).toEqual({
    result: true,
  });
});

const testIncident2 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 2,
      beta: 3,
    },
  },
  {
    selector: '#element-1',
    duration: 2000,
    id: 'test-incident-2',
  },
);

const testIncident3 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 3,
    },
  },
  {
    selector: '#element-1',
    duration: 1000,
    id: 'test-incident-3',
  },
);

const testIncident4 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 3,
    },
  },
  {
    selector: '#element-2',
    duration: 1000,
    id: 'test-incident-4',
  },
);

const testIncident5 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 5,
      beta: 5,
    },
  },
  {
    selector: '.my-class',
    duration: 200,
    delay: 300,
    hiatus: 500,
    id: 'test-incident-5',
  },
);

const testIncident6 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: '@stagger(0, 1000)',
    },
  },
  {
    selector: '.stagger',
    duration: 1000,
    id: 'stagger-attributes-incident',
  },
);

const testIncident7 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 4,
    },
  },
  {
    selector: '.stagger',
    duration: 1000,
    id: 'test-incident-7',
  },
);

const testIncident8 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 6,
    },
  },
  {
    selector: '.stagger',
    duration: 1000,
    id: 'test-incident-8',
  },
);

const testIncident9 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: 7,
    },
  },
  {
    selector: '.stagger',
    duration: '@stagger(1000, 2000)',
    delay: '@stagger(0, 1000)',
    hiatus: '@stagger(0, 50)',
    repeats: '@stagger(1, 6)',
    id: 'test-incident-9',
  },
);

const testIncident10 = new DI(
  {
    attribute: 'value',
    animatedAttrs: {
      alpha: '@attribute(data-attr)',
    },
  },
  {
    selector: '.stagger',
    duration: 500,
    id: 'attribute-value',
  },
);

const combo = new DCb(
  {
    incidents: [
      {
        incidentClass: DI,
        attrs: {
          animatedAttrs: {
            alpha: 4,
          },
        },
        props: {
          duration: 1000,
        },
        position: 0,
      },
      {
        incidentClass: DI,
        attrs: {
          animatedAttrs: {
            alpha: 3,
          },
        },
        props: {
          duration: 1000,
        },
        position: 2000,
      },
    ],
  },
  {
    selector: '.my-class',
    id: 'desc-combo',
  },
);

// PLUGIN DEFINITION
class MyPluginGroup extends MotorCortex.Group {
  buildTree() {
    for (let i = 0; i < this.attrs.number; i++) {
      const di = new DI(
        {
          animatedAttrs: {
            alpha: i % 2 === 0 ? 2 : 0,
          },
        },
        {
          duration: 100,
          id: `${this.id}_${i}`,
        },
      );
      this.addIncident(di, i * 100);
    }
  }
}

const testPlugin = {
  npm_name: '@donkeyclip/test-plugin',
  name: 'Test Plugin',
  incidents: [
    {
      exportable: MyPluginGroup,
      name: 'MyPluginGroup',
    },
  ],
};

const TestPlugin = loadPlugin(testPlugin);

const plugin_dg = new TestPlugin.MyPluginGroup(
  {
    number: 4,
  },
  {
    selector: '#element-1',
    id: 'my-plugin-group',
  },
);
// END OF PLUGIN DEFINITION

test('DC2. add a tree consisting of DescriptiveGroups and DescriptiveIncidents on the real tree of the Clip', () => {
  const di = new DI(
    {
      attribute: 'value',
      animatedAttrs: {
        alpha: 1.1,
        beta: 2.2,
      },
    },
    {
      selector: '.my-class',
      duration: 2000,
      id: 'test-incident-1',
    },
  );

  dg.addIncident(di, 1000);
  const res = myClip.addIncident(dg, 1000);

  const testRes = Tester.testTree(descriptiveTree1, myClip);
  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes1, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree1, myClip.realClip);

  expect(res).toEqual({
    result: true,
  });

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);

  const cfd_testRes = Tester.testTree(descriptiveTree1, ClipFromDefinition);

  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes1,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree1,
    ClipFromDefinition.realClip,
  );

  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC3. add a conflicting tree consisting of DescriptiveGroups and DescriptiveIncidents on the real tree of the Clip', () => {
  const testRes = Tester.testTree(descriptiveTree1, myClip);
  const realTreeTest = Tester.testTree(realTree1, myClip.realClip);

  expect(testRes.length).toEqual(0);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes1, lh.lanes, lh.incidentsById);
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test(`DC3. add a tree consisting of DescriptiveIncidents on the real tree of the Clip
    that will inherit the initial values from the previous Incidents on the lanes`, () => {
  const res = myClip.addIncident(testIncident2, 5000);

  const testRes = Tester.testTree(descriptiveTree3, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes3, lh.lanes, lh.incidentsById);
  // const realTreeTest = Tester.testTree(dc3.realTree, myClip.realClip);

  expect(res).toEqual({
    result: true,
  });

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);

  const cfd_testRes = Tester.testTree(descriptiveTree3, ClipFromDefinition);

  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes3,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree3,
    ClipFromDefinition.realClip,
  );

  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test(`DC4. add a tree consisting of DescriptiveIncidents on the real tree of the Clip
    that will inherit the initial values from the previous Incidents on the lanes and
    affect the initial values of the following`, () => {
  const res = myClip.addIncident(testIncident3, 4000);

  const testRes = Tester.testTree(descriptiveTree4, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes4, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree4, myClip.realClip);
  expect(res).toEqual({
    result: true,
  });

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree4, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes4,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree4,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test(`DC5. add a conflicting Incident on a DescriptiveGroup of the Descriptive Tree that already belongs
to a real tree`, () => {
  const di = new DI(
    {
      attribute: 'value',
      animatedAttrs: {
        alpha: 3,
      },
    },
    {
      selector: '#element-2',
      duration: 1000,
      id: 'test-incident-4',
    },
  );

  const res = dg.addIncident(di, 2000);
  expect(res.result).toEqual(false);

  const testRes = Tester.testTree(descriptiveTree4, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes4, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree4, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test(`DC5.1 edit the duration of an Incident in a way that is conflicting. The edit should be rejected
and the state should remain the same`, () => {
  const res = testIncident3.editProperties({
    selector: '#element-1',
    duration: 2000,
    id: 'test-incident-3',
  });

  expect(res.result).toBe(false);
  expect(res.errors[0].type).toBe(
    'unauthorised, overlapping incidents on the same element',
  );

  const testRes = Tester.testTree(descriptiveTree4, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes4, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree4, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test(`DC6. add a non-conflicting Incident on a DescriptiveGroup of the Descriptive Tree that already belongs
to a real tree`, () => {
  const res = dg.addIncident(testIncident4, 3000);
  expect(res.result).toEqual(true);

  const testRes = Tester.testTree(descriptiveTree5, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes5, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree5, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree5, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes5,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree5,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test(`DC6.1, edit the selector of an Incident in a way that is conflicting. The edit should be rejected
and the state should remain the same`, () => {
  const res = testIncident4.editProperties({
    selector: '#element-1',
    duration: 1000,
    id: 'test-incident-4',
  });

  expect(res.result).toBe(false);
  expect(res.errors[0].type).toBe(
    'unauthorised, overlapping incidents on the same element',
  );

  const testRes = Tester.testTree(descriptiveTree5, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes5, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree5, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC7. edit the position of an Incident', () => {
  const res = dg.moveIncident(testIncident4, 5000);

  expect(res).toEqual({
    result: true,
  });

  const testRes = Tester.testTree(descriptiveTree7, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes7, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree7, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree7, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes7,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree7,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC8. try to make a conflicting edit the position of an Incident', () => {
  const res = dg.moveIncident('test-incident-4', 1000);
  expect(res.result).toBe(false);

  const testRes = Tester.testTree(descriptiveTree7, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes7, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree7, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC8. try to edit the position of an Incident providing a negative', () => {
  const res = dg.moveIncident('test-incident-4', -1);
  expect(res.result).toBe(false);

  const testRes = Tester.testTree(descriptiveTree7, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes7, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree7, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC9. move an Incident by changing its relative position with other Incidents of the lane', () => {
  const res = dg.moveIncident('test-incident-1', 7000);
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree8, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes8, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree8, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree8, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes8,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree8,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC10. remove an Incident from the tree', () => {
  const res = dg.removeIncident(testIncident4);
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree9, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes9, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree9, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree9, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes9,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree9,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC11. remove an Incident that is the first on lane', () => {
  const res = myClip.removeIncident('test-incident-3');
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree10, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes10, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree10, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree10, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes10,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree10,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC12. edit the attributes of an Incident in a way that is accepted', () => {
  const res = testIncident2.editAttributes({
    attribute: 'value',
    animatedAttrs: {
      gamma: 2,
    },
  });
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree11, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes11, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree11, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree11, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes11,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree11,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC13. edit the properties of an Incident in a way that is accepted', () => {
  const res = testIncident2.editProperties({
    selector: '#element-1',
    duration: 6000,
    id: 'test-incident-2',
  });
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree12, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes12, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree12, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree12, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes12,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree12,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test(`DC14. Edit the attributes of a Descriptive Group exposed by a plugin. Expect the
edit not to pass due to conflicts`, () => {
  const res = myClip.addIncident(plugin_dg, 4000);
  expect(res.result).toBe(true);

  let testRes = Tester.testTree(descriptiveTree13, myClip);

  let lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  let lanesTest = Tester.testLanes(lanes13, lh.lanes, lh.incidentsById);
  let realTreeTest = Tester.testTree(realTree13, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const editRes = plugin_dg.editAttributes({ number: 44 });
  expect(editRes.result).toBe(false);

  testRes = Tester.testTree(descriptiveTree13, myClip);

  lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  lanesTest = Tester.testLanes(lanes13, lh.lanes, lh.incidentsById);
  realTreeTest = Tester.testTree(realTree13, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree13, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes13,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree13,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test(`DC15. Edit the attributes of a Descriptive Group exposed by a plugin. Expect the
edit to pass`, () => {
  const res = plugin_dg.editAttributes({ number: 3 });
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree14, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes14, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree14, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree14, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes14,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree14,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC16. Edit an Incident adding to it initial values. The addition should pass', () => {
  const res = testIncident2.editAttributes({
    attribute: 'value',
    animatedAttrs: {
      gamma: 2,
    },
    initialValues: {
      gamma: 3,
    },
  });
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree15, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes15, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree15, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree15, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes15,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree15,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC17. an Incident with delay, hiatus and repeats should have derived duration', () => {
  myClip.moveIncident(myGroup, 0);
  myGroup.addIncident(testIncident5, 0);

  const testRes = Tester.testTree(descriptiveTree16, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes16, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree16, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree16, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes16,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree16,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC18. edit delay on Incident in a non-allowed way', () => {
  const res = testIncident5.editProperties({
    selector: '.my-class',
    duration: 200,
    delay: 3400,
    hiatus: 500,
    id: 'test-incident-5',
  });

  expect(res.result).toBe(false);

  const testRes = Tester.testTree(descriptiveTree16, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes16, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree16, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC19. edit delay on Incident in an allowed way', () => {
  const res = testIncident5.editProperties({
    selector: '.my-class',
    duration: 200,
    delay: 200,
    hiatus: 500,
    id: 'test-incident-5',
  });

  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree17, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes17, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree17, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree17, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes17,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree17,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC20. edit hiatus on Incident (allowed)', () => {
  const res = testIncident5.editProperties({
    selector: '.my-class',
    duration: 200,
    delay: 200,
    hiatus: 400,
    id: 'test-incident-5',
  });

  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree18, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes18, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree18, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree18, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes18,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree18,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC21. edit repeats on Incident (not allowed)', () => {
  const res = testIncident5.editProperties({
    selector: '.my-class',
    duration: 200,
    delay: 200,
    hiatus: 400,
    repeats: 12,
    id: 'test-incident-5',
  });

  expect(res.result).toBe(false);

  const testRes = Tester.testTree(descriptiveTree18, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes18, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree18, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC22. edit repeats on Incident (allowed)', () => {
  const res = testIncident5.editProperties({
    selector: '.my-class',
    duration: 200,
    delay: 200,
    hiatus: 400,
    repeats: 3,
    id: 'test-incident-5',
  });

  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree19, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes19, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree19, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree19, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes19,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree19,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC23. resize Incident with delay, hiatus & repeats (not allowed)', () => {
  const res = testIncident5.resize(4800);

  expect(res.result).toBe(false);

  const testRes = Tester.testTree(descriptiveTree19, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes19, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree19, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC23. resize Incident with delay, hiatus & repeats (allowed)', () => {
  const res = testIncident5.resize(1200);

  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree20, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes20, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree20, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree20, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes20,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree20,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC24. resize a group containing an Incident with delay, hiatus & repeats', () => {
  const res = myGroup.resize(2400);

  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree19, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes19, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree19, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();

  const definition = myClip.exportLiveDefinition();
  definition.props.host = cfdHost;
  const ClipFromDefinition = MotorCortex.utils.clipFromDefinition(definition);
  const cfd_testRes = Tester.testTree(descriptiveTree19, ClipFromDefinition);
  const cfd_lh =
    ClipFromDefinition.realClip.instantiatedChannels[
      '@donkeyclip/test-plugin-0'
    ].LanesHandler;
  const cfd_lanesTest = Tester.testLanes(
    lanes19,
    cfd_lh.lanes,
    cfd_lh.incidentsById,
  );
  const cfd_realTreeTest = Tester.testTree(
    realTree19,
    ClipFromDefinition.realClip,
  );
  expect(cfd_testRes).toHaveNoErros();
  expect(cfd_lanesTest).toHaveNoErros();
  expect(cfd_realTreeTest).toHaveNoErros();
});

test('DC25. Add a CASI exposed by plugin on the Clip and try to edit it', () => {
  const myCASI = new TestPlugin0.MPCASI(
    {
      number: 4,
    },
    { selector: '#casi-container', id: 'mycasi' },
  );

  myClip.addIncident(myCASI, 0);
  expect(myClip.children.mycasi.leaf.duration).toBe(8000);
  expect(myClip.duration).toBe(11000);
  const res = myCASI.editAttributes({ number: 7 });
  expect(res.result).toBe(false);
  const res2 = myCASI.editProperties({ selector: '#second-selector' });
  expect(res2.result).toBe(false);
  const res3 = myClip.removeIncident(myCASI.id);
  expect(res3.result).toBe(true);
});

test('DC26. Clone Clip', () => {
  clone.onProgress(4150 / 11000, 4150);

  const ccopyContext = myClip.realClip.instantiatedCopiesContexts[clone.id];
  expect(
    parseInt(ccopyContext.getElementByMCID('my-class-1').getAttribute('alpha')),
  ).toBe(1);
});

test('DC27. Add an Incident with stagger attribute', () => {
  const res = myClip.addIncident(testIncident6, 2000);
  expect(res.result).toEqual(true);

  const testRes = Tester.testTree(descriptiveTree21, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes21, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree21, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC28. Add an Incident with after a stagger attributes Incident and examine start values', () => {
  const res = myClip.addIncident(testIncident7, 4000);
  expect(res.result).toEqual(true);

  const testRes = Tester.testTree(descriptiveTree22, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes22, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree22, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC29. Remove an Incident that is between a stagger and another Incident. Check initial values of the later', () => {
  const res = myClip.addIncident(testIncident8, 6000);
  expect(res.result).toEqual(true);
  const delRes = myClip.removeIncident(testIncident7);
  expect(delRes.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree23, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes23, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree23, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC30. Resize an Incident with stagger attribute', () => {
  const res = testIncident6.resize(800);
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree24, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes24, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree24, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC31. Add an Incident with stagger props (duration, delay, hiatus, repeats)', () => {
  const res = myClip.addIncident(testIncident9, 8000);
  expect(res.result).toEqual(true);

  const testRes = Tester.testTree(descriptiveTree25, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes25, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree25, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC32. Directly resize an Incident with stagger props', () => {
  const res = testIncident9.resize((6 * 3050) / 2);
  expect(res.result).toBe(true);
  const def = testIncident9.exportDefinition();
  expect(def.props).toEqual({
    selector: '.stagger',
    duration: '@stagger(500, 1000, 0, linear, linear, false)',
    delay: '@stagger(0, 500, 0, linear, linear, false)',
    hiatus: '@stagger(0, 25, 0, linear, linear, false)',
    repeats: '@stagger(1, 6)',
    id: 'test-incident-9',
  });

  const testRes = Tester.testTree(descriptiveTree26, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes26, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree26, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC33. Remove a resized stagger Incident from Clip', () => {
  const res = myClip.removeIncident(testIncident9);
  expect(res.result).toBe(true);
  const def = testIncident9.exportDefinition();
  expect(def.props).toEqual({
    selector: '.stagger',
    duration: '@stagger(500, 1000, 0, linear, linear, false)',
    delay: '@stagger(0, 500, 0, linear, linear, false)',
    hiatus: '@stagger(0, 25, 0, linear, linear, false)',
    repeats: '@stagger(1, 6)',
    id: 'test-incident-9',
  });
  expect(testIncident9.duration).toBe('dynamic');
});

test('DC34. Add a previously resized stagger Incident to a Clip', () => {
  const res = dg.addIncident(testIncident9, 10000);
  expect(res.result).toBe(true);
  const testRes = Tester.testTree(descriptiveTree27, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes27, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree27, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC35. Resize a Group containing a stagger Incident', () => {
  const res = dg.resize(dg.duration * 2);
  expect(res.result).toBe(true);
  const def = testIncident9.exportDefinition();
  expect(def.props).toEqual({
    selector: '.stagger',
    duration: '@stagger(1000, 2000, 0, linear, linear, false)',
    delay: '@stagger(0, 1000, 0, linear, linear, false)',
    hiatus: '@stagger(0, 50, 0, linear, linear, false)',
    repeats: '@stagger(1, 6)',
    id: 'test-incident-9',
  });

  const testRes = Tester.testTree(descriptiveTree28, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes28, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree28, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC36. Add an Incident with @attribute value', () => {
  const res = myClip.addIncident(testIncident10, 0);
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree29, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes29, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree29, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC37. Add a Combo that has conflicts', () => {
  const combo = new DCb(
    {
      incidents: [
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: 4,
            },
          },
          props: {
            duration: 1000,
          },
          position: 0,
        },
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: 3,
            },
          },
          props: {
            duration: 1000,
          },
          position: 2000,
        },
      ],
    },
    {
      selector: '.my-class',
      id: 'desc-combo',
    },
  );

  const res = myClip.addIncident(combo, 0);
  expect(res.result).toBe(false);
  expect(res.errors.length).toBe(4);

  const testRes = Tester.testTree(descriptiveTree29, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes29, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree29, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC38. Add a Combo with no conflicts', () => {
  expect(combo.duration).toBe('dynamic');

  const res = myClip.addIncident(combo, 100000);
  expect(res.result).toBe(true);
  expect(combo.duration).toBe(3000);

  const testRes = Tester.testTree(descriptiveTree30, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes30, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree30, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC39. Move a Combo with no conflicts', () => {
  const res = myClip.moveIncident('desc-combo', 100001);
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree31, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes31, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree31, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC40. Try to add a Combo having conflicting incidents itself', () => {
  const tmpClip = new DC({
    html: (initParams) =>
      `<div id="my-root-div">
        <div class="target"></div>
        <div class="target"></div>
      </div>`,
    css: () => ``,
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    initParams: {
      test: '------------------------------',
    },
    containerParams: {
      width: '500px',
      height: '500px',
    },
  });

  const combo = new DCb(
    {
      incidents: [
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: 4,
            },
          },
          props: {
            duration: 1000,
          },
          position: 0,
        },
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: 3,
            },
          },
          props: {
            duration: 1000,
          },
          position: 500,
        },
      ],
    },
    {
      selector: '.target',
      id: 'desc-combo-failing',
    },
  );

  const res = tmpClip.addIncident(combo, 0);
  expect(res.result).toBe(false);
  expect(res.errors.length).toBe(2);

  const testRes = Tester.testTree(descriptiveTree32, tmpClip);

  const lh =
    tmpClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes32, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree32, tmpClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC41. Remove a Combo with no conflicts', () => {
  const res = myClip.removeIncident('desc-combo');
  expect(res.result).toBe(true);

  const testRes = Tester.testTree(descriptiveTree29, myClip);

  const lh =
    myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0']
      .LanesHandler;
  const lanesTest = Tester.testLanes(lanes29, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree29, myClip.realClip);

  expect(testRes).toHaveNoErros();
  expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
  expect(combo.duration).toBe('dynamic');
});

test('DC42. Test own & nested staggers, as well on Combo within Combo, on a Combos', () => {
  document.body.innerHTML = `<div id="clip-container"></div>
        <div id="clip-clone-container"></div>`;

  const comboClip = new DC({
    html: (initParams) =>
      `<div id="my-root-div">
        <div class="combo-target" data-motorcortex2-id="combo-target-1">
          <div
            class="stagger"
            data-attr="100"
            id="stagger-1-1"
            data-motorcortex2-id="stagger-1-1"
          ></div>
          <div
            class="stagger"
            data-attr="200"
            id="stagger-1-2"
            data-motorcortex2-id="stagger-1-2"
          ></div>
          <div
            class="inner-combo-target"
            id="inner-combo-target-1"
            id="inner-combo-target-1"
            data-motorcortex2-id="inner-combo-target-1"
          >
            <div
              class="inner-combo-content"
              id="inner-combo-content-1"
              data-motorcortex2-id="inner-combo-content-1"
            ></div>
          </div>
        </div>
        <div class="combo-target" data-motorcortex2-id="combo-target-2">
          <div
            class="stagger"
            data-attr="100"
            id="stagger-2-1"
            data-motorcortex2-id="stagger-2-1"
          ></div>
          <div
            class="stagger"
            data-attr="200"
            id="stagger-2-2"
            data-motorcortex2-id="stagger-2-2"
          ></div>
          <div
            class="inner-combo-target"
            id="inner-combo-target-2"
            id="inner-combo-target-2"
            data-motorcortex2-id="inner-combo-target-2"
          >
            <div
              class="inner-combo-content"
              id="inner-combo-content-2"
              data-motorcortex2-id="inner-combo-content-2"
            ></div>
          </div>
        </div>
      </div>`,
    css: () => `
      .combo-target {
          width: 800px;
          height: 400px;
      }
      .my-class {
          display: inline-block;
          width: 50%;
          height: 100%;
      }
  `,
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    initParams: {
      test: '------------------------------',
    },
    containerParams: {
      width: '500px',
      height: '500px',
    },
  });

  const bombo = new DCb(
    {
      incidents: [
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: '@expression(index*2)',
            },
          },
          props: {
            duration: 1000,
            delay: '@expression(index*30)',
          },
          position: '@expression(index*100)',
        },
        {
          incidentClass: DI,
          attrs: {
            animatedAttrs: {
              alpha: 3,
            },
          },
          props: {
            selector: '.stagger',
            duration: 1000,
            delay: '@expression(index*100)',
          },
          position: '@expression(index*500 + 1000)',
        },
      ],
    },
    {
      selector: '.combo-target',
      id: 'desc-combo',
      repeats: 2,
      delay: '@expression(index*200+100)',
      hiatus: 100,
    },
  );

  const res = comboClip.addIncident(bombo, 1000);
  expect(res.result).toBe(true);

  // const testRes = Tester.testTree(descriptiveTree32, myClip);

  // const lh = myClip.realClip.instantiatedChannels['@donkeyclip/test-plugin-0'].LanesHandler;
  // const lanesTest = Tester.testLanes(lanes32, lh.lanes, lh.incidentsById);
  const realTreeTest = Tester.testTree(realTree33, comboClip.realClip);

  // expect(testRes).toHaveNoErros();
  // expect(lanesTest).toHaveNoErros();
  expect(realTreeTest).toHaveNoErros();
});

test('DC43. Test plugin Combos', () => {
  document.body.innerHTML = `<div id="clip-container"></div>
        <div id="clip-clone-container"></div>`;

  const comboClip = new DC({
    html: (initParams) =>
      `<div id="my-root-div">
        <div class="combo-target" data-motorcortex2-id="combo-target-1">
          <div
            class="stagger"
            data-attr="100"
            id="stagger-1-1"
            data-motorcortex2-id="stagger-1-1"
          ></div>
          <div
            class="stagger"
            data-attr="200"
            id="stagger-1-2"
            data-motorcortex2-id="stagger-1-2"
          ></div>
          <div
            class="inner-combo-target"
            id="inner-combo-target-1"
            id="inner-combo-target-1"
            data-motorcortex2-id="inner-combo-target-1"
          >
            <div
              class="inner-combo-content"
              id="inner-combo-content-1"
              data-motorcortex2-id="inner-combo-content-1"
            ></div>
          </div>
        </div>
        <div class="combo-target" data-motorcortex2-id="combo-target-2">
          <div
            class="stagger"
            data-attr="100"
            id="stagger-2-1"
            data-motorcortex2-id="stagger-2-1"
          ></div>
          <div
            class="stagger"
            data-attr="200"
            id="stagger-2-2"
            data-motorcortex2-id="stagger-2-2"
          ></div>
          <div
            class="inner-combo-target"
            id="inner-combo-target-2"
            id="inner-combo-target-2"
            data-motorcortex2-id="inner-combo-target-2"
          >
            <div
              class="inner-combo-content"
              id="inner-combo-content-2"
              data-motorcortex2-id="inner-combo-content-2"
            ></div>
          </div>
        </div>
      </div>`,
    css: () => `
      .combo-target {
          width: 800px;
          height: 400px;
      }
      .my-class {
          display: inline-block;
          width: 50%;
          height: 100%;
      }
  `,
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    initParams: {
      test: '------------------------------',
    },
    containerParams: {
      width: '500px',
      height: '500px',
    },
  });

  const bombo = new MPCombo(
    {
      duration1000: 1000,
    },
    {
      selector: '.combo-target',
      id: 'desc-combo',
      repeats: 2,
      delay: '@expression(index*200+100)',
      hiatus: 100,
    },
  );

  const res = comboClip.addIncident(bombo, 1000);
  expect(res.result).toBe(true);

  const realTreeTest = Tester.testTree(realTree33, comboClip.realClip);

  expect(realTreeTest).toHaveNoErros();
});

//*************************** DYNAMIC PROPS **********************************  //
test('DC44. An Animation with dynamic duration should return "dynamic" on .duration', () => {
  const di1 = new MyPluginCASI({
    duration: '@stagger(100, 300)',
    selector: '.test',
  });
  const di2 = new MyPluginCASI({
    delay: '@stagger(100, 300)',
    selector: '.test',
  });
  const di3 = new MyPluginCASI({
    hiatus: '@stagger(100, 300)',
    selector: '.test',
  });
  expect(di1.duration).toBe('dynamic');
  expect(di2.duration).toBe('dynamic');
  expect(di3.duration).toBe('dynamic');
});

test('DC45. An Animation with dynamic duration can not be resized', () => {
  const di = new MyPluginCASI({
    duration: '@stagger(100, 300)',
    selector: '.test',
  });

  const res = di.resize(1000);
  expect(res.result).toBe(false);
  expect(res.reason).toBe(_CantBeResized);
});

test(`DC46. An Animation can take hiatus, delay, repeats and duration and
  it should export them on exportDefinition and exportLiveDefinition`, () => {
  const myAnime = new MyPluginCASI({
    selector: '.a-selector',
    duration: 1000,
    repeats: 3,
    delay: 300,
    hiatus: 400,
  });

  const def = myAnime.exportDefinition();
  const liveDef = myAnime.exportLiveDefinition();
  expect(def.props).toEqual({
    selector: '.a-selector',
    duration: 1000,
    repeats: 3,
    delay: 300,
    hiatus: 400,
  });
  expect(liveDef.props).toEqual({
    selector: '.a-selector',
    duration: 1000,
    repeats: 3,
    delay: 300,
    hiatus: 400,
  });
});

test(`DC 47. NonBlockingErrorClip test`, () => {
  document.body.innerHTML = `<div id="clip-container"></div>
        <div id="clip-clone-container"></div>
        <div id="clip-from-definition-container"></div>`;

  cfdHost = document.getElementById('clip-from-definition-container');

  myClip = new DC({
    html: (initParams) => `<div id="my-root-div"></div>`,
    css: () => `
      #my-root-div {
          width: 800px;
          height: 400px;
      }
    `,
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    initParams: { id: 2, name: 'Adam' },
    initParamsValidationRules: {
      id: { type: 'number', positive: true, integer: true },
      name: { type: 'string', min: 3, max: 255 },
      status: 'boolean', // short-hand def
    },
    containerParams: {
      width: '500px',
      height: '500px',
    },
  });

  expect(myClip.nonBlockingErrorClip).toBe(true);
  expect(myClip.errors).toEqual([
    {
      type: 'required',
      message: "The 'status' field is required.",
      field: 'status',
      actual: undefined,
    },
  ]);

  const di = new DI(
    {
      attribute: 'value',
      animatedAttrs: {
        alpha: 2,
        beta: 3,
      },
    },
    {
      selector: '#element-1',
      duration: 2000,
      id: 'test-incident-2',
    },
  );

  const res = myClip.addIncident(di, 0);
  expect(res).toEqual({ result: true });
});

test(`DC 48. volumeChange pubsub`, () => {
  document.body.innerHTML = `<div id="clip-container"></div>`;

  const vclip = new DC({
    html: (initParams) => `<div id="my-root-div"></div>`,
    css: () => `
      #my-root-div {
          width: 800px;
          height: 400px;
      }
    `,
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    containerParams: {
      width: '500px',
      height: '500px',
    },
    audio: 'on',
  });

  const changes = [];
  function callback(vol) {
    changes.push(vol);
  }

  expect(vclip.volumeChangeSubscribe('test', callback)).toBe(1);
  vclip.setVolume(0.1);
  vclip.setVolume(0.2);
  expect(changes).toEqual([0.1, 0.2]);

  vclip.volumeChangeUnsubscribe('test');
  vclip.setVolume(0.3);
  expect(changes).toEqual([0.1, 0.2]);
});
