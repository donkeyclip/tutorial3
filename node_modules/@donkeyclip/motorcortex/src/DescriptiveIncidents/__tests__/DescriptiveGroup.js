import { _CantBeResized } from '../../_configuration/rejectionReasons';
import DG from '../DescriptiveGroup';
import DI from '../DescriptiveIncident';

const dg = new DG(
  {
    a: 'a',
    b: 'b',
  },
  {
    c: 'c',
    d: 'd',
  },
);

const dg2 = new DG({
  c2: 'c',
  d2: 'd',
});

const l1 = new DI({ la: 1.1 }, { lp: 1.1, duration: 1 });
const l2 = new DI({ la: 2.1 }, { lp: 2.1, duration: 1 });

/** ******************** EDITING OWN ATTRIBUTES & PROPERTIES ******************* */
test('DG1. editing attributes on an unassigned DG should pass', () => {
  const res = dg.editAttributes({ a: 'a1', b: 'b1' });
  expect(res).toEqual({
    result: true,
  });

  expect(dg.attrs).toEqual({
    a: 'a1',
    b: 'b1',
  });
});

test('DG2. editing properties on an unassigned DG should pass', () => {
  const res = dg.editProperties({ c: 'c1', d: 'd1' });
  expect(res).toEqual({
    result: true,
  });

  expect(dg.props).toEqual({
    c: 'c1',
    d: 'd1',
  });
});

/** ******************** INITIALISING ONLY WITH PROPERTIES ****************** */
test('DG3. expect the attributes object to be empty and the properties to be the passed for DG initialised only with props', () => {
  expect(dg2.attrs).toEqual({});
  expect(dg2.props).toEqual({
    c2: 'c',
    d2: 'd',
  });
});

/** ********************* CHECK THE ROLE OF THE DG AS THE DECISION AUTHORITY ON A HEADLESS TREE ************** */
test('DG4. check that a headless tree identifies as its decision authority its root DG and that it always allows addIncident on its children groups', () => {
  dg2.addIncident(l1, 100);
  dg.addIncident(dg2, 0);
  const res = dg2.addIncident(l2, 200);
  expect(res).toEqual({ result: true });
});

test('DG5. check that a headless tree identifies as its decision authority its root DG and that it always allows editProperties on its children', () => {
  const res = l2.editProperties({ lp: 1.2, duration: 1 });
  expect(res).toEqual({ result: true });
  expect(l2.props).toEqual({
    lp: 1.2,
    duration: 1,
  });
});

test('DG6. check that a headless tree identifies as its decision authority its root DG and that it always allows editAttributes on its children', () => {
  dg2.addIncident(l1, 100);
  dg2.addIncident(l2, 200);
  dg.addIncident(dg2, 0);
  const res = l2.editAttributes({ la: 1.2 });
  expect(res).toEqual({ result: true });
  expect(l2.attrs).toEqual({
    la: 1.2,
  });
});

test('DG7. check that a headless tree identifies as its decision authority its root DG and that it always allows moveIncident requests', () => {
  const res = dg2.moveIncident(l1.id, 350);
  expect(res).toEqual({ result: true });
  expect(dg2.children[l1.id]).toEqual({
    id: l1.id,
    leaf: l1,
    position: 350,
  });
});

test('DG8. check that a headless tree identifies as its decision authority its root DG and that it always allows removeIncident requests', () => {
  const res = dg2.removeIncident(l1.id);
  expect(res).toEqual({ result: true });
});

test('DG9. check editing DG name', () => {
  dg2.name = 'test';
  expect(dg2.name).toBe('test');
});

test('DG10. A DI with dynamic duration get added to a Group. Duration of Group should become "dynamic"', () => {
  const di = new DI(
    {
      a: 1,
    },
    {
      duration: '@stagger(100, 1000)',
      id: 'di',
    },
  );

  const dg4 = new DG();
  const dg3 = new DG();

  dg4.addIncident(dg3, 1000);
  expect(dg4.duration).toBe(1000);

  dg3.addIncident(di, 1000);
  expect(di.duration).toBe('dynamic');
  expect(dg3.duration).toBe('dynamic');
  expect(dg4.duration).toBe('dynamic');
});

test('DI11. A DG with dynamic duration can not be resized', () => {
  const di = new DI(
    {
      a: 1,
    },
    {
      duration: '@stagger(100, 1000)',
    },
  );

  const dg4 = new DG();
  const dg3 = new DG();

  dg4.addIncident(dg3, 1000);

  dg3.addIncident(di, 1000);

  const res = dg3.resize(1000);
  expect(res.result).toBe(false);
  expect(res.reason).toBe(_CantBeResized);

  const res2 = dg4.resize(1000);
  expect(res2.result).toBe(false);
  expect(res2.reason).toBe(_CantBeResized);
});

test(`DC12. Resize a Group belonging to another Group and containing an Incident. Check durations`, () => {
  const di = new DI(
    {
      animatedAttrs: { a: 12 },
    },
    {
      selector: '.a-selector',
      duration: 2000,
    },
  );

  const dgRoot = new DG();
  const dgTest = new DG();
  dgRoot.addIncident(dgTest, 2000);
  dgTest.addIncident(di, 0);
  expect(dgRoot.duration).toBe(4000);
  expect(dgTest.duration).toBe(2000);
  dgTest.resize(1000);
  expect(dgTest.duration).toBe(1000);
  expect(di.duration).toBe(1000);
  expect(dgRoot.duration).toBe(3000);
});
