/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import DescriptiveGroup from './DescriptiveGroup';
import { _DIRECTIONS } from '../TimedTree/_CONST';
import { roundNumberTo, hasOwnProp } from '../_coreUtils/helper';

class Playable extends DescriptiveGroup {
  constructor(attrs, props) {
    super(attrs, props);
    this.runTimeInfo = {
      currentMillisecond: 0,
      state: 'idle', // supported states: idle, playing, paused, blocked, armed
    };

    /**
          @member {object} - listeners are functions to be executed on time change of the Clip.
          It has the following format:
         listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */
    this.listeners = {};

    // previousTimeStamp is a property holding the last timestamp that the
    // requestAnimationFrame ran
    this.previousTimeStamp = -1;

    this.speed = 1;
  }

  /** ********************* execution methods  *********************
   *************************************************************** */
  /**
   *
   * @param {string} newState: the new state
   * @param {object} options: an optional options object that might provide extra info for the status change
   * @private
   */
  _setState(newState, options = {}) {
    if (newState !== this.runTimeInfo.state) {
      this.runTimeInfo.state = newState;
      // the only timer and the only responsible for Clip execution is the Clip
      // All Incidents contained on a Clip are been executed by the Clip itself via its channels.
      // Thus, the only Incidents that need to know about the state of the root Clip
      // at any time are only the Clips
      this.putMessageOnPipe('setState', { newState, options }, 'Clips', {
        selfExecute: false,
        direction: _DIRECTIONS._DOWN,
      });
      for (const key in this.listeners) {
        const listener = this.listeners[key];
        listener.funct(this.runTimeInfo.currentMillisecond, newState, options);
      }
    }
  }

  handleSetState(target, payload) {
    this._setState(payload.newState, payload.options || {});
  }

  // execution methods
  play(debug = false) {
    if (
      this.runTimeInfo.state === 'idle' ||
      this.runTimeInfo.state === 'paused' ||
      this.runTimeInfo.state === 'armed' ||
      this.runTimeInfo.state === 'transitional' ||
      this.runTimeInfo.state === 'blocked'
    ) {
      if (this.runTimeInfo.state === 'paused') {
        const delta = new Date().getTime() - this.pauseMoment;
        this.previousTimeStamp += delta;
      }

      this._setState('playing');
      this.onPlay();
      if (!debug) {
        window.requestAnimationFrame((timestamp) => {
          this.step(timestamp);
        });
      }
    }
  }

  pause() {
    if (this.runTimeInfo.state === 'playing') {
      this._setState('paused');
      this.pauseMoment = new Date().getTime();
      this.onWait();
    }
  }

  /* armed state means the Clip is on paused state after transition */
  arm() {
    if (
      this.runTimeInfo.state === 'transitional' ||
      this.runTimeInfo.state === 'blocked'
    ) {
      this._setState('armed');
    }
  }

  complete() {
    this._setState('idle');
    this.previousTimeStamp = -1;
  }

  /* in order to start a journey via the TimeCapsule the Playable needs first to stop */
  stop() {
    this._setState('transitional');
    this.previousTimeStamp = -1;
  }

  /**
   *
   * @param {object} options: An optional options object for the block.
   * Currently it supports the key "except" which can hold the id of an Incident that we want to exclude from the block
   */
  block(options = {}) {
    /*
    incidents that have exceptional blocks can't apply a block on the Clip if the Clip is not
    on the playing state
     */
    if (
      hasOwnProp(options, 'exception') &&
      this.runTimeInfo.state !== 'playing'
    ) {
      return;
    }
    this._setState('blocked', options);
    this.previousTimeStamp = -1;
  }

  onPlay() {}

  onWait() {}

  playableProgress(fraction, millisecond) {
    if (this.isTheRootClip) {
      for (const key in this.listeners) {
        const listner = this.listeners[key];
        // if the listener is only for state change continue
        if (listner.onlyOnStateChange === true) {
          continue;
        }
        if (
          Math.abs(
            millisecond +
              listner.cavaDelta -
              this.runTimeInfo.currentMillisecond,
          ) > listner.threshold
        ) {
          listner.funct(
            roundNumberTo(millisecond, listner.roundTo),
            this.runTimeInfo.state,
          );
          listner.cavaDelta = 0;
        } else {
          listner.cavaDelta += Math.abs(
            millisecond - this.runTimeInfo.currentMillisecond,
          );
        }
      }
      this.onProgress(fraction, millisecond);

      this.runTimeInfo.currentMillisecond = millisecond;
      return true;
    }
    return false;
  }

  set executionSpeed(speed) {
    if (!this.isTheRootClip) {
      return;
    }
    this.speed = parseFloat(speed);
  }

  // *******************************************************
  // STEP FUNCTION
  step(timestamp, debug = false) {
    if (this.runTimeInfo.state !== 'playing') {
      return;
    }

    const that = this;
    if (this.previousTimeStamp === -1) {
      this.previousTimeStamp = timestamp;
    }

    // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
    const progress = {
      milliseconds: Math.round(
        this.runTimeInfo.currentMillisecond +
          (timestamp - this.previousTimeStamp) * this.speed,
      ),
      fraction:
        (this.runTimeInfo.currentMillisecond +
          (timestamp - this.previousTimeStamp) * this.speed) /
        this.duration,
    };

    if (progress.fraction >= 1) {
      this.playableProgress(1, this.duration);
      this.complete();
      return;
    }
    if (progress.fraction < 0) {
      this.playableProgress(0, 0);
      this.complete();
      // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
      return;
    }

    this.playableProgress(progress.fraction, progress.milliseconds);

    this.previousTimeStamp = timestamp;

    if (!debug) {
      window.requestAnimationFrame(that.step.bind(that));
    }
  }

  // ************ PUB SUB ********************
  // *****************************************
  /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cycle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */
  subscribe(id, funct, threshold, roundTo, onlyOnStateChange = false) {
    if (!threshold) {
      threshold = 0;
    }
    if (!roundTo) {
      roundTo = 1; // round second to its units, meaning leave it as it is
    }
    this.listeners[id] = {
      funct,
      threshold,
      roundTo,
      cavaDelta: 0,
      onlyOnStateChange,
    };
  }

  unsubscribe(id) {
    if (hasOwnProp(this.listeners, id)) {
      delete this.listeners[id];
    }
  }

  subscribeToDurationChange(funct) {
    if (this.isTheRootClip) {
      this.realClip.subscribeToDurationChange(funct);
      return true;
    }
    return false;
  }
}

export default Playable;
