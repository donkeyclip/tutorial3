/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Channel from '../Channels/Channel';
import Group from '../RealIncidents/Group';
import Leaf from '../TimedTree/Leaf';
import Node from '../TimedTree/Node';
import { _DIRECTIONS } from '../TimedTree/_CONST';
import version from '../version';
import { groupPropsRule } from '../_configuration/propsValidationRules';
import { _MC_Plugin_Name } from '../_configuration/_CONST';
import helper, {
  deepCopy,
  isObject,
  validateProps,
} from '../_coreUtils/helper';
import { _TARGETTYPES } from './_CONST';

class DescriptiveGroup extends Node {
  static Incident = Group;

  static plugin_npm_name = _MC_Plugin_Name;

  static version = version;

  static Channel = Channel;

  static ClassName = 'Group';

  static isGroup = true;

  static attrsValidationRules = null;

  static propsValidationRules = groupPropsRule;

  constructor(attrs = {}, props = null) {
    if (props === null) {
      super(attrs);
      this.attrs = {};
      this.props = attrs;
    } else {
      super(props);
      this.attrs = attrs;
      this.props = props;
    }

    const propsValidation = validateProps(
      this.props,
      groupPropsRule,
      this.constructor,
    );
    if (!propsValidation.result) {
      return propsValidation;
    }

    this._inheritedSelector = null;

    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class
    Similarly, propsStaggers hold the same info only this time for props
    */
    this.attributesStaggers = [];
    this.propsStaggers = [];

    this.setupDynamicValues();

    // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)
    this.passiveAddition = true;
    this._buildTree();
    this.passiveAddition = false;
  }

  _buildTree() {
    this.buildTree();
  }

  /*
  Overwrites _calculateDuration of Node so it handles dynamic durations
  @param {boolean} forceGroups: if is set to true all Groups must recalc their
    duration, no matter if they have other Groups on their tree that also have
    duration = "dynamic"
  */
  _calculateDuration(forceGroups = false) {
    let duration = 0;
    for (const childKey in this.children) {
      const child = this.children[childKey];
      if (forceGroups === true && child.leaf.constructor.isGroup === true) {
        child.leaf._calculateDuration(true);
      }

      if (child.leaf.duration === 'dynamic') {
        duration = 'dynamic';
        break;
      }
      if (child.position + child.leaf.duration > duration) {
        duration = child.position + child.leaf.duration;
      }
    }

    if (duration === this.calculatedDuration) {
      return false;
    }

    this.calculatedDuration = duration;

    // this method is inherited from Node
    this.resetDuration();

    return true;
  }

  _rebuildTree() {
    // remove all direct passive incidents as they might be dependent on the edited attrs/props
    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        this.removeIncident(theChild.id);
      }
    }
    // run buildTree again
    this.passiveAddition = true;
    this.buildTree();
    this.passiveAddition = false;
  }

  buildTree() {}

  get duration() {
    if (this.calculatedDuration === 'dynamic') {
      return this.calculatedDuration;
    }
    return super.duration;
  }

  set duration(milliseconds) {
    super.duration = milliseconds;
  }

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const { parentNode } = this;
    // get the position of the Incident within its parent
    const position = parentNode.getLeafPosition(this.id);
    // keep a backup of the current attrs / props
    const oldAttrs = deepCopy(this[type]);
    this[type] = newAttrs;
    // first detach the Incident from its parent
    parentNode.removeIncident(this.id);
    // remove all direct passive incidents as they might be dependent on the edited attrs/props
    this._rebuildTree();
    // try to add the altered Group
    const res = parentNode.addIncident(this, position);

    if (!res.result) {
      this[type] = oldAttrs;
      this._rebuildTree();
      parentNode.addIncident(this, position);
    }
    // this method is inherited from Node
    this.resetDuration();
    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  get inheritedSelector() {
    return this._inheritedSelector;
  }

  set inheritedSelector(value) {
    this._inheritedSelector = value;
    for (const id in this.children) {
      const theChild = this.children[id].leaf;
      theChild.inheritedSelector = this.selector();
    }
  }

  get selectorToPassToChildren() {
    return this.selector();
  }

  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */
  exportDefinition() {
    const toReturn = {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props,
      incidents: {},
      duration: this.duration,
    };

    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        continue;
      }
      toReturn.incidents[id] = {
        id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportDefinition(),
      };
    }

    return toReturn;
  }

  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */
  exportLiveDefinition(includeId = true) {
    let propsToReturn = deepCopy(this.props);
    if (!includeId) {
      delete propsToReturn.id;
    }
    const toReturn = {
      Class: this.constructor,
      attrs: deepCopy(this.attrs),
      props: propsToReturn,
      incidents: {},
    };

    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        continue;
      }
      toReturn.incidents[id] = {
        // id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportLiveDefinition(includeId),
      };
    }

    return toReturn;
  }

  addIncident(descriptiveIncident, position, options = { check: true }) {
    if (!(descriptiveIncident instanceof Leaf)) {
      helper.warning('addIncident rejected, invalid incident provided');
      return {
        result: false,
        errors: 'Invalid Incident provided',
      };
    }
    descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;
    let checkIfBelongsToClip;
    if (options.check === true) {
      const initialCheck = super.checkAddition(descriptiveIncident, position);
      if (!initialCheck.result) {
        descriptiveIncident.inheritedSelector = null;
        return initialCheck;
      }

      /* Check for null or relative selector Incidents with no inherited selector */
      checkIfBelongsToClip = this.putMessageOnPipe(
        'checkForClip',
        {},
        _TARGETTYPES._DECISIONAUTHORITY,
        {
          selfExecute: true,
          direction: _DIRECTIONS._UP,
        },
      );
      if (checkIfBelongsToClip.response === true) {
        // if the Group belongs on a Clip
        const selectorsCheck = descriptiveIncident.putMessageOnPipe(
          'checkForInvalidSelectors',
          {},
          null,
          {
            selfExecute: true,
            direction: _DIRECTIONS._DOWN,
          },
        );
        if (selectorsCheck.length > 0) {
          const errors = [];
          for (let i = 0; i < selectorsCheck.length; i++) {
            errors.push(selectorsCheck[i].response);
          }
          return {
            result: false,
            errors,
          };
        }
      }

      // sends the check request to its root, either a headless root or a Descriptive Clip
      const mcCheck = this.putMessageOnPipe(
        'checkAddition',
        {
          incident: descriptiveIncident,
          millisecond: position,
          parentGroupId: this.id,
        },
        _TARGETTYPES._DECISIONAUTHORITY,
        { selfExecute: true, direction: _DIRECTIONS._UP },
      );
      if (!mcCheck.response.result) {
        helper.error({
          message: 'addIncident rejected',
          incident: {
            attrs: descriptiveIncident.attrs,
            props: descriptiveIncident.props,
          },
          position,
          conflicts: mcCheck.response.errors,
        });
        descriptiveIncident.inheritedSelector = null;
        return mcCheck.response;
      }
    }

    // if the passiveAddition flag is true we set the passive flag of the Incident
    // to true before adding it to our Group
    if (this.passiveAddition === true) {
      descriptiveIncident.passive = true;
    }

    const res = this.addChild(descriptiveIncident, position);
    if (!res.result) {
      descriptiveIncident.inheritedSelector = null;
    }

    // if it has dynamic duration but now it belongs to a Clip all Groups should
    // dynamically recal their duration
    if (descriptiveIncident.duration === 'dynamic' && checkIfBelongsToClip) {
      this._calculateDuration(true);
    }

    return res;
  }

  /**
   * @param input - can either be object or id
   * */
  moveIncident(input, position) {
    let id = input;
    if (isObject(input)) {
      id = input.id;
    }

    const initialCheck = super.checkEditPosition(id, position);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const originalPosition = this.getLeafPosition(id);
    const positionDelta = position - originalPosition;
    if (positionDelta === 0) {
      return { result: true };
    }

    const mcCheck = this.putMessageOnPipe(
      'checkMove',
      {
        id,
        millisecond: position,
        positionDelta,
        parentGroupId: this.id,
      },
      _TARGETTYPES._DECISIONAUTHORITY,
      { selfExecute: true, direction: _DIRECTIONS._UP },
    );
    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    return this.editPosition(id, position);
  }

  removeIncident(input) {
    let id = input;
    if (isObject(input)) {
      id = input.id;
    }

    const initialCheck = super.checkRemoveChild(id);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const mcCheck = this.putMessageOnPipe(
      'checkDeletion',
      { id, parentGroupId: this.id },
      _TARGETTYPES._DECISIONAUTHORITY,
      { selfExecute: true, direction: _DIRECTIONS._UP },
    );
    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    return this.removeChild(id);
  }

  /** ************************* HANDLING METHODS ****************************** */
  // eslint-disable-next-line no-unused-vars
  handleCheckForClip(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }
    return false;
  }

  // eslint-disable-next-line no-unused-vars
  handleCheckAddition(target, payload) {
    /*
        The DescriptiveGroup handles the checkAddition command which has the UP
        direction. If the DG has a parent it forwards the command to it. If not
        it just returns true, as it is a deadless tree
        */
    if (this.hasParent) {
      return this.bypass();
    }
    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions
  handleCheckMove(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions
  handleCheckDeletion(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions
  handleCheckResize(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars
  handleSetDurationDynamic(target, payload) {
    this.calculatedDuration = 'dynamic';
    this.putMessageOnPipe('setDurationDynamic', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    });
  }
}

export default DescriptiveGroup;
