/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { comboPropsRule } from '../_configuration/propsValidationRules';
import validator from '../_coreUtils/customValidator';
import helper, {
  alwaysReturnFalse,
  deepCopy,
  validateProps,
} from '../_coreUtils/helper';
import DescriptiveGroup from './DescriptiveGroup';

const comboAttrsBasicRule = {
  incidents: {
    type: 'array',
    items: {
      type: 'object',
      props: {
        position: {
          type: 'amount',
          integer: true,
          min: 0,
          optional: false,
        },
        attrs: {
          type: 'object',
          optional: false,
        },
        props: {
          type: 'object',
          optional: false,
        },
        incidentClass: {
          type: 'any',
          optional: false,
        },
      },
    },
  },
};

const comboAttrsBasicRuleMethod = validator.compile(comboAttrsBasicRule);

const incidentChangeError =
  "Combos don't allow external addition or manipulation to their Incidents";

function handleInvalidIncidentChange() {
  helper.error(incidentChangeError);
  return {
    result: false,
    errors: [incidentChangeError],
  };
}

class DescriptiveCombo extends DescriptiveGroup {
  constructor(attrs, props) {
    super(attrs, props);

    if (this.incidents !== null) {
      // it happens on Combos exposed by plugins (see getter)
      this.attrs.incidents = this.incidents; // we overwrite our incidents in case of a plugin Combo
      // we re-calculate attributes and properties staggers as we've changed the
      // original attrs
      this.attributesStaggers = [];
      this.propsStaggers = [];

      this.setupDynamicValues();
    }

    const propsValidation = validateProps(
      this.props,
      comboPropsRule,
      this.constructor,
    );
    if (!propsValidation.result) {
      return propsValidation;
    }

    // attributes validation
    const valRes = comboAttrsBasicRuleMethod(this.attrs);
    if (valRes.length > 0) {
      helper.error('The provided attributes for Combo Incident are invalid');
      return {
        result: false,
        errors: valRes,
      };
    }
    let errors = [];
    for (let i = 0; i < this.attrs.length; i++) {
      const item = this.attrs[i];

      if (item.incidentClass.attrsValidationRules !== null) {
        const attrValRes = item.incidentClass.attrsValidationMethod(item.attrs);
        if (attrValRes.length > 0) {
          errors = errors.concat(attrValRes.errors);
        }
      }

      const propValRes = validateProps(
        item.props,
        item.incidentClass.propsValidationRules,
        item.incidentClass,
      );
      if (!propValRes.result) {
        errors = errors.concat(propValRes.errors);
      }
    }
    if (errors.length > 0) {
      return {
        result: false,
        errors,
      };
    }

    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */
    this.dynamicDurationValue = null;
  }

  // to be used on incidentFromDefinition
  static isCombo = true;

  static ClassName = 'Combo';

  static attrsValidationRules = null;
  static propsValidationRules = comboPropsRule;

  get incidents() {
    return null;
  }

  get duration() {
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    } else {
      return 'dynamic';
    }
  }

  set duration(ms) {
    super.duration = ms;
  }

  /**************** OVERWRITE DESCRIPTIVE GROUP'S INCIDENT MANAGEMENT METHODS ********
   * A DescriptiveCombo is a Group itself that hosts other Incidents. Combos though
   * define solid and specific behaviors, "hardcoded" right from
   * Combo's creation. For this, no direct handling of its Incidents is allowed from the
   * outside (and neither from the inside after the first build).
   * Thus we overwrite the Incidents management layer so it prevents it
   * ********************************************************************************/
  addIncident = handleInvalidIncidentChange;

  moveIncident = handleInvalidIncidentChange;

  removeIncident = handleInvalidIncidentChange;

  /** ***************** HANDLING METHODS OVERWRITE *********************** */

  handleCheckAddition = alwaysReturnFalse;

  handleCheckMove = alwaysReturnFalse;

  handleCheckDeletion = alwaysReturnFalse;

  handleCheckResize = alwaysReturnFalse;

  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Incident at any time
   */
  exportDefinition() {
    function stringifyIncidents(incidents) {
      const exportableIncidents = [];
      for (let i = 0; i < incidents.length; i++) {
        const incident = incidents[i];
        let incidentAttrs = incident.attrs;
        if (incident.incidentClass.ClassName === 'Combo') {
          incidentAttrs = {
            ...incidentAttrs,
            incidents: stringifyIncidents(incidentAttrs.incidents),
          };
        }

        exportableIncidents.push({
          // in order to cover the loaded plugins' Incidents case (case in which the Class
          // is the Wrapper and not directly the exposed Class) we add the second (targetClass) option
          ClassName:
            incident.incidentClass.ClassName ||
            incident.incidentClass.targetClass.ClassName,
          plugin_npm_name:
            incident.incidentClass.plugin_npm_name ||
            incident.incidentClass.targetClass.plugin_npm_name,
          version:
            incident.incidentClass.version ||
            incident.incidentClass.targetClass.version,
          attrs: incidentAttrs,
          props: deepCopy(incident.props),
          position: incident.position,
        });
      }
      return exportableIncidents;
    }

    // if the incidents have been overwritten because the getter returns incidents
    // we just remove them from our export
    // as they play absolutely no role, they get ignored by the system
    let attrsToUse = {
      ...this.attrs,
      incidents: stringifyIncidents(this.attrs.incidents),
    };

    return {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: attrsToUse,
      props: deepCopy(this.props),
      incidents: {},
      duration: this.duration,
    };
  }

  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */
  exportLiveDefinition(includeId = true) {
    // if the incidents have been overwriten because the getter returns incidents
    // we just remove them from our export
    // as they play absolutely no role, they get ignored by the system
    let attrsToUse = this.attrs;
    if (this.incidents !== null) {
      attrsToUse = { ...this.attrs, incidents: undefined };
    }

    let propsToReturn = deepCopy(this.props);
    if (!includeId) {
      delete propsToReturn.id;
    }
    return {
      Class: this.constructor,
      attrs: attrsToUse,
      props: propsToReturn,
      incidents: {},
    };
  }
}

export default DescriptiveCombo;
