/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import MediaChannel from '../Channels/Media/AudioPlaybackChannel';
import helper, { getAnId, hasOwnProp } from '../_coreUtils/helper';
import getIncidentsByChannel from './helpers/getIncidentsByChannel';
import setBlock from './helpers/block';
import unblock from './helpers/unblock';

/*
dna:
- originalId
- context
*/
export default class MediaPlay {
  constructor(attrs = {}, props = {}, dna) {
    // super(props);
    this.attrs = attrs;
    this.props = props;
    this.dna = dna;

    this.context = dna.context;
    this.mcid = dna.mcid;

    this.id = props.id || getAnId();
    this.modelId = props.modelId;

    // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
    // is set to true so we prevent multiple executions of the onGetContext method
    this.gotContext = false;

    /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */
    this.plugin_channel_class = MediaChannel;
    this.mc_plugin_npm_name = 'motor-cortex-js-media-playback';
    if (hasOwnProp(props, 'plugin_channel_class')) {
      this.plugin_channel_class = props.plugin_channel_class;
    }
    if (hasOwnProp(props, 'mc_plugin_npm_name')) {
      this.mc_plugin_npm_name = props.mc_plugin_npm_name;
    }

    this.hasIncidents = false;

    /**
     * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
     * on specific points on their timeline.
     */
    this.autoGenerated = false;

    this.onInitialise(attrs, props);
  }

  get selector() {
    return this.props.selector;
  }

  get element() {
    return this.context.getElementByMCID(this.mcid);
  }

  getIncidentsByChannel = getIncidentsByChannel.bind(this);

  _onGetContextOnce() {
    // if the Incident belongs to a fragmented context there absolutely
    // no reason to run the getContext method of it
    if (this.context.fragment === true) {
      return;
    }
    try {
      if (!this.gotContext) {
        this.onGetContext();
        this.gotContext = true;
      }
    } catch (e) {
      helper.error(e, this.mcid);
    }
  }

  onGetContext() {
    helper.info(
      'Overwrite the "onGetContext" method with the code you want to get executed',
      'info',
    );
  }

  lastWish() {}

  onInitialise() {
    helper.info(
      'Overwrite the "onInialise" method with the code you want to get executed',
      'info',
    );
  }

  /**
   * Method called on progress of the timed incident.
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   */

  // eslint-disable-next-line no-unused-vars
  onProgress(milliseconds) {}

  /**
   * starts the execution of the media from the specified millisecond
   * @returns {boolean}
   * */
  // eslint-disable-next-line no-unused-vars
  play(millisecond) {
    return true;
  }

  /**
   * stops the execution of the media
   * */
  stop() {}

  setBlock = setBlock.bind(this);

  unblock = unblock.bind(this);
}
