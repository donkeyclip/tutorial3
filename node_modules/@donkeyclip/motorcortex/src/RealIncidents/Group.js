/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Channel from '../Channels/Channel';
import Node from '../TimedTree/Node';
import { _MC_Plugin_Name } from '../_configuration/_CONST';
import { hasOwnProp } from '../_coreUtils/helper';
import setBlock from './helpers/block';
import unblock from './helpers/unblock';
class Group extends Node {
  constructor(attrs, props) {
    super(props);
    this.mc_plugin_npm_name = _MC_Plugin_Name;
    this.plugin_channel_class = Channel;

    this.hasIncidents = true;
    this.onGroupInitialise();

    this.calculatedDuration = 0;
  }

  onGroupInitialise() {
    // called when group gets initialised
  }

  handleAddIncident(target, payload) {
    if (this.id === target) {
      const incidentFromDescription = payload.incidentFromDescription;
      const theIncident = incidentFromDescription(
        payload.incident,
        payload.contextData,
      );
      // in the case that an audio clip tries to process an non-audio incident or
      // a non-audio incident tries to process an audio incident the result from incidentFromDescription is null
      // in such a case there should be no candidate return, so this.bypass()
      if (theIncident === null) {
        return this.bypass();
      }

      return theIncident;
    }

    return this.bypass();
  }

  handleMoveIncident(target, payload) {
    if (this.id === target) {
      const res = this.getLeafById(payload.incidentId, true);
      if (res === null) {
        return this.bypass();
      }
      return res;
    }

    return this.bypass();
  }

  /**
   * As Group acts as a transparent layer in terms of checks handleRemoveIncident
   * and handleMoveIncident happens to have the exact same definition
   */
  handleRemoveIncident = this.handleMoveIncident;

  handleResize(target) {
    return this.id === target ? this : this.bypass();
  }

  removeChild(id) {
    this.children[id].leaf.lastWish();
    super.removeChild(id);
  }

  /**
   * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
   * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object
   */
  getIncidentsByChannel(adjustMillisecond = 0, parentMillisecond = 0) {
    // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do
    const incidentsByPlugin = {};

    incidentsByPlugin[_MC_Plugin_Name] = [
      {
        millisecond: adjustMillisecond,
        parentMillisecond,
        incident: this,
        id: this.id,
      },
    ];

    // proceed to gather the contained incidents as well
    for (const childId in this.children) {
      const child = this.children[childId];
      const incidentsToAdd = child.leaf.getIncidentsByChannel(
        adjustMillisecond + child.position,
        adjustMillisecond,
      );
      for (const key in incidentsToAdd) {
        if (hasOwnProp(incidentsByPlugin, key)) {
          incidentsByPlugin[key] = incidentsByPlugin[key].concat(
            incidentsToAdd[key],
          );
        } else {
          incidentsByPlugin[key] = incidentsToAdd[key];
        }
      }
    }

    return incidentsByPlugin;
  }

  lastWish() {
    for (const childId in this.children) {
      this.children[childId].leaf.lastWish();
    }
  }

  setBlock = setBlock.bind(this);

  unblock = unblock.bind(this);
}

export default Group;
