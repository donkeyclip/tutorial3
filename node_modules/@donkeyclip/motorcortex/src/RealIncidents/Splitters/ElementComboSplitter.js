/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import ElementSplitter from './ElementSplitter';
import { getFromNameSpace } from '../../_coreUtils/proxies/nameSpaceHandler/nameSpaceHandler';
import ObjectProxy from '../../_coreUtils/proxies/ObjectProxy/ObjectProxy';
import DescriptiveGroup from '../../DescriptiveIncidents/DescriptiveGroup';
import incidentFromIngredients from '../../IncidentFromDefinition/incidentFromIngredients';
import incidentFromDescription from '../../IncidentFromDefinition/incidentFromDescription';
import { _DIRECTIONS } from '../../TimedTree/_CONST';
import { doNothing, hasOwnProp } from '../../_coreUtils/helper';
const dot = '-';

export const CascadingHanlder = {
  isCombo: function (item) {
    return item.incidentClass.isCombo;
  },

  getItem: function (descriptiveIncident, path) {
    return getFromNameSpace(path.join('.'), 'attrs', descriptiveIncident);
  },

  getRepeatPosition(delay, hiatus, duration, index) {
    return (
      index * (hiatus || 0) + (index + 1) * (delay || 0) + index * duration
    );
  },

  /**
   * Combo Incident's children, defined strictly on its attrs.incidents attribute,
   * might or might not have a selector. If they don't they are directly applied to
   * the elements of the Combo's selection.
   * Also, Combos might host other Combos on their attrs.incidents, which may host
   * others and so on. The selection inheritance is spread down all the way, as soon
   * as no selector is defined on the children-Combos.
   * The purpose of this method is to decide whether a given path of the descriptive
   * incident's attrs refer directly to the Combo's element
   **/
  refersToOwnSelector: function (descriptiveIncident, path, startIndex = 0) {
    let arPath = path;
    if (Array.isArray(path) === false) {
      arPath = path.split('.');
    }

    const item = this.getItem(
      descriptiveIncident,
      arPath.slice(0, 2 + startIndex),
    );
    // the item always points to an Incident defined on a Combo's attributes
    // if the item has selector return false
    if (
      item.props.selector !== '' &&
      item.props.selector !== undefined &&
      item.props.selector !== null
    ) {
      return false;
    } else if (arPath[2] === 'props') {
      // else if the dynamic value is applied to its props, look no further, return true
      return true;
    } else if (!this.isCombo(item)) {
      // else if the item is not a combo then return true
      return true;
    } else {
      return this.refersToOwnSelector(
        descriptiveIncident,
        arPath,
        startIndex + 3,
      );
    }
  },

  /**
   * Takes as input the rootSelector and the incidents. Returns a list of paths
   * and values that should be applied on the incidents
   * e.g.
   * [
   *  {
   *    path: "0.props.selector",
   *    value: "new selector"
   *  }, ...
   * ]
   **/
  cascadeSelectors(rootSelector, incidents, initialPath = '') {
    let changes = [];
    for (let i = 0; i < incidents.length; i++) {
      const item = incidents[i];

      let selectorToApply;
      if (hasOwnProp(item.props, 'selector')) {
        selectorToApply = `${rootSelector} ${item.props.selector}`;
      } else {
        selectorToApply = rootSelector;
      }
      changes.push({
        path: `${initialPath}${
          initialPath === '' ? '' : '.'
        }${i}.props.selector`,
        value: selectorToApply,
      });

      if (this.isCombo(item)) {
        const nestedChanges = this.cascadeSelectors(
          selectorToApply,
          item.attrs.incidents,
          `${initialPath}${initialPath === '' ? '' : '.'}${i}.attrs.incidents`,
        );
        changes = changes.concat(nestedChanges);
      }
    }
    return changes;
  },

  /**
   * Takes in an Incident defined in the supported format of the Combo attrs and
   * returns an object that has all the necessary properties in order to be further
   * used by the standard analysis process, further down the way. The necessary properties
   * to have are:
   * - audio
   * - attrs
   * - props
   * - id
   * - selector
   * - selector()
   * - audioClip
   * - constructor.Incident
   * - constructor.plugin_npm_name
   * - constructor.Channel
   * - constructor.isClip
   * - attributesStaggers
   * - propsStaggers
   * - dynamicDurationValue
   **/
  createDescriptiveIncidentLikeObject(
    incident,
    attributesStaggers,
    propsStaggers,
    attrs,
    props,
  ) {
    return {
      constructor: {
        Incident: incident.incidentClass.targetClass.Incident,
        plugin_npm_name: incident.incidentClass.targetClass.plugin_npm_name,
        Channel: incident.incidentClass.targetClass.Channel,
        isClip: false,
      },
      attrs: attrs || incident.attrs,
      props: props || incident.props,
      selector: () => incident.props.selector,
      id: incident.props.id,
      audioClip: null,
      audio: 'no',
      dynamicDurationValue: null,
      putMessageOnPipe: doNothing,
      attributesStaggers: attributesStaggers,
      propsStaggers: propsStaggers,
    };
  },

  parseElementsDynamics(
    staggerAttrs,
    originalAttrs,
    originalProps,
    elementIndex,
    incidentIndex,
  ) {
    const attrsStartPattern = `incidents.${incidentIndex}.attrs`;
    const propsStartPattern = `incidents.${incidentIndex}.props`;
    const attrsProxy = ObjectProxy(originalAttrs);
    const propsProxy = ObjectProxy(originalProps);
    for (let i = 0; i < staggerAttrs.length; i++) {
      if (staggerAttrs[i].path.indexOf(attrsStartPattern) === 0) {
        const path = staggerAttrs[i].path.substring(
          attrsStartPattern.length + 1,
        );
        attrsProxy.setValue(path, staggerAttrs[i].values[elementIndex]);
      } else if (staggerAttrs[i].path.indexOf(propsStartPattern) === 0) {
        const path = staggerAttrs[i].path.substring(
          propsStartPattern.length + 1,
        );
        propsProxy.setValue(path, staggerAttrs[i].values[elementIndex]);
      }
    }
    return {
      incidentAttrs: attrsProxy.exportFlattened(),
      incidentProps: propsProxy.exportFlattened(),
    };
  },

  /**
   * Gets a list of dynamics in the form (example):
   * [
   *  {
   *    path: "incidents.<index>.attrs.alpha",
   *    stagger: [StaggerClass] // or ElementAttributeC, MathC
   *  }
   * ] (This type of information is stored on the properties "attributesStaggers" and
   *    "propsStaggers" of any DescriptiveIncident)
   * the index of the incident (on the attrs.incidents array, needed for path resolving)
   * and the type of data (either attrs or props) of our Combo that the dynamic
   * lives in. (It helps us easily separate attrributesStaggers from propsStaggers)
   **/
  getStaggersForChild(attributesStaggers, index, type) {
    const remainingDynamics = [];
    const identifiedDynamics = [];
    for (let i = 0; i < attributesStaggers.length; i++) {
      // if the path of the dynamic starts with "incidents.<index>.<type>", e.g.
      // incidents.0.attrs we pass the dynamic to the child otherwise we keep it
      // on our remaining attributesStaggers
      if (
        type === 'position' &&
        attributesStaggers[i].path.indexOf(`incidents.${index}.${type}`) === 0
      ) {
        identifiedDynamics.push({
          path: 'position',
          stagger: attributesStaggers[i].stagger,
        });
      } else if (
        attributesStaggers[i].path.indexOf(`incidents.${index}.${type}`) === 0
      ) {
        identifiedDynamics.push({
          path: attributesStaggers[i].path.substring(
            `incidents.${index}.${type}`.length + 1,
          ),
          stagger: attributesStaggers[i].stagger,
        });
      } else {
        remainingDynamics.push(attributesStaggers[i]);
      }
    }
    return { identifiedDynamics, remainingDynamics };
  },

  createElementProxy(
    descriptiveIncident,
    selector,
    elementIndex,
    staggerAttrs,
    staggerProps,
  ) {
    const elementProxy = ObjectProxy(descriptiveIncident);
    /* we need to apply selector's cascading down to the Combo's attrs.incidents tree.
     For this we gather all selector changes that should be applied on an array (a collection)
     containing {path, value} pairs, totally compatible for feeding our proxy.
    */
    const selectorChanges = this.cascadeSelectors(
      selector,
      descriptiveIncident.attrs.incidents,
      'attrs.incidents',
    );
    /* we need to apply changes on the tree coming from the element's dynamic values (e.g. stagger)
      ElementComboSplitter has this information as :
        this.staggerProps and this.staggerAttrs (that have been calculated by the methods
        this.parsePropsDynamicValues and this.parseAttrsDynamicValues that ran on setUp).
        this.staggerProps and this.staggerAttrs, each are arrays holding {path, values}
        entries. Each entry has the path to the attr or prop and an array with the values
        that should be applied in all of the elements (e.g. values[100, 110, 120])
    */
    // we now feed our changes to our ObjectProxy
    for (let i = 0; i < staggerAttrs.length; i++) {
      elementProxy.setValue(
        `attrs.${staggerAttrs[i].path}`,
        staggerAttrs[i].values[elementIndex],
      );
    }
    for (let i = 0; i < staggerProps.length; i++) {
      elementProxy.setValue(
        `props.${staggerProps[i].path}`,
        staggerProps[i].values[elementIndex],
      );
    }
    for (let i = 0; i < selectorChanges.length; i++) {
      elementProxy.setValue(selectorChanges[i].path, selectorChanges[i].value);
    }
    // and we are now good to proceed with the implementation of our element-specific Combo
    // with all the selectors and the dynamic values already parsed for it
    return elementProxy;
  },
};

class ElementComboSplitter extends ElementSplitter {
  // only puts on its staggerAttrs the staggers that refer to its own elements
  parseAttrsDynamicValues(descriptiveIncident, elements) {
    this.childrenStaggers = [];
    for (let i = 0; i < descriptiveIncident.attributesStaggers.length; i++) {
      if (
        CascadingHanlder.refersToOwnSelector(
          descriptiveIncident,
          descriptiveIncident.attributesStaggers[i].path,
        )
      ) {
        this.staggerAttrs.push({
          path: descriptiveIncident.attributesStaggers[i].path,
          values: descriptiveIncident.attributesStaggers[
            i
          ].stagger.calculateValues(elements, this.initParams),
        });
      } else {
        this.childrenStaggers.push(descriptiveIncident.attributesStaggers[i]);
      }
    }
  }

  /*
   * handleRecalDuration method is called after a successful addition.
   * Thus this is the chance and the point where the ElementsSplitter can update
   * the dynamicDurationValue of its DescriptiveIncident
   */
  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);
    this.descriptiveIncident.dynamicDurationValue = this.duration * 1;
    return res;
  }

  /*
   * lastWish is called when and Incident gets detached from a Clip. ElementsComboSplitter overwrites
   * the default lastWish coming from Group so it clears the dynamicDurationValue from its
   * DescriptiveIncident
   */
  lastWish() {
    this.descriptiveIncident.dynamicDurationValue = null;
    this.descriptiveIncident.putMessageOnPipe(
      'setDurationDynamic',
      {},
      'Groups',
      {
        selfExecute: false,
        direction: _DIRECTIONS._UP,
      },
    );
    super.lastWish();
  }

  _createElementIncident(
    element,
    descriptiveIncident,
    contextData,
    elementIndex,
    totalElements,
    mcid,
  ) {
    // let's frist create a proxy of the descriptive incident (to apply element-specific changes)
    // so we can mess with it without affecting our original data at all.
    const elementDI = CascadingHanlder.createElementProxy(
      descriptiveIncident,
      contextData.context.getElementSelectorByMCID(mcid),
      elementIndex,
      this.staggerAttrs,
      this.staggerProps,
    );
    for (let i = 0; i < this.staggerAttrs.length; i++) {
      elementDI.setValue(
        `attrs.${this.staggerAttrs[i].path}`,
        this.staggerAttrs[i].values[elementIndex],
      );
    }
    // we then create a real Group instance that represents / contains all of the action of the element
    const elementGroup = incidentFromIngredients({
      id: `${this.id}_element${dot}${elementIndex}`,
      attrs: {},
      props: {},
      Incident: DescriptiveGroup.Incident,
      plugin_npm_name: DescriptiveGroup.plugin_npm_name,
      Channel: DescriptiveGroup.Channel,
      DescriptiveIncident: new DescriptiveGroup(),
    });
    // then we create Groups, one per elementDI's repeats, we fill them with the
    // incidents of attrs.incidents array. We will position each according to
    // the delay and hiatus of elementDI
    for (
      let repeatIndex = 0;
      repeatIndex < (elementDI.props.repeats || 1);
      repeatIndex++
    ) {
      const repeatGroup = incidentFromIngredients({
        id: `${this.id}_element${dot}${elementIndex}_repeat${dot}${repeatIndex}`,
        attrs: {},
        props: {},
        Incident: DescriptiveGroup.Incident,
        plugin_npm_name: DescriptiveGroup.plugin_npm_name,
        Channel: DescriptiveGroup.Channel,
        DescriptiveIncident: new DescriptiveGroup(),
      });

      // --- we handle the iteration on elementDI.attrs.incidents array ---

      // we will divide the identified staggers of our Combo by passing down to each
      // incident only the ones that concern it. For performance reasons instead of
      // iterating for each incident to the full list of the attributesStaggers
      // the getStaggersForChild method always returns the remaining (not matched) so we can
      // use them instead for every next child/incident.
      // remainingStaggers just represent the reduced original attributesStaggers after each child filtering
      let remainingStaggers = this.childrenStaggers;
      elementDI.attrs.incidents.forEach((incident, incidentIndex) => {
        const { incidentAttrs, incidentProps } =
          CascadingHanlder.parseElementsDynamics(
            this.staggerAttrs,
            incident.attrs,
            incident.props,
            elementIndex,
            incidentIndex,
          );

        const inc_attrsStaggersResult = CascadingHanlder.getStaggersForChild(
          remainingStaggers,
          incidentIndex,
          'attrs',
        );
        const inc_propsStaggersResult = CascadingHanlder.getStaggersForChild(
          inc_attrsStaggersResult.remainingDynamics,
          incidentIndex,
          'props',
        );
        const inc_positionStaggersResult = CascadingHanlder.getStaggersForChild(
          inc_attrsStaggersResult.remainingDynamics,
          incidentIndex,
          'position',
        );
        remainingStaggers = inc_propsStaggersResult.remainingDynamics;
        // assign id to our incident
        elementDI.setValue(
          `attrs.incidents.${incidentIndex}.props.id`,
          `${this.id}_element${dot}${elementIndex}_repeat${dot}${repeatIndex}_incident${dot}${incidentIndex}`,
        );
        // we now have all the data needed to create a DescriptiveIncident - like object
        // reprensenting our incident
        const inc_di = CascadingHanlder.createDescriptiveIncidentLikeObject(
          incident,
          inc_attrsStaggersResult.identifiedDynamics,
          inc_propsStaggersResult.identifiedDynamics,
          incidentAttrs,
          incidentProps,
        );
        const inc_incident = incidentFromDescription(inc_di, contextData);
        let position = incident.position;
        if (inc_positionStaggersResult.identifiedDynamics.length === 1) {
          position =
            inc_positionStaggersResult.identifiedDynamics[0].stagger.calculateValues(
              new Array(totalElements),
              this.initParams,
            )[elementIndex];
        }
        repeatGroup.addChild(inc_incident, position);
      });

      // now that we have our repeat Group ready we only have to position it on
      // the elementGroup taking in consideration the hiatus, the delay of the
      // elementDI as well as the index of the iteration itself
      elementGroup.addChild(
        repeatGroup,
        CascadingHanlder.getRepeatPosition(
          elementDI.props.delay,
          elementDI.props.hiatus,
          repeatGroup.duration,
          repeatIndex,
        ),
      );
    }
    this.addChild(elementGroup, 0);
  }
}

export default ElementComboSplitter;
