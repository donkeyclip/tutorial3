/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Group from '../Group';
import {
  assignValueToPath,
  deepCopy,
  getAnId,
  hasOwnProp,
} from '../../_coreUtils/helper';
import AnimatedAttributeSplitter from './AnimatedAttributeSplitter';
import ContextAwareIncident from './ContextAwareIncident';
import { _DIRECTIONS } from '../../TimedTree/_CONST';
import {
  prepareElementsAttrs,
  prepareElementsProps,
} from './helpers/prepareDynamics';

class ElementSplitter extends Group {
  constructor(descriptiveIncident, contextData) {
    // we make sure the DOMAwareIncident takes the same id as the Descriptive Incident
    super({}, { id: descriptiveIncident.id });

    // a property to hold all of the contexts
    this.contexts = {};
    this.contexts[contextData.clipId] = contextData.context;
    this.originalContextKey = contextData.clipId;
    this.initParams = contextData.context.initParams;
    this.instantiatedCopiesContexts = contextData.instantiatedCopiesContexts;
    this.descriptiveIncident = descriptiveIncident;

    /*
    staggerAttrs is an array holding the calculated values of stagger attributes
    per path and per element. So, for example, if animatedAttrs.width and animatedAttrs.height
    attributes have stagger expressions and there are 10 in total elements the
    staggerAttrs will end up with two entries, one for animatedAttrs.width and one for
    animatedAttrs.height attributes.
    Each of these objects will have a "path" key, defining their path in the attriubtes
    and the "values" key which is an array holding the final values per element. In
    our example this will be an array of length = 10, as we have 10 in total elements.
    */
    this.staggerAttrs = [];
    this.staggerProps = [];

    this.setUp(descriptiveIncident, contextData);
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  parsePropsDynamicValues(descriptiveIncident, elements) {
    for (
      let propStagger, i = 0;
      i < descriptiveIncident.propsStaggers.length;
      i++
    ) {
      propStagger = descriptiveIncident.propsStaggers[i];
      this.staggerProps.push({
        path: propStagger.path,
        values: propStagger.stagger.calculateValues(elements, this.initParams),
      });
    }
  }

  parseAttrsDynamicValues(descriptiveIncident, elements) {
    for (
      let attrStagger, i = 0;
      i < descriptiveIncident.attributesStaggers.length;
      i++
    ) {
      attrStagger = descriptiveIncident.attributesStaggers[i];
      this.staggerAttrs.push({
        path: attrStagger.path,
        values: attrStagger.stagger.calculateValues(elements, this.initParams),
      });
    }
  }

  setUp(descriptiveIncident, contextData) {
    // the elements of the original context
    const elements = this.originalContext.getElements(
      descriptiveIncident.selector(),
    );
    // calculate stagger (if any) and store values on this.staggerAttrs
    this.parsePropsDynamicValues(descriptiveIncident, elements);
    this.parseAttrsDynamicValues(descriptiveIncident, elements);

    let element, mcid;
    for (let i = 0; i < elements.length; i++) {
      element = elements[i];
      // set the mcid of the element on index i of the original context
      mcid = this._getElementMCID(element);
      // set the same mcid for the elements of the same context in all of the instantiatedCopiesContexts
      for (const contextKey in this.instantiatedCopiesContexts) {
        // TODO perfrormance improvement via selecting once elements per context
        this._setElementMCID(
          this.instantiatedCopiesContexts[contextKey],
          this.instantiatedCopiesContexts[contextKey].getElements(
            descriptiveIncident.selector(),
          )[i],
          mcid,
        );
      }
      this._createElementIncident(
        element,
        descriptiveIncident,
        contextData,
        i,
        elements.length,
        mcid,
      );
    }
  }

  /*
   * handleRecalDuration method is called after a successful addition.
   * Thus this is the chance and the point where the ElementsSplitter can update
   * the dynamicDurationValue of its DescriptiveIncident
   */
  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);
    if (this.descriptiveIncident.propsStaggers.length > 0) {
      this.descriptiveIncident.dynamicDurationValue = this.duration * 1;
    }
    return res;
  }

  /*
   * lastWish is called when and Incident gets detached from a Clip. ElementsSplitter overwrites
   * the default lastWish coming from Group so it clears the dynamicDurationValue from its
   * DescriptiveIncident
   */
  lastWish() {
    if (this.descriptiveIncident.propsStaggers.length > 0) {
      this.descriptiveIncident.dynamicDurationValue = null;
      this.descriptiveIncident.putMessageOnPipe(
        'setDurationDynamic',
        {},
        'Groups',
        {
          selfExecute: false,
          direction: _DIRECTIONS._UP,
        },
      );
    }
    super.lastWish();
  }

  _getElementMCID(element) {
    let mcid = this.originalContext.getMCID(element);
    if (!mcid) {
      mcid = getAnId(true);
      this.originalContext.setMCID(element, mcid);
    }
    return mcid;
  }

  _setElementMCID(context, element, mcid) {
    const existingMCID = context.getMCID(element);
    if (!existingMCID) {
      context.setMCID(element, mcid);
    }
  }

  _prepareAttrsPropsForElement(descriptiveIncident, elementIndex) {
    // as a first step we need to assign the already calculated dynamic values (if any) of the specific element
    const attrsForElement = prepareElementsAttrs(
      this.staggerAttrs,
      elementIndex,
    );
    // same for props
    const propsForElement = prepareElementsProps(
      this.staggerProps,
      elementIndex,
    );
    let attributes = descriptiveIncident.attrs;
    let properties = descriptiveIncident.props;
    // if there are dynamic values make a copy of the original attrs so we don't change
    // the original values and assign the dynamic values to it
    if (attrsForElement.length > 0) {
      attributes = deepCopy(descriptiveIncident.attrs);
      for (let i = 0; i < attrsForElement.length; i++) {
        assignValueToPath(
          attributes,
          attrsForElement[i].path,
          attrsForElement[i].value,
        );
      }
    }

    if (propsForElement.length > 0) {
      properties = deepCopy(descriptiveIncident.props);
      for (let i = 0; i < propsForElement.length; i++) {
        assignValueToPath(
          properties,
          propsForElement[i].path,
          propsForElement[i].value,
        );
      }
    }

    return {
      attrs: attributes,
      props: properties,
    };
  }

  _createElementIncident(
    element,
    descriptiveIncident,
    contextData,
    elementIndex,
    totalElements,
    mcid,
  ) {
    const elementData = this._prepareAttrsPropsForElement(
      descriptiveIncident,
      elementIndex,
    );

    /* elements splitter might handle either attribute Incidents (that have animatedAttrs) or Incidents
        that do not have animatedAttrs such as MediaPlayback Incidents.
        In the case of an attributed Incident we proceed by creating one AttributeSplitter for each
        while on the case of an non-attribured Incident we go ahead and implement the final
        Incident
        */
    if (hasOwnProp(descriptiveIncident.attrs, 'animatedAttrs')) {
      const animatedAttributeSplitter = new AnimatedAttributeSplitter(
        descriptiveIncident,
        contextData,
        mcid,
        contextData.context.getElementSelectorByMCID(mcid),
        elementData,
      );
      this.addChild(animatedAttributeSplitter, 0);
    } else {
      const attrsToPass = elementData.attrs;
      const propsToPass = elementData.props;
      const constructionIngredients = {
        incidentId: descriptiveIncident.id,
        attrs: attrsToPass,
        props: propsToPass,
        Incident: descriptiveIncident.constructor.Incident,
        plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
        Channel: descriptiveIncident.constructor.Channel,
        DescriptiveIncident: descriptiveIncident,
      };
      const contextAwareIncident = new ContextAwareIncident(
        constructionIngredients,
        contextData,
        mcid,
        null,
      );
      this.addChild(contextAwareIncident, 0);
    }
  }
}

export default ElementSplitter;
