/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Channel from '../../Channels/Clip/ClipsChannel';
import ContextAwareClipIncident from './ContextAwareClipIncident';
import ElementSplitter from './ElementSplitter';
import clipFromDefinition from '../../IncidentFromDefinition/clipFromDefinition';
import { getAnId } from '../../_coreUtils/helper';
import { _DIRECTIONS } from '../../TimedTree/_CONST';

/**
 * This Class is the Context Aware Incident for Clips. When constructed, the Incident passed to
 * it is a Clip with HTMLFragmented context handler.
 * On add, edit or deletion of Incidents on the Original Clip's tree ElementClipSplitter implements, all updates on lanes
 * and everything that these clips need in order to run are made directly to the
 * ContextAwareIncidents of the HTMLDescriptiveClip's real Clip.
 */
class ElementClipSplitter extends ElementSplitter {
  constructor(descriptiveIncident, contextData) {
    super(descriptiveIncident, contextData);
    this.realClip = descriptiveIncident.realClip;
  }

  _createElementIncident(
    element,
    descriptiveIncident,
    contextData,
    elementIndex,
    totalElements,
    mcid,
  ) {
    // we want to apply stagger (and any other dynamic value assignment method)
    // to the allowed props (duration, hiatus, delay)
    const elementData = this._prepareAttrsPropsForElement(
      descriptiveIncident,
      elementIndex, // we should prevent @stagger and other dynamic expressions from the attrs of the Clip
    );

    // here we create the new OriginalCASIClip if the mock one is used. This happens in cases of @initParams on the props of the Clip
    if (descriptiveIncident.realClip.isNullClip) {
      const definition = {
        ...descriptiveIncident.exportLiveDefinition(),
        ...elementData,
      };
      const tempDC = clipFromDefinition(definition);
      descriptiveIncident.realClip = tempDC.realClip;

      // we connect the subscriptions of the temporary Descriptive Incident with the one the user created and it's on
      // the descriptive tree
      descriptiveIncident.subscribe(
        getAnId(),
        (ms, state) => {
          tempDC._setState(state);
        },
        0,
        1,
        true,
      );

      // all blocks and unblocks coming to the new (temporary) Descriptive Clip are re-handled and re-generated by the
      // original Descriptive Clip so they can travel all the way up to the Descriptive tree until the root
      tempDC.handleSetBlock = (target, payload) => {
        return descriptiveIncident.putMessageOnPipe(
          'setBlock',
          { ...payload, id: tempDC.id },
          'rootClip',
          { selfExecute: true, direction: _DIRECTIONS._UP },
        );
      };

      tempDC.handleUnBlock = () => {
        return descriptiveIncident.putMessageOnPipe(
          'unBlock',
          {
            id: tempDC.id,
          },
          'rootClip',
          { selfExecute: true, direction: _DIRECTIONS._UP },
        );
      };
    }

    // as we are going to create a clip copy we want to take the snapshot of our original clip
    // as it is at the moment. For example in the case of HTMLClip this method will make sure all
    // html attributes applied up to this moment will be reflected on the new clip copy
    const constructionArguments =
      descriptiveIncident.realClip.exportConstructionArguments();

    const propsToPass = {
      ...descriptiveIncident.props,
      duration: descriptiveIncident.realClip.duration, // the original duration of the real Clip
      ...constructionArguments.props,
      ...elementData.props, // if duration is dynamic it will be re-set here, overwriting the line above
      selector: contextData.context.getElementSelectorByMCID(mcid),
      // runTimeInfo: descriptiveIncident.runTimeInfo,
    };

    /**
     * ElementClipSplitter only uses the props that have been produced by the dynamic value parsing method (elementData)
     * It doesn't use attrs and that's because attrs might contain data that can affect the number of Incidents of the
     * Clip, the html of Clip etc, something we certainly don't want as it's mandatory all of our CASIs to have the exact
     * same structure, html and css. Check the comments below inline
     * @type {{Channel: ClipChannel, DescriptiveIncident, Incident: *, incidentId, plugin_npm_name: *, attrs, props: (*&{duration, runTimeInfo, selector: *})}}
     */
    const constructionIngredients = {
      incidentId: descriptiveIncident.id,
      attrs: constructionArguments.attrs, // keeps the original attrs
      props: propsToPass, // uses the props produced by the dynamic values' parsing
      Incident: descriptiveIncident.constructor.Incident,
      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
      Channel,
      DescriptiveIncident: descriptiveIncident,
    };
    const contextAwareClipIncident = new ContextAwareClipIncident(
      constructionIngredients,
      contextData,
      mcid,
      descriptiveIncident,
    );
    this.addChild(contextAwareClipIncident, 0);
  }
}

export default ElementClipSplitter;
