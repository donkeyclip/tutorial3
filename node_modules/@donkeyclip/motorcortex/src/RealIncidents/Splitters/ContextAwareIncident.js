/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import bezeasing from 'bezier-easing';
import incidentFromIngredients from '../../IncidentFromDefinition/incidentFromIngredients';
import Leaf from '../../TimedTree/Leaf';
import easings from '../../_configuration/easings';
import { isObject, hasOwnProp, deepCopy } from '../../_coreUtils/helper';
import getIncidentsByChannel from '../helpers/getIncidentsByChannel';

class ContextAwareIncident extends Leaf {
  constructor(constructionIngredients, contextData, mcid, attribute) {
    super({
      ...constructionIngredients.props,
      id: `${constructionIngredients.incidentId}_${mcid}${
        attribute != null ? '_' + attribute : ''
      }`,
    });

    // a property to hold all of the contexts
    this.contexts = {};

    this.constructionIngredients = constructionIngredients;
    this.mcid = mcid;
    this.attribute = attribute;
    // this._duration = constructionIngredients.props.duration;

    this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
    this.plugin_channel_class = constructionIngredients.Channel;

    this.DescriptiveIncident = constructionIngredients.DescriptiveIncident;

    this.addContext(contextData);

    if (attribute !== null) {
      const animatedAttr =
        this.constructionIngredients.attrs.animatedAttrs[this.attribute];
      if (Array.isArray(animatedAttr)) {
        this.originalAnimatedAttributeValue = [...animatedAttr];
      } else if (isObject(animatedAttr)) {
        this.originalAnimatedAttributeValue = {
          ...animatedAttr,
        };
      } else {
        this.originalAnimatedAttributeValue = animatedAttr;
      }
    }

    this.easing = easings.linear;

    if (hasOwnProp(this.props, 'easing')) {
      if (Array.isArray(this.props.easing)) {
        this.easing = bezeasing(
          this.props.easing[0],
          this.props.easing[1],
          this.props.easing[2],
          this.props.easing[3],
        );
      } else {
        this.easing = easings[this.props.easing];
      }
    }

    this._duration = super.duration;
    this.repeatDuration = this.delay + this.props.duration + this.hiatus;
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  get duration() {
    return this._duration;
  }

  set duration(milliseconds) {
    super.duration = milliseconds;

    for (const context in this.contexts) {
      this.contexts[context].duration = milliseconds;
    }
    this._duration = super.duration;
    this.repeatDuration = this.delay + this.props.duration + this.hiatus;
  }

  addContext(contextData, forceGetContext = false) {
    // if it's the first context to be added then it's the original
    let isTheOriginalContext = false;
    if (Object.keys(this.contexts).length === 0) {
      this.originalContextKey = contextData.clipId;
      this.originalClipContext = contextData.context;
      isTheOriginalContext = true;
    }

    const ingredientsToPass = {
      ...this.constructionIngredients,
      context: contextData.context,
      mcid: this.mcid,
    };
    const whatToAdd = incidentFromIngredients(ingredientsToPass);
    this.contexts[contextData.clipId] = whatToAdd;

    // when we add a new context we must set the inital value of the newly added Incidents
    // but only for Incidents with animatedAttrs
    if (!isTheOriginalContext && this.attribute != null) {
      this.contexts[contextData.clipId].setInitialValue(this.initialValue);
    }

    if (
      forceGetContext &&
      this.contexts[contextData.clipId].context.contextLoaded
    ) {
      this.contexts[contextData.clipId]._onGetContextOnce();
    }
  }

  // eslint-disable-next-line no-unused-vars
  handleAddContext(target, payload) {
    this.addContext(payload, true);
    return true;
  }

  // eslint-disable-next-line no-unused-vars
  handleContextLoaded(target, payload) {
    this._onGetContextOnce();
    return true;
  }

  getIncidentsByChannel = getIncidentsByChannel.bind(this);

  onProgress(milliseconds, contextId) {
    /* MonoIncidents are totally agnostic about delay, hiatus and repeats.
        CAI is not that's exactly the point where these properties management occurs.
        Having already set the duration of the ContextAwareIncident according to
        all of these props, here the CAI decides on the progress that its MonoIncidents
        are to on at the given millisecond and according to the given props.
        */

    const delay = this.props.delay || 0; // we prefer this from the Leaf's getter for performance reasons
    // step 2.a: find the running repeat and millisecond of this repeat
    let millisecondWithinRepeat = milliseconds % this.repeatDuration;
    // step 2.b: decide between 0 and 1
    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = delay + this.props.duration;
    }
    // step 3: find the millisecond of the MonoIncident
    let MI_millisecond = millisecondWithinRepeat - delay;
    if (MI_millisecond < 0) {
      MI_millisecond = 0;
    } else if (MI_millisecond > this.props.duration) {
      // if it has stepped into hiatus
      MI_millisecond = this.props.duration;
    }
    const MI_fraction = MI_millisecond / this.props.duration;

    const eased_MI_fraction = this.easing(MI_fraction);
    const eased_MI_millisecond = eased_MI_fraction * this.props.duration;
    if (contextId == null) {
      for (const context in this.contexts) {
        if (
          this.originalContextKey !== context ||
          this.originalContext.fragment !== true
        ) {
          this.contexts[context].onProgress(eased_MI_millisecond);
        }
      }
      return;
    }
    // if (this.contexts[contextId].context.contextLoaded) { we leave this here for future reference. Might cause issues
    this.contexts[contextId].onProgress(eased_MI_millisecond);
    // }
  }

  /** METHODS THAT ACT AS "PROXY" TO ALL OF THE INCIDENTS BELONGING TO
   * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT
   * */
  get animatedAttributeValue() {
    return this.constructionIngredients.attrs.animatedAttrs[this.attribute];
  }

  set animatedAttributeValue(value) {
    this.constructionIngredients.attrs.animatedAttrs[this.attribute] = value;
  }

  // massive editing methods that apply the request massively to all of the
  // Incidents of all of the contexts
  gotContext() {
    for (const context in this.contexts) {
      this.contexts[context].gotContext();
    }
  }

  _onGetContextOnce() {
    if (this.originalContext.context.contextLoaded === false) {
      return;
    }
    for (const context in this.contexts) {
      this.contexts[context]._onGetContextOnce();
    }
  }

  lastWish() {
    for (const context in this.contexts) {
      this.contexts[context].lastWish();
    }
  }

  onGetContext() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }
    for (const context in this.contexts) {
      if (this.contexts[context].context.contextLoaded) {
        this.contexts[context].onGetContext();
      }
    }
  }

  get initialValue() {
    return this.originalContext.initialValue;
  }

  get scratchValue() {
    return this.originalContext.scratchValue;
  }

  get pureInitialValues() {
    return this.originalContext.pureInitialValues;
  }

  setInitialValue(value, store = true) {
    const val = deepCopy(value ?? this.getScratchValue());

    for (const context in this.contexts) {
      this.contexts[context].setInitialValue(val, store);
    }
  }

  getScratchValue(contextId = null) {
    // if the context is not loaded yet then return a temporary 0. When the context
    // gets loaded the ExtendableClip will force ContextAwareIncidents to recalc
    // and store it
    if (!this.originalContext.context.contextLoaded) {
      return 0;
    }

    if (contextId != null) {
      return this.contexts[contextId].getScratchValue();
    }

    if (hasOwnProp(this.originalClipContext, 'nonFragmentedContext')) {
      const ingredientsToPass = {
        ...this.constructionIngredients,
        context: this.originalClipContext.nonFragmentedContext,
        mcid: this.mcid,
      };
      const tempIncident = incidentFromIngredients(ingredientsToPass);
      return tempIncident.getScratchValue();
    }

    const contextsKeys = Object.keys(this.contexts);
    if (contextsKeys.length === 1) {
      return this.originalContext.getScratchValue();
    }
    // prefer another (not the original) context to provide scratch values
    return this.contexts[contextsKeys[1]].getScratchValue();
  }

  play(fraction, ms, contextId) {
    return this.contexts[contextId].play(ms);
  }

  stop(contextId) {
    this.contexts[contextId].stop();
  }
}

export default ContextAwareIncident;
