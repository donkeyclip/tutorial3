/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import bezeasing from 'bezier-easing';
import ClipCopy from '../../Clip/_ClipCopy/ClipCopy';
import incidentFromIngredients from '../../IncidentFromDefinition/incidentFromIngredients';
import Leaf from '../../TimedTree/Leaf';
import { _DIRECTIONS } from '../../TimedTree/_CONST';
import easings from '../../_configuration/easings';
import getIncidentsByChannel from '../helpers/getIncidentsByChannel';
import { hasOwnProp } from '../../_coreUtils/helper';

class ContextAwareClipIncident extends Leaf {
  constructor(constructionIngredients, contextData, mcid, descriptiveIncident) {
    super({
      ...constructionIngredients.props,
      id: `${constructionIngredients.incidentId}_${mcid}`,
    });
    // a property to hold all of the contexts
    this.contexts = {};

    this.constructionIngredients = constructionIngredients;
    this.mcid = mcid;
    this.DescriptiveIncident = descriptiveIncident;

    this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
    this.plugin_channel_class = constructionIngredients.Channel;

    this.addContext(contextData);

    this.timeScale = 1;
    if (descriptiveIncident.realClip.duration > 0) {
      this.timeScale =
        this.props.duration / descriptiveIncident.realClip.duration;
    }

    /*
    resizing a CASI follows a slightly different approach than resizing anything
    else in the MC ecosystem. The differences rely on the fact that resizing a
    HTMLDescriptiveClip, used as CASI, doesn't need to be checked as CASIs are Clips that
    check themselves and resizing can't produce conflicts, and also that CASIs have
    their fragmented clips (realClip) which they should resize as well.
    When resizing a CASI the DC resizes its realClip but it doesn't resize its representation
    on the context of its parent Clip, which is ElementClipSplitter with its ContextAwareClipIncident
    (CACI) children.
    For this, CACI is responsible for that as it subscribes and listens to
    duration changes on its HTMLDescriptiveClip's realClip and it informs its own tree (the
    parent Clip tree), as well as its own duration.
     */
    descriptiveIncident.realClip.subscribeToDurationChange((newDuration) => {
      this.props.duration = this.timeScale * newDuration;
      this.resetDuration();
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP,
      });
    });

    this.easing = easings.linear;
    if (hasOwnProp(this.props, 'easing')) {
      if (Array.isArray(this.props.easing)) {
        this.easing = bezeasing(
          this.props.easing[0],
          this.props.easing[1],
          this.props.easing[2],
          this.props.easing[3],
        );
      } else {
        this.easing = easings[this.props.easing];
      }
    }
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  onProgress(fraction, milliseconds, contextId, forceReset = false) {
    // step 1: find the full delay-duration-hiatus duration of one repeat
    const repeatDuration = this.delay + this.props.duration + this.hiatus;
    // step 2.a: find the running repeat and millisecond of this repeat
    let millisecondWithinRepeat = milliseconds % repeatDuration;
    // step 2.b: decide between 0 and 1
    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = this.delay + this.props.duration;
    }
    // step 3: find the millisecond of the MonoIncident
    let MI_millisecond = millisecondWithinRepeat - this.delay;
    if (MI_millisecond < 0) {
      MI_millisecond = 0;
    } else if (MI_millisecond > this.props.duration) {
      // if it has stepped into hiatus
      MI_millisecond = this.props.duration;
    }
    const MI_fraction =
      this.props.duration === 0 ? 0 : MI_millisecond / this.props.duration;

    const eased_MI_fraction = this.easing(MI_fraction);
    const eased_MI_millisecond =
      eased_MI_fraction * this.props.duration * (1 / this.timeScale);
    if (this.originalContext.context.contextLoaded !== false) {
      this.contexts[contextId].onProgress(
        eased_MI_fraction,
        eased_MI_millisecond,
        forceReset,
      );
    }
  }

  /**
   * The method that handles the addContext message from the ExtendableClip
   **/
  addContext(contextData, forceGetContext = false) {
    // if it's the first context to be added then it's the original
    if (Object.keys(this.contexts).length === 0) {
      this.originalContextKey = contextData.clipId;
    }

    // instantiates a _ClipCopy for the new context
    const ingredientsToPass = {
      ...this.constructionIngredients,
      context: contextData.context,
      mcid: this.mcid,
      Incident: ClipCopy,
      DescriptiveIncident: this.DescriptiveIncident,
    };
    // and puts it on the corresponding context key
    this.contexts[contextData.clipId] =
      incidentFromIngredients(ingredientsToPass);
    if (forceGetContext) {
      this.contexts[contextData.clipId]._onGetContextOnce();
    }
  }

  // eslint-disable-next-line no-unused-vars
  handleAddContext(target, payload) {
    this.addContext(payload, true);
    return true;
  }

  // eslint-disable-next-line no-unused-vars
  handleContextLoaded(target, payload) {
    this._onGetContextOnce();
  }

  getIncidentsByChannel = getIncidentsByChannel.bind(this);

  // massive editing methods that apply the request massively to all of the
  // Incidents of all of the contexts
  gotContext() {
    for (const context in this.contexts) {
      this.contexts[context].gotContext();
    }
  }

  _onGetContextOnce() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }
    for (const context in this.contexts) {
      this.contexts[context]._onGetContextOnce();
    }
  }

  lastWish() {
    for (const context in this.contexts) {
      this.contexts[context].lastWish();
    }
  }

  onGetContext() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }
    for (const context in this.contexts) {
      this.contexts[context].onGetContext();
    }
  }
}

export default ContextAwareClipIncident;
