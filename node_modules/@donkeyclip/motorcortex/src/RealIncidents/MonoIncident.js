/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Channel from '../Channels/Channel';
import helper, {
  getAnId,
  isObject,
  hasOwnProp,
  deepCopy,
} from '../_coreUtils/helper';
import getIncidentsByChannel from './helpers/getIncidentsByChannel';
/* @handleResize is missing from Incident. The reason is that when the
ExtendableClip asks for the under-resize candidates via the "checkResize" pipe
message the message will never be handled by an Incident directly but rather via
its corresponding ElementSplitter
*/
import setBlock from './helpers/block';
import unblock from './helpers/unblock';
import { _MC_Plugin_Name } from '../_configuration/_CONST';

/*
dna:
- originalId
- context
*/
class MonoIncident {
  constructor(attrs = {}, props = {}, dna) {
    this.attrs = attrs;
    this.props = props;
    this.dna = dna;

    this.context = dna.context;
    this.mcid = dna.mcid;

    this.id = props.id || getAnId();
    this.modelId = props.modelId;

    // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
    // is set to true so we prevent multiple executions of the onGetContext method
    this.gotContext = false;

    /*
      these are the default values that define channeling for the default Incidents. These values get ovewriden through
      the loadPlugin method of MC with the values found on the main.js file of the plugin
    */
    this.plugin_channel_class = Channel;
    this.mc_plugin_npm_name = _MC_Plugin_Name;
    if (hasOwnProp(props, 'plugin_channel_class')) {
      this.plugin_channel_class = props.plugin_channel_class;
    }
    if (hasOwnProp(props, 'mc_plugin_npm_name')) {
      this.mc_plugin_npm_name = props.mc_plugin_npm_name;
    }

    this.hasIncidents = false;

    /*
        initialValues is an object holding the automatically computed initial values of the animatedAttrs
        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to
        an AttributesChannel have initialValues).
        The keys set of this object is identical to the object attrs.animatedAttrs
        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
        of a specific element when there are no other Incidents entered on its lanes yet. These values are
        the "scratchValues" and they are strongly dependent on the nature of the lib. E.g. for a CSS animation
        what we are looking for can be found on the computedStyle.
        The initialValues are the values that are actually going to be used by
        the MonoIncident in the real execution of them
        */
    this.initialValues = {};

    /*
        The initial values defined by the user via the initialValues key on the
        attributes (if present)
        */
    this.userDefinedInitialValues = attrs.initialValues || {};

    /*
      The initialValues of the Incident as passed by the Attribute Channel.
      These values are been altered by the userDefinedInitialValues (if any)
      but we need them for passing them on other Incidents on edit and delete operations
    */
    this.pureInitialValues = null;

    /**
     * @member {boolean} - if autoGenerated is set to true, it means that this MonoIncident has been auto-generated by its parent on initialisation.
     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
     * on specific points on their timeline.
     */
    this.autoGenerated = false;

    if (hasOwnProp(this.attrs, 'animatedAttrs')) {
      this.attributeKey = Object.keys(this.attrs.animatedAttrs)[0];
    }
    this.onInitialise();
  }

  get selector() {
    return this.props.selector;
  }

  /* shortcuts for attrs.attrs and attrs.animatedAttrs */
  get animAttributes() {
    return this.attrs.animatedAttrs;
  }

  set animAttributes(value) {
    this.attrs.animatedAttrs[this.attributeKey] = value;
  }

  /**
    This method shoudl be overwritten by the Incidents of the plugins. The method returns
    the initial value that the element of it has as the library calculates / defines them. The
    returned value represents the very initial value of the element's attribute before
    any Incident that alters it gets added.

    @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
    of the Clip gets rendered
    */
  getScratchValue() {
    return 0;
  }

  get element() {
    if (this.context === null) {
      return [];
    }
    if (this.context.getElementByMCID) {
      return this.context.getElementByMCID(this.mcid);
    }
    return this.context.getElements(this.selector)[0];
  }

  // get attributeKey() {
  //   return Object.keys(this.attrs.animatedAttrs)[0];
  // }

  get targetValue() {
    return this.animAttributes[this.attributeKey];
  }

  getElementAttribute(attr) {
    return this.element.getAttribute(attr);
  }

  getFraction(ms) {
    return ms / this.props.duration;
  }

  getIncidentsByChannel = getIncidentsByChannel.bind(this);

  hasUserDefinedInitialValue() {
    return hasOwnProp(this.userDefinedInitialValues, this.attributeKey);
  }

  setInitialValue(value, storePure = true) {
    if (storePure) {
      this.pureInitialValues = deepCopy(value); // keep a copy of the
      // passed initial values
    }

    if (!this.hasUserDefinedInitialValue()) {
      this.initialValues[this.attributeKey] = value;
      return;
    }

    if (isObject(this.targetValue)) {
      // if it is a combo attribute
      for (const key in this.userDefinedInitialValues[this.attributeKey]) {
        value[key] = this.userDefinedInitialValues[this.attributeKey][key];
      }
      this.initialValues[this.attributeKey] = value;
      return;
    }
    this.initialValues[this.attributeKey] =
      this.userDefinedInitialValues[this.attributeKey];
  }

  get initialValue() {
    return this.initialValues[this.attributeKey];
  }

  _onGetContextOnce() {
    // if the MonoIncident belongs to a fragmented context there absolutely
    // no reason to run the getContext method of it
    try {
      if (this.context.fragment === true) {
        return;
      }
      if (!this.gotContext) {
        this.onGetContext();
        this.gotContext = true;
      }
    } catch (e) {
      helper.error(e);
      helper.error(this.mcid);
    }
  }

  onGetContext() {
    helper.info(
      'Overwrite the "onGetContext" method with the code you want to get executed',
      'info',
    );
  }

  lastWish() {}

  onInitialise() {
    helper.info(
      'Overwrite the "onInialise" method with the code you want to get executed',
      'info',
    );
  }

  /**
   * Method called on progress of the timed incident.
   * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   */
  // eslint-disable-next-line no-unused-vars
  onProgress(milliseconds) {}

  setBlock = setBlock.bind(this);

  unblock = unblock.bind(this);
}

export default MonoIncident;
