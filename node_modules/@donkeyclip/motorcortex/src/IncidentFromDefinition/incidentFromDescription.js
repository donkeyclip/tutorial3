/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/* eslint-disable sonarjs/cognitive-complexity */

import Channel from '../Channels/Channel';
import ElementClipSplitter from '../RealIncidents/Splitters/ElementClipSplitter';
import ElementSplitter from '../RealIncidents/Splitters/ElementSplitter';
import ElementComboSplitter from '../RealIncidents/Splitters/ElementComboSplitter';
import incidentFromIngredients from './incidentFromIngredients';
import { hasOwnProp } from '../_coreUtils/helper';

/**
 * Creates a real Incident (with all of its real tree) out of the Descriptive Incident.
 * @param {object} descriptiveIncident - the Descriptive Incident that defines the Incident
 * @param {contextData} - the context data (object containing id and actual context) to be used for real
 *      Incidents init
 * @returns {object} - the real Incident
 * */
function incidentFromDescription(descriptiveIncident, contextData) {
  /*
  RULES:
  - Clips can only have selectors (and not hosts) as they participate on a Desc. TimedTree
      and thus they are Clips As Incidents. The DescriptiveClips are treated a bit
      different compared to the rest of the Incidents as they copy all of the
      Description channels and lanes
  - Descriptive Incidents can either have or not have selectors
  - Descriptive Compos always have selectors

  All Incidents of the tree, no matter their type have the static properties:
  - Incident (which is the Incident class they need to initialise)
  - plugin_npm_name (the plugin name they bolong to)
  - Channel (the Channel class to handle the instance)
  */

  /* check for the descriptive incident and audio compatibility. If audio is true then we're
    working on the audioClip and we need incidents that are at least "on" while if the audio==false
    and we are working on the real tree then we reject the cases that the incident is audio "only".
    This check is targeting the top-level Incidents, the Clips, which are the ones that have the
    "audio" property.
  */

  const audio = contextData.context.audio;

  /*
  if it is on audio context and descriptive incident's audio cpabilities are set to "off"
  or if it's not on audio context and the descriptive incident is audio only
   */
  if (
    (!!audio && descriptiveIncident.audio === 'off') ||
    (!audio && descriptiveIncident.audio === 'only')
  ) {
    return null;
  }

  let incidentToReturn;
  /*
  if it has a selector and
    it's not audio context but the selector starts with "~"
    or we are on audio context and the selector doesn't start with "~"
      and the Incident is not a clip
   */
  if (
    hasOwnProp(descriptiveIncident.props, 'selector') &&
    ((!audio && descriptiveIncident.props.selector.charAt(0) === '~') ||
      (!!audio &&
        descriptiveIncident.props.selector.charAt(0) !== '~' &&
        !descriptiveIncident.constructor.isClip))
  ) {
    return null;
  }

  if (descriptiveIncident.constructor.isClip) {
    if (hasOwnProp(descriptiveIncident.props, 'selector') && !audio) {
      incidentToReturn = new ElementClipSplitter(
        descriptiveIncident,
        contextData,
      );
      incidentToReturn.plugin_channel_class = Channel;
    } else {
      // TODO This block needs review
      if (audio) {
        return descriptiveIncident.audioClip; // here we are
      }
      return descriptiveIncident.realClip;
    }
  } else if (descriptiveIncident.constructor.isCombo) {
    incidentToReturn = new ElementComboSplitter(
      descriptiveIncident,
      contextData,
    );
  }
  // else if (descriptiveIncident.constructor.Incident === Group) {
  else if (descriptiveIncident.constructor.isGroup) {
    incidentToReturn = incidentFromIngredients({
      id: descriptiveIncident.id,
      attrs: descriptiveIncident.attrs,
      props: descriptiveIncident.props,
      Incident: descriptiveIncident.constructor.Incident,
      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
      Channel: descriptiveIncident.constructor.Channel,
      DescriptiveIncident: descriptiveIncident,
    });

    for (const incId in descriptiveIncident.children) {
      const childIncident = incidentFromDescription(
        descriptiveIncident.children[incId].leaf,
        contextData,
      );
      if (childIncident === null) {
        continue;
      }
      incidentToReturn.addChild(
        childIncident,
        descriptiveIncident.children[incId].position,
      );
    }
  } else {
    // if it is an Incident that extends the Incident (not a Group) then
    // we should anaylse it to its element/attribute Incidents starting from
    // the elements, that's why we create an ElementSplitter. It is our
    // starting point to which the Incident will be analysed to its
    // element/attributes children.
    incidentToReturn = new ElementSplitter(descriptiveIncident, contextData);
  }

  return incidentToReturn;
}

export default incidentFromDescription;
