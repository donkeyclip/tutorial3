/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Group from '../../RealIncidents/Group';
import incidentFromDescription from '../../IncidentFromDefinition/incidentFromDescription';
import { _DIRECTIONS } from '../../TimedTree/_CONST';
import {
  hasOwnProp,
  systoleDiastoleProjections,
} from '../../_coreUtils/helper';

const selfContainedIncidentsNpmName = '@donkeyclip/self-contained-incidents';

function turnIntoReturnExecuteFunction(toReturnExecutables) {
  return function toReturnExecuteFunct() {
    for (let i = 0; i < toReturnExecutables.length; i++) {
      toReturnExecutables[i]();
    }
  };
}

/**
 * As its name implies, ExtendableClip's one and only use is to extend it in order
 * to create new Clip types. All channel handling, add / edit / remove / resize checks are
 * handled by ExtendableClip itself.
 * ExtendableClip's only need is the this.ownContext property to be defined. All
 * of the class's functionality is based on this object. The expected keys of this object
 * are the following:
 * {
 *  getElements()
 *  getMCID()
 *  setMCID()
 *  getElementSelectorByMCID()
 *  getElementByMCID()
 *  isHostedClip
 *  contextLoaded
 *  unmout()
 * }
 * Clips that extend ExtendableClip need to define this property ("this.ownContext")
 * on their constructor. ExtendableClip itself does NOT define this.ownContext and
 * thus it's not meant to be used alone/directly.
 **/
export default class ExtendableClip extends Group {
  /**
   * @param {object} attrs - an object with the attrs exactly as passed by the user to the HTMLDescriptiveClip
   * @param {object} props - an object that should contain all of the props passed to the HTMLDescriptiveClip plus:
   * - runTimeInfo: the runTimeInfo of its corresponding Descriptive Clip
   * @param {DescriptiveClip} DescriptiveIncident: the Descriptive Clip of the Clip, itself
   */
  constructor(attrs, props, DescriptiveIncident) {
    super(attrs, props);

    this.attrs = attrs;
    this.props = props;

    this.DescriptiveIncident = DescriptiveIncident;

    this.blockingWaitings = {};

    /**
     * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
     * this attribute is only valuable when the Group becomes the Clip
     * The format of the attribute is:
     *  key-value pairs in the manner:
     * <mc_plugin_npm_name>: Channel object
     */
    this.instantiatedChannels = {};

    this.isHostedClip = true;

    /**
     * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
     * contexts of all instantiated ClipCopies
     * */
    this.instantiatedCopiesContexts = {};

    this.onClipInitialise();

    this.runTimeInfo = this.props.runTimeInfo;

    this.durationSubs = [];
  }

  get contextReady() {
    return this.context.contextLoaded;
  }

  onClipInitialise() {
    // called when group gets initialised
  }

  /*********************************************************
    Context loading and the contextReady parameter
    *********************************************************
  There are cases that the Clip might need time in order to prepare its context,
  such as asynch sources loading. For this reason we use the contextReady parameter,
  which is set to true by default, and which can change state by the use of the two
  methods: contextLoading and contextLoaded.
  When contextLoading method is executed and the context gets to the loading state
  Incidents might be added to the Clip. While contextReady is set to false the
  onGetContext method of MonoIncidents and ClipCopies will be postponed and run when the context
  is actually loaded
  */
  contextLoading() {
    // this.contextReady is used on onProgress. If it's set to false it blocks the execution
    this.context.contextLoaded = false;
  }

  /**
   * This method will be invoked once the context (that is currently loading) has
   * finished loading. In case the Clip is been used as CAsI, ClipCopies might
   * have fired block() so they need to get unblocked. If so, the instantiatedCopiesUnblockingMethods
   * variable will contain the unblocking methods of them and the method will
   * execute them.
   **/
  contextLoaded() {
    this.context.contextLoaded = true;
    this.putMessageOnPipe(
      'contextLoaded',
      {},
      {},
      { selfExecute: false, direction: _DIRECTIONS._DOWN },
    );
    for (const key in this.instantiatedChannels) {
      this.instantiatedChannels[key].recalcScratchValues();
    }
    this.unblock(this.clipCopyId || null);
  }

  getElements(selector) {
    if (this.props.host !== null && this.props.host !== undefined) {
      return this.context.getElements(selector);
    }

    const elements = [];
    for (const contextKey in this.instantiatedCopiesContexts) {
      const contextElements =
        this.instantiatedCopiesContexts[contextKey].getElements(selector);
      for (let i = 0; i < contextElements.length; i++) {
        elements.push(contextElements[i]);
      }
    }
    return elements;
  }

  /**
   * This method is been called when a new _ClipCopy enters the real tree successfully.
   * @param {object} contextData - keys: clipId, context
   * */
  addContext(contextData) {
    this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
    contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
    return this.putMessageOnPipe(
      'addContext',
      contextData,
      {},
      { selfExecute: false, direction: _DIRECTIONS._DOWN },
    );
  }

  /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */
  exportConstructionArguments() {
    return {
      attrs: this.attrs,
      props: this.props,
    };
  }

  /**
   * completely resizes the Clip without any checks
   */
  _resize(durationFraction) {
    for (const key in this.instantiatedChannels) {
      this.instantiatedChannels[key]._resize(durationFraction);
    }
    this.setNewDuration(this.duration * durationFraction);
    for (let i = 0; i < this.durationSubs.length; i++) {
      this.durationSubs[i](this.duration);
    }
  }

  /** *******************************************************
    Editing commands input methods
    ******************************************************** */
  /**
   * This command is proxied form the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  incident: the Descriptive Incident to be added
   *  millisecond: the millisecond to add it
   *  targetGroupId: the id of the Group to which we want to the Incident to be placed
   * }
   */
  addIncident(payload) {
    const candidates = this.putMessageOnPipe(
      'addIncident',
      {
        incident: payload.incident,
        millisecond: payload.millisecond,
        incidentFromDescription: incidentFromDescription,
        contextData: {
          clipId: this.id,
          context: this.context,
          instantiatedCopiesContexts: this.instantiatedCopiesContexts,
        },
      },
      payload.parentGroupId,
      { selfExecute: true, direction: _DIRECTIONS._DOWN },
    );
    // concatenate candidates
    const totalIncidentsByPlugin = {};
    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(
        candidates[i].positionDelta + payload.millisecond,
      );
      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }
        totalIncidentsByPlugin[pluginName].push(
          ...incidentsByPlugin[pluginName],
        );
      }
    }

    const res = this.checkAddition(totalIncidentsByPlugin);
    if (res.result) {
      const successCallback = () => {
        res.execute();

        // up to that point the only context Incident that has been initialised on the
        // ContextAwareIncidents of the candidates is the original context of the
        // ExtendableClip.
        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.addChild(
            candidates[i].response,
            payload.millisecond,
          );

          // recalculate duration the groups that we added
          // the incidents to along with their parents
          candidates[i].responder.putMessageOnPipe(
            'recalcDuration',
            { childId: candidates[i].response.id },
            'Groups',
            {
              selfExecute: true,
              direction: _DIRECTIONS._UP,
            },
          );

          // we also need to add every existing (copied) context to the ContextAwareIncidents
          // created on the candidates process
          for (const contextKey in this.instantiatedCopiesContexts) {
            candidates[i].response.putMessageOnPipe(
              'addContext',
              {
                clipId: contextKey,
                context: this.instantiatedCopiesContexts[contextKey],
              },
              'ContextAwareIncidents',
              { selfExecute: false, direction: _DIRECTIONS._DOWN },
            );
          }
        }
      };
      return {
        result: true,
        execute: successCallback,
      };
    }
    return res;
  }

  // *******************************************************
  // INCIDENTS MANAGEMENT METHODS

  /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
  checkAddition(incidentsById, type = 'all-or-nothing') {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = [];

    // for each key of the incidentsById object perform the check
    for (const npmName in incidentsById) {
      // if the clip had no channel instantiated for the specific key (plugin id) yet create it
      if (!hasOwnProp(this.instantiatedChannels, npmName)) {
        // instantiate the channel of the plugin by using the reference to the class definition which can be found on
        // the Incidents of the plugin. Incidents of the plugin can be found easily here on incidentsById[npmName]
        // an array that holds all of them, and just take the info from the first (0 index), as it'll certainly exist

        const Channel = incidentsById[npmName][0].incident.plugin_channel_class;
        this.instantiatedChannels[npmName] = new Channel({
          runTimeInfo: this.runTimeInfo,
          context: this.context,
          subscribe: this.DescriptiveIncident.subscribe.bind(
            this.DescriptiveIncident,
          ), // all channels can subscribe to state or current millisecond changes. This is very useful for Channels
          // such as MediaPlayback as listening to state changes is mandatory to start or stop play. The only timer AND
          // the single source of truth in terms of the play state of a Clip in MC is the HTMLDescriptiveClip.
          // Thus we pass to the Channels a the subscribe method of HTMLDescriptiveClip itself so they have direct access
        });
      }

      // perform the check
      const pluginResult = this.instantiatedChannels[npmName].addIncidents(
        incidentsById[npmName],
        type,
      );
      toReturnResult = toReturnResult && pluginResult.result;
      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
      } else {
        toReturnExecutables.push(pluginResult.execute);
      }
    } // enf of iteration on the incidentsById keys

    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables),
    };
  }

  /**
   * This command comes form the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  incident: the Descriptive Incident to be repositioned
   *  millisecond: the new millisecond to put it
   *  targetGroupId: the id of the
   * }
   */
  moveIncident(payload) {
    const candidates = this.putMessageOnPipe(
      'moveIncident',
      {
        incidentId: payload.id,
        millisecond: payload.millisecond,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context,
        },
      },
      payload.parentGroupId,
      { selfExecute: true, direction: _DIRECTIONS._DOWN },
    );

    const totalIncidentsByPlugin = {};
    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(
        candidates[i].positionDelta + payload.millisecond,
      );
      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }
        totalIncidentsByPlugin[pluginName].push(
          ...incidentsByPlugin[pluginName],
        );
      }
    }

    const res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);
    if (res.result) {
      // eslint-disable-next-line no-inner-declarations
      function successCallback() {
        res.execute();
        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.editPosition(
            candidates[i].response.id,
            payload.millisecond,
          );

          // recalculate duration the groups that we added
          // the incidents to along with their parents
          candidates[i].responder.putMessageOnPipe(
            'recalcDuration',
            {},
            'Groups',
            {
              selfExecute: true,
              direction: _DIRECTIONS._UP,
            },
          );
        }
      }
      return {
        result: true,
        execute: successCallback,
      };
    }
    return res;
  }

  /**
   * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident
   * (edit of Incident's position given in milliseconds delta)
   * is valid and accepted, according to the rules defined on the channels.
   * The method boobles up until it reaches the Clip.
   * @param {object} incidentsById - the incident to edit, provided in an object by id
   * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
   The method should return either:
      {
          result:true,
          execute: // an array of functions that when executed it will edit the Incidents on the Channels
      }
      or
      {
          result: false,
          errors
      }
  */
  checkMove(incidentsById, millisecondsDelta) {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = [];

    // for each key of the incidentsById object perform the check
    for (const key in incidentsById) {
      // perform the check
      const pluginResult = this.instantiatedChannels[key].editIncidents(
        incidentsById[key],
        millisecondsDelta,
      );
      toReturnResult = toReturnResult && pluginResult.result;
      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
      } else {
        toReturnExecutables.push(pluginResult.execute);
      }
    } // enf of iteration on the incidentsById keys

    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables),
    };
  }

  removeIncident(payload) {
    const candidates = this.putMessageOnPipe(
      'removeIncident',
      {
        incidentId: payload.id,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context,
        },
      },
      payload.parentGroupId,
      { selfExecute: true, direction: _DIRECTIONS._DOWN },
    );

    const totalIncidentsByPlugin = {};
    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel();
      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }
        totalIncidentsByPlugin[pluginName].push(
          ...incidentsByPlugin[pluginName],
        );
      }
    }

    const res = this.checkDelete(totalIncidentsByPlugin);
    if (!res.result) {
      return res;
    }
    const successCallback = () => {
      res.execute();
      for (let i = 0; i < candidates.length; i++) {
        candidates[i].responder.removeChild(candidates[i].response.id);

        // recalculate duration the groups that we added
        // the incidents to along with their parents
        candidates[i].responder.putMessageOnPipe(
          'recalcDuration',
          {},
          'Groups',
          {
            selfExecute: true,
            direction: _DIRECTIONS._UP,
          },
        );
      }
    };
    return {
      result: true,
      execute: successCallback,
    };
  }

  /**
   * The checkDelete method serves exactly what its name implies. To check if the deletion of some Incidents
   * is valid and accepted, according to the rules defined on the channels.
   * @param {object} incidentsById - the incident to remove in an object, by id
    The result might be either:
      {
          result:true,
          execute: // an array of functions that when executed it will remove the Incident on the Channels
      }
      or
      {
          result: false,
          errors
      }
  */
  checkDelete(incidentsById) {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = [];

    // for each key of the incidentsById object perform the check
    for (const key in incidentsById) {
      // perform the check
      const pluginResult = this.instantiatedChannels[key].removeIncidents(
        incidentsById[key],
      );
      toReturnResult = toReturnResult && pluginResult.result;
      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        continue;
      }

      toReturnExecutables.push(pluginResult.execute);
    } // enf of iteration on the incidentsById keys

    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables),
    };
  }

  /**
   * This command is invoked by the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  id: the id of the Incident to resize
   *  newSize: the milliseconds of the new duration
   *  fraction: the division of the new duration to the current
   * }
   */
  resizeIncident(payload) {
    const candidates = this.putMessageOnPipe(
      'resize',
      {
        incidentId: payload.id,
        newSize: payload.newSize,
        fraction: payload.fraction,
        contextData: {
          clipId: this.id,
          context: this.context,
        },
      },
      payload.id,
      { selfExecute: false, direction: _DIRECTIONS._DOWN },
    );

    const totalIncidentsByPlugin = {};
    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(
        candidates[i].positionDelta,
      );
      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }
        totalIncidentsByPlugin[pluginName].push(
          ...incidentsByPlugin[pluginName],
        );
      }
    }

    let positionDelta = 0;
    if (candidates.length > 0) {
      positionDelta = candidates[0].positionDelta;
    }
    const res = this.checkResize(
      payload.fraction,
      totalIncidentsByPlugin,
      positionDelta,
    );
    if (res.result) {
      const successCallback = () => {
        res.execute();
        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.setNewDuration(payload.newSize);
        }
      };
      return {
        result: true,
        execute: successCallback,
      };
    }
    return res;
  }

  /**
   * checks if a duration edit is feasible and doesn't cause conflicts
   * @param {number} durationFraction - the duration fraction
   * @param {object} incidentsById - the Incidents to resize
   * @param {number} adjustMillisecond - a time adjustment very useful on repulsiveness
   * */
  checkResize(durationFraction, incidentsById, adjustMillisecond = 0) {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = [];
    // for each key of the incidentsById object perform the check
    for (const key in incidentsById) {
      // perform the check
      const adjustedIncidents = systoleDiastoleProjections(
        incidentsById[key],
        durationFraction,
        adjustMillisecond,
      );
      const pluginResult =
        this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
      toReturnResult &&= pluginResult.result;
      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        continue;
      }
      toReturnExecutables.push(pluginResult.execute);
    } // enf of iteration on the incidentsById keys

    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables),
    };
  }

  get context() {
    /*
    prevent possible bugs from clips that extend ExtendableClip
    and don't define contextLoaded = true
    on their constructor
    */
    this.ownContext.contextLoaded ??= true;
    return this.ownContext;
  }

  /**
   * Returns an object with keys the keys of all the plugins Incidents of which appear in the
   * tree of the Group. All Incidents are projected to the Group's timeline.
   * The array includes the Group's projection too
   */
  getIncidentsByChannel(adjustMillisecond = 0) {
    const incidentsByPlugin = {};
    incidentsByPlugin[selfContainedIncidentsNpmName] = [
      {
        millisecond: adjustMillisecond,
        incident: this,
        id: this.id,
      },
    ];

    return incidentsByPlugin;
  }

  setVolume(newVal) {
    this.volume = parseFloat(newVal);
  }

  /**
   * Eventual Clips have their own context, still they might belong to another Clip's
   * tree (CASI). In such a case this method gives the opportunity to set things up
   * and do operations related with their parent's context (such as subscribing to audio effect nodes)
   * */
  // eslint-disable-next-line no-unused-vars
  _onGetContextOnce(parentClipContext) {}

  // special recalcDuration handling so any potential clip copies update their trees
  // eslint-disable-next-line no-unused-vars
  handleRecalcDuration(target, payload) {
    if (this._calculateDuration(payload)) {
      for (let i = 0; i < this.durationSubs.length; i++) {
        this.durationSubs[i](this.duration);
      }
    }
    return true;
  }

  /**
   * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
   *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
   *      a reference to this Clip via their "realClip" property. Whenever any
   *      of these ClipCopies progresses (via the onProgress method) calls
   *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
   *      that will also progress via the Channels know which specific Incident to progress.
   *      That's the result of keeping just one real tree, belonging always to the realClip
   *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
   *      are the ones to hold the ClipCopies instances.
   * @param {boolean} forceReset - set to true in cases we want full flash of the state
   */
  onProgress(fraction, milliseconds, contextId, forceReset = false) {
    if (this.contextReady === false) {
      this.setBlock();
      return;
    }
    if (!contextId) {
      contextId = this.id;
    }
    for (const key in this.instantiatedChannels) {
      const channel = this.instantiatedChannels[key];
      channel.moveTo(
        this.runTimeInfo.currentMillisecond,
        milliseconds,
        contextId,
        forceReset,
      );
    }
  }

  /*
  Channels' moveTo method first two arguments define the start and end point of the time delta we want to execute so Channels can
  start their journey on their lanes and gradually calculate just the differences between the two time points and apply it.
  Normally, when a Clip is executed, the time difference is very small and only few diffs (if not none) are applied.
  flash() method of ExtendableClip gives the ability to recalculate the state of the full Clip from 0 to the current
  millisecond. This method is extremely useful (actually is mandatory) when editing a Clip (add / edit / remove / resize).
   */
  flash() {
    if (!this.contextReady) {
      return;
    }
    for (const key in this.instantiatedChannels) {
      const channel = this.instantiatedChannels[key];
      channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
    }
  }

  // duration changes pub/sub
  subscribeToDurationChange(method) {
    this.durationSubs.push(method);
  }

  /** ***************************************************** */
  /** ****** BLOCKING WAITINGS SET / REMOVE ************** */
  // eslint-disable-next-line no-unused-vars
  handleSetBlockingWaiting(target, payload) {}

  // eslint-disable-next-line no-unused-vars
  handleRemoveBlockingWaiting(target, payload) {}

  setCustomEntity(id, entity, classes = []) {
    return this.context.setCustomEntity(id, entity, classes);
  }
}
