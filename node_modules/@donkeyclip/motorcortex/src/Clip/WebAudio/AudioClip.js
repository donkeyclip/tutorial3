/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import ExtendableClip from '../_kit/ExtendableClip';
import { audioContext } from '../../_coreUtils/helper';
import AudioContextHandler from './AudioContextHandler';
import AudioNodeSet from './helpers/AudioNodeSet';
import { _DIRECTIONS } from '../../TimedTree/_CONST';

class AudioClip extends ExtendableClip {
  constructor(attrs, props) {
    super(attrs, props);

    // Our AudioNodeSet Class represents an audio routing graph of connected Nodes (pan->gain->master)
    // connected in this exact order. Our AudioNodeSet exposes the "input" and "output" props as well
    // as the "connect" method which connects it with a Web WebAudio API Node.
    this.audioNodeSet = new AudioNodeSet();
    // initially we connect our AudioNodeSet with the window.audioContext.destination
    // treating our AudioClip as root. This will change on the _onGetContextOnce method
    // which is only invoked if AudioClip is used as CASI. In this method the destination
    // changes to target the input of its parent node
    this.audioNodeSet.connect(audioContext.destination);
    const contextHandler = new AudioContextHandler(
      this.props.audioSources,
      this.audioNodeSet,
    );

    this.ownContext = {
      ...contextHandler.context,
      initParams: props.initParams,
    };
  }

  /**
   * As AudioClip does not accept a selector and does not get analysed to ContextAwareIncidents, the mechanism that
   * triggers recalcDuration to the parents does not get executed. For this we overwrite its parent's method so
   * whenever there is a change on the duration the parents get informed as well
   * @param target
   * @param payload
   */
  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);
    if (res) {
      this.putMessageOnPipe(
        'recalcDuration',
        payload.childId ? { childId: this.id } : {}, // only in additions there is childId which we should further apply
        'Groups',
        {
          selfExecute: false,
          direction: _DIRECTIONS._UP,
        },
      );
    }
  }

  onProgress(fraction, milliseconds, contextId, forceReset = false) {
    if (milliseconds > this.duration) {
      return super.onProgress(1, this.duration, this.id, forceReset);
    }

    const repeatDuration = this.delay + this.calculatedDuration + this.hiatus;
    // step 2.a: find the running repeat and millisecond of this repeat
    let millisecondWithinRepeat =
      repeatDuration === 0 ? 0 : milliseconds % repeatDuration;
    // step 2.b: decide between 0 and 1
    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = this.delay + this.calculatedDuration;
    }

    // step 3: find the millisecond of the MonoIncident
    let MI_millisecond = millisecondWithinRepeat - this.delay;
    if (MI_millisecond < 0) {
      return;
    }
    if (MI_millisecond > this.calculatedDuration) {
      // if it has stepped into hiatus
      MI_millisecond = this.calculatedDuration;
    }
    const MI_fraction =
      this.calculatedDuration === 0
        ? 0
        : MI_millisecond / this.calculatedDuration;

    super.onProgress(MI_fraction, MI_millisecond, this.id, forceReset);
    // super.onProgress(fraction, milliseconds, this.id, forceReset);
  }

  _onGetContextOnce(parentClipContext) {
    /*
        context.master {gain, pan, highpass, lowpass}
        */
    // as highpass is the first node of master in row

    this.audioNodeSet.disconnect();
    this.parentClipContext = parentClipContext;
    // the connect method of our AudioNodeSet expects a Web WebAudio API Node as input
    // parentClipContext.masterNode is the AudioNodeSet of the parent and thus on its "input"
    // property its Web WebAudio API input Node is exposed
    this.audioNodeSet.connect(parentClipContext.masterNode.input);
  }

  lastWish() {
    this.audioNodeSet.output.disconnect();
    // returns back to the root state
    this.audioNodeSet.output.connect(audioContext.destination);
  }

  get volume() {
    return this.audioNodeSet.output.gain.value;
  }

  setVolume(vol) {
    this.audioNodeSet.output.gain.value = vol;
  }
}

export default AudioClip;
