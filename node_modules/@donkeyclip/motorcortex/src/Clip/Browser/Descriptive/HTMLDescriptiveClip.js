/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import Channel from '../../../Channels/Clip/ClipsChannel';
import NonBlockingErrorClip from '../../../DescriptiveIncidents/helpers/NonBlockingErrorClip';
import Playable from '../../../DescriptiveIncidents/Playable';
import incidentFromIngredients from '../../../IncidentFromDefinition/incidentFromIngredients';
import { _DIRECTIONS } from '../../../TimedTree/_CONST';
import version from '../../../version';
import { clipPropsRule } from '../../../_configuration/propsValidationRules';
import { _CantBeResized } from '../../../_configuration/rejectionReasons';
import { validateObject } from '../../../_coreUtils/customValidator/_helpers';
import helper, {
  assignValueToPath,
  deepCopy,
  hasOwnProp,
  isFunction,
  validateProps,
} from '../../../_coreUtils/helper';
import AudioClip from '../../WebAudio/AudioClip';
import Clip from '../BrowserClip';
import OriginalCASIClip from '../OriginalCASIClip';
import NullClip from './helpers/NullClip';
import ClipClone from './helpers/RootClipClone';

function check(_this, func, payload) {
  const res = _this.realClip[func](payload);
  const audioRes = _this.audioClip[func](payload);
  if (!res.result || !audioRes.result) {
    // TODO: Shouldn't we return the result of the audioRes?
    return res;
  }

  res.execute();
  audioRes.execute();
  return _this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
    selfExecute: true,
    direction: _DIRECTIONS._UP,
  });
}

/**
 * Along with the expected props for the Clip on the props support the audio key.
 * The audio can take one of the 3 following values:
 * - "on": The Clip has audio enabled
 * - "off": The Clip has audio disabled
 * - "only": The Clip is only audio
 *
 * Also, in the case audio is on or only the user should pass the "audioSources"
 * key containing all the audio sources they want to pass on the WebAudio Context
 * of their clip. Please check AudioClip for details on the expected format
 * */
export default class HTMLDescriptiveClip extends Playable {
  // eslint-disable-next-line sonarjs/cognitive-complexity
  constructor(attrs, props = null) {
    let attrsToPass;
    let propsToUse;

    if (props === null) {
      attrsToPass = {};
      propsToUse = attrs;
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = attrs;
      propsToUse = props;
    }

    super(attrsToPass, propsToUse);

    // mustHaveNullClip is a property that gets true in the case the Clip is a CASI and on the same time
    // has @expression dynamic values either on its attrs or props
    this.mustHaveNullClip = false;

    this.initParams = propsToUse.initParams || {};
    // check if the Clip has initParamsValidationRules
    if (hasOwnProp(propsToUse, 'initParamsValidationRules')) {
      const ipValidation = validateObject(
        propsToUse.initParamsValidationRules,
        this.initParams,
        'Error on initParams validation',
      );
      if (!ipValidation.result) {
        helper.error(
          `Clip initParams validation failed. Switching to non-blocking blank Clip`,
        );
        return NonBlockingErrorClip(this, ipValidation.errors);
      }
    }

    const propsValidation = validateProps(
      { props: this.props },
      clipPropsRule,
      this.constructor,
      this.id,
    );
    if (!propsValidation.result) {
      return propsValidation;
    }

    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class.
    Similarly, propsStaggers hold the same info only this time for props
    */
    this.attributesStaggers = [];
    this.propsStaggers = [];

    const dynamicValuesReport = this.setupDynamicValues();

    // isTheRootClip defines whether the Clip is the root or not. It depends on
    // the host or selector parameter passed on props (if host is present then
    // the Clip is the root Clip while if the Clip gets initialised by a selector
    // is not)
    this.isTheRootClip = false;

    // a list of subscribers (functions) to volume change of the clip
    this.volumeChangeSubsribers = {};

    const ingredients = {
      id: this.id,
      attrs: attrsToPass,
      props: {
        ...propsToUse,
        html: hasOwnProp(propsToUse, 'html') ? propsToUse.html : this.html,
        css: hasOwnProp(propsToUse, 'css') ? propsToUse.css : this.css,
        fonts: hasOwnProp(propsToUse, 'fonts') ? propsToUse.fonts : this.fonts,
        runTimeInfo: this.runTimeInfo,
        subscribe: this.subscribe.bind(this),
        // cleanup any delay, hiatus and repeats
        repeats: 1,
        delay: 0,
        hiatus: 0,
      },
      plugin_npm_name: this.constructor.plugin_npm_name,
      Channel: this.constructor.Channel,
      DescriptiveIncident: this,
    };

    // Decide what kind of audio (or non-audio) Clip we are dealing with
    this.audio = 'on';
    if (hasOwnProp({ ...this.constructor }, 'audio')) {
      this.audio = this.constructor.audio;
    }
    if (hasOwnProp(propsToUse, 'audio')) {
      this.audio = propsToUse.audio;
    }

    // decide if this is the root clip
    if (
      // if it's a CASI of a BrowserClip then ingredients get OriginalCASIClip as Incident
      hasOwnProp(propsToUse, 'selector') &&
      propsToUse.selector !== undefined &&
      this.constructor.customClip !== true
    ) {
      ingredients.Incident = OriginalCASIClip;
      // TODO it doesn't take in account the get html and get css of the Descriptive Clip
    } else if (
      // if it's a CASI of a custom Clip then the technique of passing the Incident
      // it's different. We wrap it on a temporary FrgmentedClip and we position it in there
      hasOwnProp(propsToUse, 'selector') &&
      propsToUse.selector !== undefined &&
      this.constructor.customClip === true
    ) {
      delete ingredients.props.selector;
      const FragmentWrapper = new OriginalCASIClip({
        html: '<div id="clip-container"></div>',
        css: '',
        fonts: [],
      });
      ingredients.props.host = FragmentWrapper.rootElement;
      ingredients.Incident = this.constructor.Incident;
    } else if (
      // else if it's a root Clip but it's an WebAudio. No Incident is passed,
      // this case is not allowed
      this.audio === 'only' &&
      this.props.root !== true
    ) {
      // audioClips can never be the root
      this.isTheRootClip = false;
    } else {
      // finally, if it's a root (non-WebAudio) Clip we pass as Incident directly the
      // constructor defined by the Incident itself. No need for fragments here
      this.isTheRootClip = true;

      /*
            blockingWaitings are been triggered by Incidents when there is the
            need to halt the Clip's execution and wait. As an example a blocking
            waiting can be set by an WebAudio Playback Incident when the audio has
            not been loaded yet.
            Each blocking waiting has an id and via the same id the waiting can be
            unblocked.
            The blockingWaitings property of the root Clip is a collection with
            keys the blocking waitings ids and values the description of each waiting
            which consists of:
            {
                id
                description
                incidentId
            }
            The blocking waitings are triggered by real Incidents living on the real
            Clips of the Descriptive Clip (either the audioClip or the realClip).
            The root that a waiting set or unset follows is from any real incident
            up to its ContextAware Incident and from there
            up to the real Clip and from there to its DescriptiveTree and from there
            all the way up to the root Descriptive Clip.
            Blocking waitings must always be triggered on the "onProgress" or on
            the "play" methods of Incidents. Setting a blocking waiting from anywhere
            else is an error
            */
      this.blockingWaitings = {};

      ingredients.Incident = this.constructor.Incident;
    }

    // we initialise real and audio clips of the Clip by checking the static audio
    // property
    // the property this.audio helps incidentFromDescription identify if the Incident
    // participates or not on the audioClip. By default is "on" but if the props.audio is set to off
    // it turns to "off" so the DC gets totally ignored on the addition process on audio clip
    /* The audio value is set in the following manner
        - first we check if the Class has a static audio parameter and if yes we keep it
        - then we check if this.props has the audio key and if yes we keep this one
        - otherwise we use the default ("on")
    */
    /**************** AUDIO CLIP SETUP START ***********************/
    if (this.audio === 'on' || this.audio === 'only') {
      // if there are audioSources related dynamic values we need to initialise them right here and now
      const audioIngredients = {
        id: this.id,
        attrs: {},
        props: {
          audioSources: hasOwnProp(propsToUse, 'audioSources')
            ? propsToUse.audioSources
            : this.audioSources,
          runTimeInfo: this.runTimeInfo,
          subscribe: this.subscribe.bind(this),
          hiatus: this.hiatus,
          delay: this.delay,
          repeats: this.repeats,
          initParams: this.initParams,
        },
        plugin_npm_name: this.constructor.plugin_npm_name,
        Channel: this.constructor.Channel,
        Incident: AudioClip,
        DescriptiveIncident: this,
      };

      // in the case the audioSources contain @initParams we should resolve here using the initParams passed to the Clip
      if (hasOwnProp(propsToUse, 'audioSources')) {
        audioIngredients.props.audioSources = this.resolveAudioSources(
          propsToUse.audioSources,
        );
      }

      this.audioClip = incidentFromIngredients(audioIngredients);
    } else {
      this.audio = 'off';
      this.audioClip = new NullClip();
    }
    /**************** AUDIO CLIP SETUP END ************************/

    /**************** REAL CLIP SETUP START ***********************/
    if (this.audio === 'only') {
      // only audio means we should create a Null clip
      this.realClip = new NullClip();
    } else if (
      // if either attrs or props has at least one expression then we should create a
      // Null Clip instead of a OriginalCASIClip.
      // TODO check from more dynamic values and decide on their handling
      !this.isTheRootClip && // in the case of root clip we want to allow the use of dynamic values such as @initParams
      (hasOwnProp(dynamicValuesReport.attrs, 'expression') ||
        hasOwnProp(dynamicValuesReport.props, 'expression') ||
        hasOwnProp(dynamicValuesReport.attrs, 'initParams') ||
        hasOwnProp(dynamicValuesReport.props, 'initParams'))
    ) {
      this.mustHaveNullClip = true;
      this.realClip = new NullClip();
    } else {
      // happy path
      this.realClip = incidentFromIngredients(ingredients, true);
    }
    /**************** REAL CLIP SETUP END ************************/

    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */
    this.dynamicDurationValue = null;

    // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)
    this.passiveAddition = true;
    this._buildTree();
    this.passiveAddition = false;

    if (this.constructor.isAnimation && hasOwnProp(this.props, 'duration')) {
      this.resize(this.duration);
    }
  }

  static isClip = true;

  // a static member to help@donkeyclipDefinition identify clips
  static Incident = Clip;

  static plugin_npm_name = '@donkeyclip/self-contained-incidents';

  static version = version;

  static Channel = Channel;

  static ClassName = 'HTMLClip';

  static propsValidationRules = clipPropsRule;

  get selectorToPassToChildren() {
    return null; // the Clip (any Clip) resets the selection cascading
  }

  get inheritedSelector() {
    return this._inheritedSelector;
  }

  set inheritedSelector(value) {
    this._inheritedSelector = value;
  }

  get html() {
    return '';
  }

  get css() {
    return '';
  }

  get fonts() {
    return [];
  }

  get audioSources() {
    return [];
  }

  resolveAudioSources(audioSources) {
    const toReturn = deepCopy(audioSources);
    for (let i = 0; i < this.propsStaggers.length; i++) {
      const dvalue = this.propsStaggers[i];
      if (dvalue.path.indexOf('audioSources') === 0) {
        assignValueToPath(
          toReturn,
          dvalue.path.replace('audioSources.', ''),
          dvalue.stagger.calculateValues([0], this.initParams)[0],
        );
      }
    }
    return toReturn;
  }

  // we overwrite detachFromParent so we can reset the Clip's realClip to NullClip in the case
  // there are expressions present on its dymaicValues
  detachFromParent() {
    super.detachFromParent();
    if (this.mustHaveNullClip) {
      this.realClip = new NullClip();
    }
  }

  get duration() {
    /*
    if the duration of the Incident is dynamic (because of staggers) the dynamicDurationValue
    which is the real duration of the Incident as it's calculated after applying it in the
    real world is #1 choice and it represents the truth for this Incident
     */
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    }
    /*
    if there is no dynamicDurationValue but there are props staggers then the Incident
    should inform its user that its duration is dynamic and can't be calculated yet
    as there is no context to be applied. This should only apply to CASIs and not root
    Clips though as root Clips can accept only the @initParams dynamic value which is directly
    transformed to the value of the initParam
     */
    if (this.propsStaggers.length > 0 && !this.isTheRootClip) {
      return 'dynamic';
    }
    /*
    Otherwise if props.duration is set then calculate duration using it
     */
    if (hasOwnProp(this.props, 'duration')) {
      return this.repeats * (this.delay + this.props.duration + this.hiatus);
    }
    /*
    if none of this is true then pass the classic duration value as define on Node
    which is the real duration of the Incident based on the calculations on its
    children
     */
    return super.duration;
  }

  /*
  Overwrites set duration of Node in order to support stagger props
  */
  set duration(milliseconds) {
    if (this.propsStaggers.length == 0) {
      super.duration = milliseconds;
      return;
    }
    for (let i = 0; i < this.propsStaggers.length; i++) {
      if (this.propsStaggers[i].path === 'repeats') {
        continue;
      }
      const newStaggerExpression = this.propsStaggers[i].stagger.resize(
        milliseconds / this.duration,
      );
      assignValueToPath(
        this.props,
        this.propsStaggers[i].path,
        newStaggerExpression,
      );
    }
    this.dynamicDurationValue = milliseconds;
  }

  /*
  systoleDiastole (which is defined in Node) is a method that is called by parent Groups
  to its children whenever they get resized. DescriptiveClips (when used as Animations)
  have the characteristic that they need to store the resize to their props as this is
  exportable and considered as the source of truth when it comes to their duration
   */
  systoleDiastole(durationFraction) {
    if (this.constructor.isAnimation) {
      if (!this.props.duration) {
        this.props.duration = durationFraction * this.calculatedDuration;
      } else {
        this.props.duration *= durationFraction;
      }
    }
    this.realClip._resize(durationFraction);
    super.systoleDiastole(durationFraction);
  }

  exportLiveDefinition(includeId = true) {
    let def = super.exportLiveDefinition(includeId);
    // we add duration on props
    if (this.constructor.isAnimation) {
      def.props.duration = this.props.duration
        ? this.props.duration
        : this.calculatedDuration;
    }
    if (isFunction(this.props.html)) {
      def.props.html = this.props.html;
    }
    if (isFunction(this.props.css)) {
      def.props.css = this.props.css;
    }
    return def;
  }

  /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */
  _buildTree() {
    if (this.realClip === undefined) {
      return;
    }
    this.buildTree();
  }

  /**
   * When the resize command is given directly to a HTMLDescriptiveClip no checks
   * need to be performed.
   * HTMLDescriptiveClip directly invokes the _resize method of ExtendableClip which
   * resizes the full clip
   */
  resize(newSize) {
    if (this.duration === 'dynamic') {
      return {
        result: false,
        reason: _CantBeResized,
      };
    }

    const scale = newSize / this.duration;

    this.realClip._resize(scale);
    this.audioClip._resize(scale);

    this.duration = newSize;
    // update this.props.duration accordingly
    if (this.constructor.isAnimation) {
      if (!this.props.duration) {
        this.props.duration = this.calculatedDuration;
      } else {
        this.props.duration *= scale;
      }
    }

    this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    });

    return this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
      selfExecute: true,
      direction: _DIRECTIONS._UP,
    });
  }

  // eslint-disable-next-line no-unused-vars
  manageEditAttrProps(newAttrs, type) {
    return {
      result: false,
      errors: ['Clips attributes and properties can not be edited'],
    };
  }

  /** ************************* HANDLING METHODS ****************************** */
  // eslint-disable-next-line no-unused-vars
  handleCheckForClip(target, payload) {
    return true;
  }

  handleGetElements(target, payload) {
    return this.realClip.getElements(payload.selector);
  }

  handleCheckAddition(target, payload) {
    /* Is the responsibility of the HTMLDescriptiveClip to pass the addition request
        to its real clip and expect for a response.
     Before doing so, and only in the case of CASI, our DescriptiveClip will temporarily render the contents of the Clip
     on DOM so all initial values and everything else can be properly calculated and after the end of the process it will
     remove it from the DOM
   */
    if (
      !this.isTheRootClip &&
      this.audio !== 'only' &&
      this.constructor.customClip !== true
    ) {
      this.realClip.renderOnDOM();
    }

    let res = this.realClip.addIncident(payload);
    const audioRes = this.audioClip.addIncident(payload);
    if (res.result && audioRes.result) {
      res.execute();
      audioRes.execute();
      res = this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      });
    }
    if (
      !this.isTheRootClip &&
      this.audio !== 'only' &&
      this.constructor.customClip !== true
    ) {
      this.realClip.removeFromDOM();
    }
    return res;
  }

  handleCheckMove(target, payload) {
    return check(this, 'moveIncident', payload);
  }

  handleCheckDeletion(target, payload) {
    return check(this, 'removeIncident', payload);
  }

  handleCheckResize(target, payload) {
    return check(this, 'resizeIncident', payload);
  }

  // eslint-disable-next-line no-unused-vars
  handleFlash(target, payload) {
    if (!this.isTheRootClip) {
      return this.bypass();
    }
    this.flash();
  }

  /**
   * We overwrite exportDefinition of Groups so we add duration on the props
   * of the Clip
   */
  exportDefinition() {
    const toReturn = super.exportDefinition();
    if (this.constructor.isAnimation) {
      // only to Animations imported from plugins
      toReturn.props.duration = this.props.duration
        ? this.props.duration
        : this.calculatedDuration;
    }
    return toReturn;
  }

  /** **************** BLOCKING WAITINGS HANDLING ************************* */
  /** ******************************************************************** */
  handleSetBlock(target, payload) {
    // only accepts blocks if is the root clip and if it's playing
    if (this.isTheRootClip) {
      if (this.runTimeInfo.state === 'transitional') {
        return;
      }

      if (this.runTimeInfo.state !== 'blocked') {
        this.statusBeforeBlock = this.runTimeInfo.state;
      }

      this.blockingWaitings[payload.id] = payload;
      const options = {};
      if (payload.options.exceptional) {
        options.exception = payload.incidentId;
      }

      // We do setTimeout here because we want the block command to run after each and
      // every onProgress already scheduled to run
      const that = this;
      setTimeout(() => {
        that.block(options);
      }, 0);
    } else {
      return this.bypass();
    }
  }

  handleUnBlock(target, payload) {
    if (this.isTheRootClip) {
      if (hasOwnProp(this.blockingWaitings, payload.id)) {
        delete this.blockingWaitings[payload.id];
        if (Object.keys(this.blockingWaitings).length === 0) {
          if (this.statusBeforeBlock === 'playing') {
            this.previousTimeStamp = -1;
            this.play();
          } else {
            this.arm();
          }
        }
      }
    } else {
      return this.bypass();
    }
  }

  /* empty blocking waitings on transition start */
  stop() {
    super.stop();
    this.blockingWaitings = {};
  }

  /** ******************************************************************** */
  /** ******************************************************************** */

  onProgress(fraction, millisecond) {
    // fraction represents the fraction of the overall Descriptive Clip which equals the max duration between
    // realClip duration and audioClip duration
    // TODO we need to adjust the fraction here as the two clips might have different duration. The system works because the implemented Clips only use millisecond
    this.realClip.onProgress(fraction, millisecond);
    this.audioClip.onProgress(fraction, millisecond);
  }

  /** ********************************************************** */
  paste(host) {
    if (this.isTheRootClip) {
      return new ClipClone({
        host,
        descriptiveIncident: this,
      });
    }
    return null;
  }

  flash() {
    this.realClip.flash();
    this.audioClip.flash();
  }

  get volume() {
    if (this.audio === 'off') {
      return 0;
    }

    return this.audioClip.volume;
  }

  /**
   *
   * @param {number} vol: a number from 0 to 1
   * @returns {{result: boolean}|{result: boolean, errors: [{type: string}]}}
   */
  setVolume(vol) {
    if (vol < 0 || vol > 1) {
      return {
        result: false,
        errors: [
          {
            type: 'invalid volume number',
          },
        ],
      };
    }
    if (this.audio === 'off') {
      return {
        result: false,
        errors: [
          {
            type: 'can not set volume of Clip with audio off',
          },
        ],
      };
    }

    this.audioClip.setVolume(vol);

    for (const id in this.volumeChangeSubsribers) {
      this.volumeChangeSubsribers[id](vol);
    }
    return { result: true };
  }

  // AUDIO RELATED METHODS
  // TODO there might might the need of detaching attached audioNodes from audioNodeSet on incident deletion
  /**
   * This method provides the ability to attach MediaElementAudioSourceNodes to the DI's audioClip's input
   * The method is mainly used by BrowserClips that have some kind of audio output which should be heard on playback
   * (such as the VideoClip of the video plugin)
   * @param {MediaElementAudioSourceNode} source
   */
  attachMediaElementSource(source) {
    if (this.audio === 'off') {
      return;
    }

    this.audioClip.context.audioContext
      .createMediaElementSource(source)
      .connect(this.audioClip.context.masterNode.input);
  }

  // The following two methods subscribe and unsubscribe callbacks to volume change event.
  // This is particularly useful for autonomous sound sources
  /**
   *
   * @param {string} id: the unique subscription id
   * @param {function} funct: the callback function to listen to volume changes
   */
  volumeChangeSubscribe(id, funct) {
    return this.putMessageOnPipe(
      'volumeChangeSubscribe',
      { type: 'subscribe', id, funct },
      'RootClip',
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    ).response;
  }

  volumeChangeUnsubscribe(id) {
    this.putMessageOnPipe(
      'volumeChangeSubscribe',
      { type: 'unsubscribe', id },
      'RootClip',
      {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      },
    );
    return 0;
  }

  handleVolumeChangeSubscribe(target, payload) {
    if (!this.isTheRootClip) {
      return this.bypass();
    }

    switch (payload.type) {
      case 'subscribe':
        this.volumeChangeSubsribers[payload.id] = payload.funct;
        return this.volume;
      case 'unsubscribe':
        delete this.volumeChangeSubsribers[payload.id];
        return 0;
    }
    return false;
  }
}
