/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import ExtendableClip from '../_kit/ExtendableClip';
// context handlers
import IframeContextHandler from './contextHandlers/IframeContextHandler';
import WebComponentContextHandler from './contextHandlers/WebComponentContextHandler';

/**
 * It's the Browser version of a MotorCortex Clip. BrowserClip extends ExtendableClip and, as
 * it should, it defines its ownContext on its constructor (see ExtendableClip
 * for details re this.ownContext property). Also, it renders itself either on
 * iframe or via shadow Browser, depending on browser support.
 * BrowserClip, via the use of the customEntities, provided by ExtendableClip, can be
 * used to create other kinds of Clips (not HTML/Browser), such as webGL that all run on
 * the browser, on a given Browser elment should be implemented by extending this Class.
 * The rest can be handled by customEntities, check on documentation how to use them.
 * For Clips that do not live on the browser developers can extend ExtendableClip,
 * follow the paradigm of BrowserClip and create a Clip for a totally different platform.
 *
 **/
class BrowserClip extends ExtendableClip {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameters that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  constructor(attrs = {}, props = {}, DescriptiveIncident) {
    super(attrs, props, DescriptiveIncident);
    props = {
      ...props,
      html: this.html !== '' ? this.html : props.html,
      css: this.css !== '' ? this.css : props.css,
      fonts: this.fonts.length > 0 ? this.fonts : props.fonts,
    };

    // that means the Clip is hosted or, in other words a host has been
    // provided on the props (and not a selector)
    // this.isHostedClip = true;

    let ContextHandler = null;

    if (document.head.createShadowRoot || document.head.attachShadow) {
      ContextHandler = WebComponentContextHandler;
    } else {
      ContextHandler = IframeContextHandler;
    }

    const contextHandler = new ContextHandler(props);

    this.ownContext = {
      ...contextHandler.context,
      initParams: props.initParams,
    };
    this.iframe = contextHandler.iframeElement;

    this.onAfterRender();
  }

  onAfterRender() {
    // implement here
  }

  // this getter can be overwritten by plugins developers when extending the BrowserClip. This html is going to be the
  // html that will be rendered
  get html() {
    return '';
  }

  // this getter can be overwritten by plugins developers when extending the BrowserClip. This css is going to be the
  // css that will be rendered
  get css() {
    return '';
  }

  // this getter can be overwritten by plugins developers when extending the BrowserClip. The fonts are going to be the
  // fonts that will be loaded
  get fonts() {
    return [];
  }

  get rootElement() {
    return this.context.rootElement;
  }

  /**
   * exportConstructionArguments is a method already defined and provided by ExtendableClip.
   * Though BrowserClip overwrites it as it wants the exportedConstructionArguments to reflect
   * the changes already made on the actual DOM.
   * @return {{attrs: Object, props: (*&{host: undefined, html: (string|*)})}}
   */
  exportConstructionArguments() {
    // TODO also export CSS and fonts taking in account the potential existence
    // of them on the get methods
    return {
      attrs: this.attrs,
      props: {
        ...this.props,
        host: undefined,
        /*
        all custom Clips defined in plugins (as classes extending the BrowserClip) are marked
        on their constructor (as static variable) as custom clips (customClip = true).
        Custom BrowserClips should always export blank html as most of the time this
        html is produced in the onAfterRender method which runs on clip copies
        */
        html:
          this.DescriptiveIncident.constructor.customClip === true
            ? ''
            : this.context.rootElement.innerHTML,
      },
    };
  }
}

export default BrowserClip;
