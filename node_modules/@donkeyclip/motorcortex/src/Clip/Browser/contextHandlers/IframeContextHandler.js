/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/*
iframe[seamless]{
    background-color: transparent;
    border: 0px none transparent;
    padding: 0px;
    overflow: hidden;
}

might need more work for IE. See here: https://stackoverflow.com/a/29209248
*/

import { hasOwnProp } from '../../../_coreUtils/helper';
import DOMContextHandler from './DOMContextHandler';
import compileHTML from './helpers/compileHTML';
import { addCSSToNode } from './helpers/css';
import createFontTag from './helpers/fontsLoader';

const iframeCSSID = '@donkeyclip/motorcortex/iframeContextHandler/css';

class IframeContextHandler extends DOMContextHandler {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  constructor(props = {}) {
    super(props);

    const { ownerDocument } = props.host;

    if (!ownerDocument.getElementById(iframeCSSID)) {
      const seamlessCSS = `iframe[seamless]{background-color:transparent;border:0 none transparent;padding:0;overflow: hidden;}`;
      const iframesCSS = ownerDocument.createElement('style');
      iframesCSS.id = iframeCSSID;
      addCSSToNode(iframesCSS, seamlessCSS, ownerDocument);
      (
        ownerDocument.head || ownerDocument.getElementsByTagName('head')[0]
      ).appendChild(iframesCSS);
    }

    // Create an iframe:
    const iframe = ownerDocument.createElement('iframe');
    props.host.appendChild(iframe);
    const scale = this.scalingCalculator(props);

    const clipDims = this.calcClipDims(props);

    iframe.setAttribute('seamless', 'seamless');
    if (clipDims.use === true) {
      if (clipDims.width !== null) {
        iframe.setAttribute('width', clipDims.width);
      }
      if (clipDims.height !== null) {
        iframe.setAttribute('height', clipDims.height);
      }
    }

    iframe.style.transform = `scale(${scale.width}, ${scale.height})`;
    iframe.style.transformOrigin = 'top left';
    iframe.style.position = 'absolute';

    // Initialise the iframe
    iframe.src = '';
    // Put it in the document (but hidden):
    let iframeDocument = iframe.contentWindow || iframe.contentDocument;
    if (iframeDocument.document) {
      iframeDocument = iframeDocument.document;
    }

    iframeDocument.write(compileHTML(props.html, props.initParams, true));
    const css = `${compileHTML(
      props.css,
      props.initParams,
    )}body{padding:0;margin:0;}`;

    const styleTag = iframeDocument.createElement('style');
    addCSSToNode(styleTag, css, ownerDocument);

    const head =
      iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];
    head.appendChild(styleTag);

    if (hasOwnProp(props, 'fonts')) {
      for (let i = 0; i < props.fonts.length; i++) {
        const theFont = props.fonts[i];
        const fontTag = createFontTag(iframeDocument, theFont);
        head.appendChild(fontTag);
      }
    }

    this.rootElement = iframe;
    iframeDocument.close();

    this.setContext({
      document: iframeDocument,
      window: iframe.contentWindow || iframe,
      clipContainer: iframe,
      rootElement: iframeDocument.body,
      unmount() {
        props.host.removeChild(iframe);
      },
    });
  }
}

export default IframeContextHandler;
