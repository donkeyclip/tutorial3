/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/*
iframe[seamless]{
    background-color: transparent;
    border: 0px none transparent;
    padding: 0px;
    overflow: hidden;
}
might need more work for IE. See here: https://stackoverflow.com/a/29209248
*/

import helper, { hasOwnProp } from '../../../_coreUtils/helper';
import DOMContextHandler from './DOMContextHandler';
import compileHTML from './helpers/compileHTML';
import { addCSSToNode } from './helpers/css';
import createFontTag from './helpers/fontsLoader';

const mcContainerDataAttr = 'data-motorcortex-container';

class WebComponentContextHandler extends DOMContextHandler {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  constructor(props = {}) {
    super(props);

    /*
    We will construct the following structure:
    this.targetHost  context.clipContainer  (= in the case of a fragmented clip is a div we create in the memory. In the
                                            case of a WCCH (this) it's the provided host from the props (props.host))
    #shadow          -                      the shadow root of the targetHost
    wrapper          context.rootElement    the container of the Clip itself. Both clipDims AND scale are applied to
                                            this element. The logic is simple, clipDims define the pixels of the
                                            wrapper while the scale its scale. There are plenty of originalDims /
                                            containerParams combinations covered here.
    */

    const wrapper = document.createElement('div');
    this.styleWrapper(wrapper, this.props);
    wrapper.innerHTML = compileHTML(props.html, props.initParams, true);
    this.rootElement = wrapper;

    // if shadow root is not yet implemented, implement it
    let shadow = this.targetHost.shadowRoot;
    if (!shadow) {
      shadow = this.targetHost.attachShadow({ mode: 'open' });
    }

    // append wrapper into the shadow
    shadow.appendChild(wrapper);
    const slotElement = document.createElement('slot');
    shadow.appendChild(slotElement);

    // append style tag into the shadow
    const styleTag = document.createElement('style');
    addCSSToNode(
      styleTag,
      `${
        styleTag.styleSheet
          ? '[' + mcContainerDataAttr + '] { all: initial; }'
          : ''
      }${compileHTML(props.css, props.initParams)}`,
      document,
    );

    shadow.appendChild(styleTag);

    // append fonts into document
    this.fontTags = [];
    if (hasOwnProp(props, 'fonts')) {
      for (let i = 0; i < props.fonts.length; i++) {
        const theFont = props.fonts[i];
        const fontTag = createFontTag(document, theFont);
        document.getElementsByTagName('head')[0].appendChild(fontTag);
        this.fontTags.push(fontTag);
      }
    }

    this.setContext({
      contextLoaded: true,
      document,
      window,
      clipContainer: this.targetHost,
      rootElement: wrapper,
      unmount() {
        try {
          shadow.innerHTML = '';
          for (let i = 0; i < this.fontTags.length; i++) {
            document
              .getElementsByTagName('head')[0]
              .removeChild(this.fontTags[i]);
          }
        } catch (er) {
          helper.warning(
            'The element of the Clip to be removed seems not to exist any more',
          );
        }
      },
    });
  }

  styleWrapper(wrapper, props) {
    const scale = this.scalingCalculator(props);
    const clipDims = this.calcClipDims(props);

    wrapper.setAttribute(mcContainerDataAttr, 'true');

    if (clipDims.use === true) {
      if (clipDims.width !== null) {
        wrapper.style.width = clipDims.width;
      }
      if (clipDims.height !== null) {
        wrapper.style.height = clipDims.height;
      }
    }
    wrapper.style.transform = `scale(${scale.width}, ${scale.height})`;
    wrapper.style.transformOrigin = 'top left';
    wrapper.style.position = 'absolute';
    wrapper.style.overflow = 'hidden';
  }

  unstyleWrapper(wrapper) {
    while (wrapper.attributes.length > 0) {
      wrapper.removeAttribute(wrapper.attributes[0].name);
    }
    wrapper.setAttribute(mcContainerDataAttr, true);
  }

  get targetHost() {
    return this.props.host;
  }
}

export default WebComponentContextHandler;
