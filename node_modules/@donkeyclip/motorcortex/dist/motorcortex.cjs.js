'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var exprEval = require('expr-eval');
var bezeasing = require('bezier-easing');
var Validator = require('fastest-validator');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var bezeasing__default = /*#__PURE__*/_interopDefaultLegacy(bezeasing);
var Validator__default = /*#__PURE__*/_interopDefaultLegacy(Validator);

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/*
known events:
- state-change / meta: the name of the new state
- attribute-rejection / meta: animationID, attributes
- animation-rejection / meta: animationID
- conflicts-on-edit
*/
const logTypes = [{
  key: 'info',
  style: 'color:#666;',
  level: 5,
  consoleMethod: 'log'
}, {
  key: 'notice',
  style: 'background:rgba(0,0,0,0.8);color:white;padding:8px;',
  level: 4,
  consoleMethod: 'log'
}, {
  key: 'warning',
  style: 'color:black;background:orange;',
  level: 2,
  consoleMethod: 'warn'
}, {
  key: 'error',
  style: 'color:black;background:red;',
  level: 1,
  consoleMethod: 'error'
}];
const lanesMCIDattrsSeparator = '___';
const elementsDataAttributeName = 'data-motorcortex2-id';
const logLevel = 2;
const mcNameSpace = 'MotorCortex';
const dynamicValuesTerms = {
  dynamicDuration: 'dynamic',
  totalElements: 'total',
  elementIndex: 'index',
  initParams: 'initParams'
};
/**
 * when a dynamic value validation method is been defined it has the checkValues method available. This method takes an
 * array of values to be checked against the original schema of the property. Long story short, when a dv gets validated
 * by the provided validation method of the dv implementation the developer has the chance to extract any values out of
 * the provided expression and check them against the original schema of the field. (e.g. on @stagger(0px, 200px) the
 * developer will call checkValues(["0px", "200px"]) which will check both values against the original schema of the field
 * (e.g. it'll check for min, max, units etc).
 * The way MC supports dv implementation is via strings and this check can only occur for very specific field types, or
 * to put it another way, it can't support specific field types. This property holds the list of NOT supported field
 * types.
 * @type {*[]}
 */

const unsupportedDVTypesSchemaCheck = ['object', 'array', 'any', 'boolean', 'class', 'tuple'];

var _window;

(_window = window).AudioContext || (_window.AudioContext = window.webkitAudioContext);
const audioContext = new window.AudioContext();
function isInteger(number) {
  return number === parseInt(number, 10);
}
function isNumber(value) {
  return typeof value === 'number' && isFinite(value);
}
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function isString(test) {
  return typeof test === 'string' || test instanceof String;
}
function isObject(test) {
  return typeof test === 'object';
}
function isFunction(functionToCheck) {
  return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
}
function hasOwnProp() {
  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (prop === null || !isObject(obj)) {
    return false;
  }

  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function deepCopy(value) {
  return JSON.parse(JSON.stringify(value));
}
function jsUcfirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
const numberPartRegexp = /^[+-]?(\d+([.]\d*)?|[.]\d+)/gi;
/**
 * A function that takes an object and a key an extracts the number
 * and the unit from the value of the key, returns null if the value isn't
 * properly formatted or if the key doesn't exist
 * @typedef {Object} ObjectWithNumberAndUnits
 * @property {number} number - The number of the value
 * @property {string} unit- The unit of the value
 * @param  {object} object
 * @param  {string} key
 * @returns {(null|ObjectWithNumberAndUnits)}
 */

function extractNumberValueFromObject(object, key) {
  const value = object === null || object === void 0 ? void 0 : object[key];

  if (!isString(value)) {
    return null;
  }

  let number = value.match(numberPartRegexp)[0];
  const unit = value.substring(number.length);
  number = Number(number);

  if (!isNumber(number) || unit !== '%' && unit !== 'px') {
    return null;
  }

  return {
    number,
    unit
  };
}

const noWidthAndHeightKeysError = ['originalDims should be an object containing both the "width" and "height" keys'];
function originalDimsCheck(originalDims) {
  if (originalDims == null) {
    return {
      result: true,
      analysis: {
        width: null,
        height: null
      }
    };
  }

  if (!isObject(originalDims)) {
    return {
      result: false,
      errors: noWidthAndHeightKeysError
    };
  }

  if (!hasOwnProp(originalDims, 'width') || !hasOwnProp(originalDims, 'height')) {
    return {
      result: false,
      errors: noWidthAndHeightKeysError
    };
  }

  if (extractNumberValueFromObject(originalDims, 'width') == null) {
    return {
      result: false,
      errors: ['originalDims.width should be defined either on px or %.']
    };
  }

  if (extractNumberValueFromObject(originalDims, 'height') == null) {
    return {
      result: false,
      errors: ['originalDims.height should be defined either on px or %.']
    };
  }

  return {
    result: true,
    analysis: analyseContainerParams(originalDims)
  };
}
function analyseContainerParams(containerParams) {
  if (!isObject(containerParams) || containerParams == null) {
    return {
      width: null,
      height: null
    };
  }

  return {
    width: extractNumberValueFromObject(containerParams, 'width'),
    height: extractNumberValueFromObject(containerParams, 'height')
  };
}
/**
 * extracts the arguments that exist within the parenthesis of a given expression.
 * E.g. the @stagger(0px, 10px) will give the array ["0px", "10px'] etc
 *
 * @param {string} expression
 * @returns {*|string[]}
 */

function extractParenthesisAttrsAsArray(expression) {
  const tempValue = removeWhitespace(expression);
  const onlyWithinParenthesesRegexp = /.*\((.*)\).*/;
  const content = onlyWithinParenthesesRegexp.exec(tempValue)[1];
  return content.split(',');
}
/**
  subdivision might be rounding the number to its:
    units (subdivision = 1)
    tenths (subdivision = 10)
    hundreds (subdivision = 100)
    thousands (subdivision = 1000)
  @param {number} number
  @param {number} subdivision
  @returns {number} the rounded number
 */

function roundNumberTo(number, subdivision) {
  return Math.round(number / subdivision) * subdivision;
}
function getMCIDandAttrOutOfLaneKey(laneKey) {
  const laneArray = laneKey.split(lanesMCIDattrsSeparator);
  return {
    mcid: laneArray[0],
    attribute: laneArray[1]
  };
}

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
}
/**
 * @returns {string} in the form "1bc45f78-ab23-jl59"
 */


function getAnId() {
  let underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let specialChar = underscore ? '_' : '-';
  return "".concat(s4()).concat(s4()).concat(specialChar).concat(s4()).concat(specialChar).concat(s4());
}
function getLaneKey(mcid, attribute) {
  return "".concat(mcid).concat(lanesMCIDattrsSeparator).concat(attribute);
}
/**
 * This function always returns false,
 * it's used to overwrite other functions
 * @returns {false}
 */

function alwaysReturnFalse() {
  return false;
}
/**
 * given an object, a path in string format and a value the method will assign
 * to the given path of the object the provided value. If the path does not exist
 * it will return false, otherwise it'll return true
 * @param {object} obj
 * @param {string} path: a string representatio of the path, e.g. "path.to.key"
 * @param {any} value: the new value of the given key
 **/

function assignValueToPath(obj, path, value) {
  const arrayPath = path.split('.');
  let currentObject = obj;

  for (let i = 0; i < arrayPath.length - 1; i++) {
    if (!hasOwnProp(currentObject, arrayPath[i])) {
      return false;
    }

    currentObject = currentObject[arrayPath[i]];
  }

  if (!hasOwnProp(currentObject, arrayPath[arrayPath.length - 1])) {
    return false;
  }

  currentObject[arrayPath[arrayPath.length - 1]] = value;
  return true;
}
function sortByIndexes(collection, by) {
  const test_with_index = [];

  for (let i = 0; i < collection.length; i++) {
    test_with_index.push([collection[i], i]);
  }

  test_with_index.sort(function (left, right) {
    return left[0][by] < right[0][by] ? -1 : 1;
  });
  var indexes = [];

  for (var j in test_with_index) {
    indexes.push(test_with_index[j][1]);
  }

  return indexes;
}
function doNothing() {
  /* This function is intentionally empty*/
}
/** @classdesc Helper maintains a number of helpful functions in a single point  */

class Helper {
  constructor(configuration) {
    let logLevel$1 = logLevel;

    if (hasOwnProp(configuration, 'logLevel')) {
      logLevel$1 = configuration.logLevel;
    }

    for (let i = 0; i < logTypes.length; i++) {
      const logType = logTypes[i];

      if (logLevel$1 >= logType.level) {
        this[logType.key] = window.console[logType.consoleMethod].bind(window.console, "MotorCortex - ".concat(logType.key, ": ")) ;
      } else this[logType.key] = doNothing;
    }

    if (logLevel$1 >= 3) {
      this.log = window.console.log.bind(window.console, 'MotorCortex - ');
      return;
    }

    this.log = doNothing;
  }

}

const helper = new Helper();
function validateProps(props, rules, constructor) {
  const validationResult = rules(props);

  if (validationResult.length > 0) {
    let errorMessage = "Error on plugin's \"".concat(constructor.plugin_npm_name, "\" \"").concat(constructor.ClassName, "\" instantiation. Errors (op props):");

    for (let i = 0; i < validationResult.length; i++) {
      errorMessage += "\n - ".concat(validationResult[i].message, ". ").concat(validationResult[i].actual, " provided");
    }

    helper.error(errorMessage);
    return {
      result: false,
      errors: validationResult
    };
  }

  return {
    result: true
  };
}
function getElementByMCID(context, mcid) {
  return context.rootElement.querySelectorAll("[".concat(elementsDataAttributeName, "=\"").concat(mcid, "\"]"))[0];
}
function buildInitialValuesValidationRules(attributeRules) {
  let initialValuesRules = deepCopy(attributeRules);

  function makeOptional(attr) {
    if (isString(attr)) {
      attr = {
        type: attr
      };
    }

    attr.optional = true;

    if (attr.type === 'object') {
      for (let key in attr.props) {
        makeOptional(attr.props[key]);
      }
    }
  }

  makeOptional(initialValuesRules);
  return initialValuesRules;
}
/**
 * Escape a string for HTML interpolation.
 * @param {string} string
 */

function htmlEscape(string) {
  // List of HTML entities for escaping.
  const htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  }; // Regex containing the keys listed immediately above.

  const htmlEscaper = /[&<>"'/]/g;
  return "".concat(string).replace(htmlEscaper, function (match) {
    return htmlEscapes[match];
  });
}
/**
 * systole / diastole of the projections
 * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
 * */

function systoleDiastoleProjections(projections, durationFraction, anchorPoint) {
  const alteredProjections = [];

  for (let i = 0; i < projections.length; i++) {
    const projectedIncident = projections[i];
    let start = projectedIncident.parentMillisecond - anchorPoint;
    start = start * durationFraction + anchorPoint;

    if (durationFraction !== 1) {
      alteredProjections.push({
        id: projectedIncident.incident.id,
        start,
        end: start + projectedIncident.incident.duration * durationFraction,
        startDelta: start - projectedIncident.millisecond
      });
    }
  }

  return alteredProjections;
}
function validateGoogleFontUrl(url) {
  return url.trimStart().startsWith('https://fonts.googleapis.com/css');
}
function removeWhitespace(str) {
  return str.replace(/\s/g, '');
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function wrapReturn(result) {
  return !result.result ? {
    result: false,
    errors: result.errors
  } : {
    result: true,
    execute: result.execute
  };
}

const successWithEmptyExecution = {
  result: true,
  execute: function () {// this is left intentionally empty
  }
};
class Channel {
  constructor(props) {
    this.runTimeInfo = props.runTimeInfo;
    this.context = props.context;
    this.onInitialise();
    this.getIncidentById = props.getIncidentById;
  }

  static get type() {
    return 'plain';
  }

  onInitialise() {}

  _resize() {
    helper.log('Please overwite the _resize method of the Channel');
  }
  /**
   * @param {array} incidents - A collection of Incidents in the form:
   * {
   *  millisecond
   *  incident
   *  id
   * }
   * @returns either:
   *   {
   *       result:true,
   *       execute: // an array of functions that when executed it will add the Incidents on the Channels
   *   }
   *   or
   *   {
   *       result: false,
   *       errors
   *   }
   */


  addIncidents(incidents) {
    // first check the Incidents addition directly using the checkAddition method of the class
    return wrapReturn(this.checkAddition(incidents));
  }
  /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
     * @param {number} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */


  editIncidents(incidents, millisecondsDelta) {
    // first check the Incidents addition directly using the checkAddition method of the class
    return wrapReturn(this.checkEdit(incidents, millisecondsDelta));
  }
  /**
     * Method to remove incidents
     * @param {array} incidents - the ids of the incidents to remove in an array format
     * @param {object} props
     * @retuns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */


  removeIncidents(incidents) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // first check the Incidents addition directly using the checkAddition method of the class
    return wrapReturn(this.checkDelete(incidents, props));
  }
  /**
   * This method is invoked whenever a Clip with exits a context loading waiting. All Channels
   * that extend Channel can rewrite this method accordingly
   * @param {string} _contextId - The id of the context of the Clip Copy according to which
   *      we are going to recalc the scratch values
   * */
  // eslint-disable-next-line no-unused-vars


  recalcScratchValues(_contextId) {// this is left intentionally empty
  }
  /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} _incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
  // eslint-disable-next-line no-unused-vars


  checkAddition(_incidents) {
    return successWithEmptyExecution;
  } // eslint-disable-next-line no-unused-vars


  checkEdit(_incidentsArray, _millisecondsDelta) {
    return successWithEmptyExecution;
  } // eslint-disable-next-line no-unused-vars


  checkDelete(_incidentIds, _props) {
    return successWithEmptyExecution;
  } // eslint-disable-next-line no-unused-vars


  checkResizedIncidents(_incidents) {
    return successWithEmptyExecution;
  } // eslint-disable-next-line no-unused-vars


  moveTo(_from, _to, _contextId) {// this is left intentionally empty
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 *
 * Clip from definition takes a definition object and returns a full Descriptive
 * Representation / creation of the Clip. As soon as the Clip is hosted, immediately
 * the real Clip will also be rendered.
 *
 * definition: {
 *     Class: <The Class>,
 *     attrs: <attrs>,
 *     props: <props>,
 *     incidents: { // this exists only in the case of a Group or a Clip
 *         <id>:{
 *           id: <id>,
 *           position> <position>,
 *           leaf: <definition>
 *         },
 *         ...
 *     }
 * }
 */

function constructIncident(definition) {
  const TheIncident = new definition.Class(definition.attrs, definition.props);

  if (TheIncident.result === false) {
    return TheIncident;
  }

  if (hasOwnProp(definition, 'incidents')) {
    for (const key in definition.incidents) {
      const incidentDefinition = definition.incidents[key];
      const incident = constructIncident(incidentDefinition.leaf);

      if (incident.result === false) {
        return incident;
      }

      const additionResult = TheIncident.addIncident(incident, incidentDefinition.position);

      if (additionResult.result === false) {
        return additionResult;
      }
    }
  }

  return TheIncident;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _CantBeResized = "Incidents with dynamic duration can't be resized. Once the Incident enters a Clip it'll become resizable";
const _SizeBiggerThanZero = 'Size must always be > 0';

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class ElementAttribute {
  constructor(expressionProps) {
    this.expressionProps = {
      attribute: /\(([^)]+)\)/.exec(expressionProps.value)[1]
    };
  }

  calculateValues(elements) {
    const values = [];

    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      let value = element.getAttribute(this.expressionProps.attribute);

      if (isNumeric(value)) {
        value = parseFloat(value);
      }

      values.push(value);
    }

    return values;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var conf$4 = {
  supportedTypes: ['amount', 'color', 'date', 'email', 'measurement', 'number', 'string'],
  preface: 'attribute'
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const attributeRegexp = new RegExp("^@".concat(conf$4.preface, "\\([_A-z0-9-]*\\)$")); // eslint-disable-next-line no-unused-vars

function validate$3(expression, logError, checkValues) {
  return attributeRegexp.test(expression);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var attribute = {
  Handler: ElementAttribute,
  validation: validate$3,
  preface: conf$4.preface,
  supportedTypes: conf$4.supportedTypes
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var conf$3 = {
  supportedTypes: ["amount", "measurement", "number"],
  preface: 'expression'
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const curlyBracketsOpenCloseRegexp = /({{ *| *}})/g;
function itemsIdentifierRegexp(items) {
  let asString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const itemsKeys = Object.keys(items).join('|');

  if (itemsKeys === '') {
    return false;
  }

  const itemsIdentifierRegex = "(\\b(".concat(itemsKeys, ")\\b)(((\\.[a-zA-Z_]\\w*)|(\\[\\d*\\]))*)(?![a-z,A-Z_0-9])");

  if (asString) {
    return itemsIdentifierRegex;
  }

  return new RegExp(itemsIdentifierRegex, 'g');
}
function keysIdentifierRegexp(keys) {
  if (!isObject(keys)) {
    return false;
  }

  const theKeys = Object.keys(keys).join('|');

  if (!theKeys) {
    return false;
  }

  const keysIdentifierRegex = "(\\b(".concat(theKeys, "\\b))(?![a-z,A-Z_0-9.\\[])");
  return new RegExp(keysIdentifierRegex, 'g');
}
function ofAttributeValueRegexp(items) {
  const ofAttrRegx = "^ *".concat(itemsIdentifierRegexp(items, true), " *$");
  return new RegExp(ofAttrRegx, 'g');
} // TODO  ignore backslashed double curly brackets

const dynamicExpressionsRegexp = /{{((?!}}).)*}}/g; // right test it on "{{   fsdaf }} and {{ τεστ {{ τεστ }} }} {{ {{ test }}"

const dynamicExpressionsOnlyIfRegexp = /( *mc-if *= *" *)[^"]*(?=")/g; // for backwards lookup (when safari supports it
// we will use  /(?<= *mc-if *= *" *)[^"]*(?=")/g;
// TODO  regex that identifies blackslashed double curly brackets

const singleQuotesRegexp = /'.*'/g;
const integerRegexp = /^ *\d* *$/;
const fullStringRegexp = /^ *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *$/g;
const stringComparisonRegexp = /^( *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *)(==|===)( *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *)$/g;

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function addToNameSpace(path, value) {
  let replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : mcNameSpace;
  let win = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : window;

  if (!hasOwnProp(win, namespace)) {
    win[namespace] = {};
  }

  let currentObject = win[namespace];
  const arrayPath = path.split('.');

  for (let i = 0; i < arrayPath.length - 1; i++) {
    if (!hasOwnProp(currentObject, arrayPath[i])) {
      currentObject[arrayPath[i]] = {};
    }

    currentObject = currentObject[arrayPath[i]];
  }

  if (!replace && hasOwnProp(currentObject, arrayPath[arrayPath.length - 1])) {
    return false;
  }

  currentObject[arrayPath[arrayPath.length - 1]] = value;
  return true;
}
function getFromNameSpace(path) {
  let namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mcNameSpace;
  let win = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;
  if (namespace !== '') path = "".concat(namespace, ".").concat(path);
  const arrayPath = path.replaceAll(/\]/g, '').split(/[[.]/g);
  let currentObject = win;

  for (let i = 0; i < arrayPath.length; i++) {
    if (!hasOwnProp(currentObject, arrayPath[i])) {
      if (i === arrayPath.length - 1 && arrayPath[i] === 'length' && ( // if it's the last key and it's "length"
      isString(currentObject) || Array.isArray(currentObject))) {
        // and its either a string or an array
        return currentObject.length;
      }

      return undefined;
    }

    currentObject = currentObject[arrayPath[i]];
  }

  return currentObject;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const keywords = new Set(['getValue', 'setValue', '_getFromProxy', '__createPathProxies', 'hasOwnProperty', 'pushValue', 'removePathKey', 'removeKey', 'restoreKey', 'getKeys', 'exportFlattened', 'isArray', 'push', 'sortBy', 'findIndex']); // eslint-disable-next-line sonarjs/cognitive-complexity

function createProxy(originalObject) {
  let proxy = {};
  const removedKeys = new Set();
  let isArray = Array.isArray(originalObject);
  let length = isArray ? originalObject.length : 0; // indexesMap maps the real indexes of our proxy to virtual indexes that can be
  // produced by custom array-like & array-specific methods such as sortBy or slice

  let indexesMap = null;
  const overlay = {
    get: function (obj, prop) {
      if (prop === 'length' && isArray) {
        return length;
      }

      if (keywords.has(prop)) {
        return this[prop];
      }

      if (removedKeys.has(prop)) {
        return undefined;
      }

      if (isArray && indexesMap !== null) {
        prop = indexesMap[prop];
      }

      if (hasOwnProp(proxy, prop)) {
        return proxy[prop];
      }

      return originalObject[prop];
    },

    isArray() {
      return isArray;
    },

    _getFromProxy(prop) {
      return hasOwnProp(proxy, prop) ? proxy[prop] : undefined;
    },

    set: alwaysReturnFalse,

    sortBy(what) {
      indexesMap = null;

      if (!isArray) {
        return false;
      }

      indexesMap = sortByIndexes(this, what);
    },

    __createPathProxies(arrayPath) {
      let currentObject = proxy;
      let currentRealObect = originalObject; // if they don't already exist, create Proxies all the way down the path

      for (let i = 0; i < arrayPath.length - 1; i++) {
        // if our current object doesn't already have the specific key
        const key = isArray && indexesMap !== null ? indexesMap[arrayPath[i]] : arrayPath[i];
        const decision = i === 0 ? currentObject[key] === undefined : currentObject._getFromProxy(key) === undefined;

        if (decision) {
          // we create a new proxy passing as originalData the data of our originalData
          const childProxy = createProxy(currentRealObect !== undefined ? currentRealObect[key] || {} : {});

          if (i === 0) {
            currentObject[key] = childProxy; // our proxy now points to the new proxy on the specific key
          } else {
            currentObject.setValue(key, childProxy);
          }
        }

        currentObject = currentObject[key];
        currentRealObect = currentRealObect !== undefined ? currentRealObect[key] : {};
      }

      return {
        currentObject,
        currentRealObect
      };
    },

    /* a method that accepts the array element and if it returns true the element's index is returned */
    findIndex(method) {
      if (!isArray) {
        return null;
      }

      for (let i = 0; i < length; i++) {
        if (method(this[i])) {
          return i;
        }
      }

      return null;
    },

    setValue(path, value) {
      const arrayPath = path.split('.');

      const currentObject = this.__createPathProxies(arrayPath).currentObject;

      let valueToSet = value;

      if (isObject(value)) {
        valueToSet = createProxy(value);
      }

      if (arrayPath.length === 1) {
        currentObject[arrayPath[arrayPath.length - 1]] = valueToSet; // sets only delete an element if it exists, otherwise they return false

        removedKeys.delete(valueToSet);
      } else {
        currentObject.setValue(arrayPath[arrayPath.length - 1], valueToSet);
        currentObject.restoreKey(arrayPath[arrayPath.length - 1]);
      }

      return true;
    },

    pushValue(path, value) {
      let arrayPath = path.split('.');

      const {
        currentObject,
        currentRealObect
      } = this.__createPathProxies(arrayPath);

      if (currentRealObect === undefined) {
        return false;
      }

      const lastKey = arrayPath[arrayPath.length - 1];
      let currentObjectTarget = currentObject[lastKey];
      let originalObjectTarget = originalObject[lastKey];

      if (path === '') {
        // if it refers directly to our proxy
        currentObjectTarget = this;
        originalObjectTarget = originalObject;
      }

      if (arrayPath.length !== 1) {
        return currentObject.pushValue(lastKey, value);
      } // if the target array is an attribute directly of our proxy
      // first check if our target (either belonging on the proxy or on the original data) is an array


      let existsOnProxy = false;

      if (currentObjectTarget !== undefined) {
        // if the key already exists on our proxy
        existsOnProxy = true;

        if (!currentObjectTarget.isArray()) {
          return false;
        }
      } else {
        if (!Array.isArray(originalObjectTarget)) {
          return false;
        }
      } // then, if the array is not already implemented as proxy, create a proxy for it


      if (!existsOnProxy) {
        const arrayProxy = createProxy(originalObjectTarget);
        currentObject[lastKey] = arrayProxy;
        currentObjectTarget = currentObject[lastKey];
      } // finally, push the new entry on the proxy array


      currentObjectTarget.push(value);
      return true;
    },

    push(value) {
      if (!this.isArray()) {
        return false;
      }

      proxy[length] = isObject(value) ? createProxy(value) : value;
      length += 1;
      return true;
    },

    removePathKey(path) {
      const arrayPath = path.split('.');

      const {
        currentObject
      } = this.__createPathProxies(arrayPath);

      currentObject.removeKey(arrayPath[arrayPath.length - 1]);
      return true;
    },

    removeKey(key) {
      removedKeys.add(key);
    },

    restoreKey(key) {
      removedKeys.delete(key);
    },

    hasOwnProperty(key) {
      return !(removedKeys.has(key) || this[key] === undefined);
    },

    getKeys() {
      if (isArray) {
        return [];
      }

      let allKeys = Object.keys(originalObject);
      allKeys.push(...Object.keys(proxy));
      allKeys = allKeys.filter(item => !removedKeys.has(item));
      return allKeys;
    },

    exportFlattened() {
      let toReturn;

      if (isArray) {
        toReturn = [];

        if (indexesMap !== null) {
          for (let i = 0; i < indexesMap.length; i++) {
            const key = indexesMap[i];

            if (hasOwnProp(proxy, key)) {
              // if it exists in our proxy
              const value = proxy[key];

              if (isObject(value)) {
                // if it's an object
                try {
                  toReturn[i] = proxy[key].exportFlattened(); // get the flattened version
                } catch (e) {
                  toReturn[i] = value;
                }
              } else {
                toReturn[i] = value; // else just copy the value of the proxy to our output
              }
            } else {
              toReturn[i] = originalObject[key];
            }
          }
        } else {
          toReturn = [...originalObject];

          for (const [key, value] of Object.entries(proxy)) {
            if (isObject(value)) {
              // if it's an object
              try {
                toReturn[key] = proxy[key].exportFlattened(); // get the flattened version
              } catch (e) {
                toReturn[key] = value;
              }
            } else {
              toReturn[key] = value; // else just copy the value of the proxy to our output
            }
          }
        }
      } else {
        toReturn = {};
        const keys = this.getKeys();

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];

          if (proxy[key] !== undefined) {
            // if it's on the proxy side
            toReturn[key] = isObject(proxy[key]) ? proxy[key].exportFlattened() // if it's an object get the flattened version
            : proxy[key];
          } else {
            // if it resides on the real array
            toReturn[key] = originalObject[key];
          }
        }
      }

      return toReturn;
    }

  };
  return new Proxy(originalObject, overlay);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const parser = new exprEval.Parser();
const mcifRegex = / *mc-if *= *" */g; // expr: a complete string expression ready to parsed to string
// e.g. 'test' + ' another string ' + 3 will be turned to "test another string 3"

function createString(dexp) {
  const strings = dexp.split(/ *\+ */);

  for (let i = 0; i < strings.length; i++) {
    strings[i] = strings[i].trim(); // it starts and ends in double quotes

    if (strings[i].match(singleQuotesRegexp)) {
      // remove first and last character
      strings[i] = strings[i].substring(1, strings[i].length - 1);
    }
  }

  return strings.join('');
}

function compareNumbers(val1, val2, operator) {
  switch (operator) {
    case '==':
    case '===':
      return val1 === val2;

    case '!=':
    case '!==':
      return val1 !== val2;

    case '>':
      return val1 > val2;

    case '>=':
      return val1 >= val2;

    case '<':
      return val1 < val2;

    case '<=':
      return val1 <= val2;

    default:
      helper.error('Not supported operator ' + operator);
      return false;
  }
}
/*
1. find all {{ }} except the ones that have the off= {{ sthg }}. Leave \}} and \{{ untouched
2. On each, find and replace the items and the keys on them
3. And then decide if they are final and if so...
final:
- either "string" + "string" + number + "string" -> parses the string concat
- or string [!=, !==, ==, ===] string -> parses strings, compares them and returns boolean
- or can get parsed by expr-eval and gets parsed
- if it contains undefined -- ?? --
4. Replace them with their final value. Turn \{{ to {{ and \}} to }}
if isHTML is true all parsed values will be html escaped
 */
// eslint-disable-next-line sonarjs/cognitive-complexity


function parseKnownParams(template, params, isHTML) {
  // eslint-disable-next-line sonarjs/cognitive-complexity
  function replacer(dynamicExpression) {
    // as backwards lookup on regxp is not supported by safari on the replacer function we might have as input strings
    // that are directly the expression to evaluate and replace or expressions that start with / *mc-if *= *" */
    // We need to know if our expression starts with mc-if and if so to initially remove it and then restore it on the
    // string we'll provide back
    const mcifResults = dynamicExpression.match(mcifRegex);
    const mcif = Array.isArray(mcifResults);
    dynamicExpression = dynamicExpression.replaceAll(/ *mc-if *= *" */g, '');

    function customReturn(toReturn) {
      if (mcif) {
        toReturn = " mc-if=\"".concat(toReturn);
      }

      return toReturn;
    }

    dynamicExpression = dynamicExpression.replaceAll(/ *mc-if *= *" */g, '');
    const hasCurly = dynamicExpression.match(curlyBracketsOpenCloseRegexp);
    let expression = dynamicExpression.replaceAll(curlyBracketsOpenCloseRegexp, ''); // itemsIdentifierRegexp returns either a regular expression of boolean false if there are no items present

    const itemsRegex = itemsIdentifierRegexp(params.items); // same stands for keysIdentifierRegexp

    const keysRegex = keysIdentifierRegexp(params.keys); // itemRegex === false means no items are present

    if (itemsRegex !== false) {
      expression = expression.replaceAll(itemsRegex, exp => {
        if (exp === 'initParams' || exp === 'attrs') {
          return customReturn('undefined');
        }

        let value = getFromNameSpace(exp, '', params.items);

        if (isString(value)) {
          value = "'".concat(isHTML ? htmlEscape(value) : value, "'");
        }

        return value;
      });
    } // keysRegex === false means there are no keys present


    if (keysRegex !== false) {
      expression = expression.replaceAll(keysRegex, exp => {
        let value = params.keys[exp];

        if (isString(value)) {
          value = "'".concat(isHTML ? htmlEscape(value) : value, "'");
        }

        return value;
      });
    }

    if (expression.match(stringComparisonRegexp)) {
      // if it is a string comparison
      const comparedParts = expression.split(/===|==/);
      comparedParts[0] = createString(comparedParts[0]);
      comparedParts[1] = createString(comparedParts[1]);
      return customReturn((comparedParts[0] === comparedParts[1]).toString());
    } // first we will try to parse it by expr-eval


    try {
      const expr = parser.parse(expression);
      const parserArgs = Object.assign({}, params.keys, params.items);
      const value = expr.evaluate(parserArgs);

      if (value !== undefined && !isNaN(value)) {
        return customReturn(value);
      }
    } catch (e) {// eslint-disable-line no-empty
    } // then we will try to parse it as a string


    if (expression.match(fullStringRegexp)) {
      // if it is a full string
      return customReturn(createString(expression));
    } // a final try: parse potential valid numeric comparison


    const operatorRegex = /===|==|>=|>|<=|<|!==|!=/g;
    const comparedParts = expression.split(operatorRegex);

    if (comparedParts.length === 2) {
      const operator = expression.match(operatorRegex)[0];

      try {
        const expr1 = parser.parse(comparedParts[0]);
        const expr2 = parser.parse(comparedParts[1]);
        const parserArgs = Object.assign({}, params.keys, params.items);
        const value1 = expr1.evaluate(parserArgs);
        const value2 = expr2.evaluate(parserArgs);
        return customReturn(compareNumbers(value1, value2, operator).toString());
      } catch (e) {// eslint-disable-line no-empty
      }
    }
    /*
    at this point several things have happened:
    - the parser has turned all known values inside the expressions to their corresponding values
    - the parser has identified all valid complete expression and turned them to their final value
      removing curly brackets. These cases have already been returned, so here we are talking about
      not final expressions
    so, at this point we have expressions that have their know values parsed but still, the expressions
    are not final yet.
    We need to maintain the curly brackets on these expressions so the following iterations (potential
    mc-for children) can try to parse them, as they'll hold more data (items / keys).
    expression here is the expression (without curly brackets) will all know attributes already parsed.
     */


    if (hasCurly !== null) {
      return customReturn("{{".concat(expression, "}}"));
    }

    return customReturn(expression);
  } // first match all params.items expressions matched (within {{ }} )


  let stepOne = template.replaceAll(dynamicExpressionsRegexp, replacer); // then the mc-if

  return stepOne.replaceAll(dynamicExpressionsOnlyIfRegexp, replacer);
}
function resolveIfs(rootElement) {
  const ifs = rootElement.querySelectorAll('[mc-if]');

  for (const element of ifs) {
    const mcif = element.getAttribute('mc-if');

    if (mcif === 'true') {
      element.removeAttribute('mc-if');
    } else if (mcif === 'false') {
      element.remove();
    }
  }
}
function getOfValue(element, items) {
  if (!element.hasAttribute('mc-for') || !element.hasAttribute('mc-of')) {
    helper.warning('Either mc-for and mc-of is missing from element');
    return false;
  }

  if (!element.getAttribute('mc-for').match(/^ *[a-zA-Z_]\w* *, *[a-zA-Z_]\w* *$/)) {
    // TODO investigate false warning on CASIs and restore the warning
    // helper.warning('mc-for attribute is not a valid expression');
    return false;
  }

  const exp = ofAttributeValueRegexp(items);
  const mcof = element.getAttribute('mc-of');
  const res = mcof.match(exp);
  const integerRes = mcof.match(integerRegexp);

  if ((res === null || res === void 0 ? void 0 : res.length) !== 1 && integerRes === null) {
    helper.warning('mc-of attribute is not a valid expression');
    return false;
  }

  if (integerRes !== null) {
    return new Array(parseInt(mcof)).fill('');
  }

  const value = getFromNameSpace(res[0].trim(), '', items);

  if (value === undefined) {
    helper.warning('mc-of value is undefined');
    return false;
  } else if (!isObject(value) && !isString(value) && !isInteger(value)) {
    helper.warning('mc-of value should be either a string, an object or an array');
    return false;
  }

  if (isInteger(value)) {
    return new Array(value).fill('');
  }

  return value;
}
/**
 *
 * @param {object} props: contains the keys:
 *  - template
 *  - keys
 *  - items
 *  - params
 */

function parseForLoop(props) {
  const blocks = [];
  const paramsProxy = createProxy(props.params);

  for (const key in props.items) {
    paramsProxy.setValue("keys.".concat(props.keys.key), key);
    paramsProxy.setValue("items.".concat(props.keys.item), props.items[key]);
    blocks.push(parse(props.template, paramsProxy.exportFlattened(), true));
  }

  return blocks;
}
/**
 *
 * @param {HTMLDOMElement} rootElement: the Browser element to resolve its direct mc-for loops
 * @param params: consists of two keys, the "items" and the "keys"
 *  keys are expected to be strings (or numbers) while items are treated as
 *  objects (or arrays)
 * @return {HTMLDOMElement}: return the same element only with its mc-for elements either
 *  parsed or discarded
 */

function parseForLoops(rootElement, params) {
  const fors = rootElement.querySelectorAll('[mc-for]');

  for (const element of fors) {
    const items = getOfValue(element, params.items);

    if (items === false) {
      element.remove();
      continue;
    } // get the key and item keys from mc-for attribute


    const keysAr = element.getAttribute('mc-for').split(',');
    const keys = {
      key: keysAr[0].trim(),
      item: keysAr[1].trim()
    }; // cleanup the mc-for and mc-of attributes from the element

    element.removeAttribute('mc-for');
    element.removeAttribute('mc-of'); // get the outerHTML to be used as our template

    const template = element.outerHTML; // get the parsed Browser for the for

    const forDOMBlocks = parseForLoop({
      template,
      keys,
      params,
      items
    }); // insert the for blocks in place of the original element
    // if the resolved items is empty just remove the original element

    if (forDOMBlocks.length === 0) {
      element.remove();
      continue;
    } // otherwise loop into results and gradually replace element with the resolved Browser blocks


    let currentElement = element;

    for (let i = 0; i < forDOMBlocks.length; i++) {
      const insertedNode = currentElement.parentNode.insertBefore(forDOMBlocks[i], currentElement.nextSibling);
      currentElement = insertedNode;
    }

    element.remove();
  } // ends loop within the mc-for elements

}
/**
 *
 * @param {string} template
 * @param {object} params: consists of two keys, the "items" and the "keys"
 *  keys are expected to be strings (or numbers) while items are treated as
 *  objects (or arrays)
 * @param {boolean} isHTML: defines if the parser will parse html
 */

function parse(template, params) {
  let isHTML = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  template = template.replace(/^\s+|\s+$/g, '');
  template = parseKnownParams(template, params, isHTML);

  if (!isHTML) {
    return template;
  }

  const containerElement = document.createElement('div');
  containerElement.innerHTML = template;
  resolveIfs(containerElement);
  parseForLoops(containerElement, params); // prevent non-rooted Browser trees to get parsed

  if (containerElement.childElementCount !== 1) {
    helper.warning('parser only accepts close Browser trees (always contained on a single element). The root element can not have mc-for applied to it. Returning empty div');
    return document.createElement('div');
  }

  return containerElement.firstChild;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const cleanupRegex = /\(([^()]|\(([^()]|\(([^()]|\(([^()])*\))*\))*\))*\)/;
function validateExpression(expression) {
  expression = removeWhitespace(expression);
  const mathExpression = cleanupRegex.exec(expression);

  if (mathExpression === undefined) {
    return {
      result: false
    };
  }

  const splitExpression = expression.split(')');
  return {
    result: true,
    unit: splitExpression[splitExpression.length - 1],
    expression: mathExpression[0]
  };
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const preface = conf$3.preface;
class Handler {
  constructor(expressionProps) {
    const validity = validateExpression(expressionProps.value);
    this.expressionProps = {
      unit: validity.unit,
      expression: validity.expression
    };
  }
  /* resizes the stagger to the given fraction */


  resize(fraction) {
    let expression = validateExpression(this.expressionProps.expression);
    const mathExpression = "(".concat(expression.expression, "*").concat(fraction, ")");
    return "".concat(preface, "(").concat(mathExpression, ")").concat(this.expressionProps.unit);
  }
  /**
   * the initParams is the initParams that the Clip accepts on its creation
   * and stores on its context, on the key initParams
   **/


  calculateValues(elements, initParams) {
    const totalElements = elements.length;
    const values = [];
    const parserArgs = {
      [dynamicValuesTerms.totalElements]: totalElements,
      [dynamicValuesTerms.initParams]: initParams
    };

    for (let i = 0; i < totalElements; i++) {
      parserArgs[dynamicValuesTerms.elementIndex] = i;
      const removedParenthesis = this.expressionProps.expression.substring(1, this.expressionProps.expression.length - 1);
      const parsedString = parse("{{".concat(removedParenthesis, "}}"), {
        items: parserArgs
      }); // if the returned string is still a dynamic expression that means it can't fully parsed

      if (parsedString.match(dynamicExpressionsRegexp) !== null) {
        helper.error("".concat(this.expressionProps.expression, " can not fully parsed. At least one of the provided parameters seem not to be valid. Returning 0"));
        values.push(0);
        continue;
      }

      const finalValue = "".concat(parsedString).concat(this.expressionProps.unit);
      values.push(isNumeric(finalValue) ? finalValue * 1 : finalValue);
    }

    return values;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function validate$2(expression, logError) {
  const res = validateExpression(expression);

  if (!res.result) {
    logError("Invalid ".concat(conf$3.preface, " expression"));
  }

  return res.result;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var expression = {
  Handler,
  validation: validate$2,
  preface: conf$3.preface,
  supportedTypes: conf$3.supportedTypes
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class InitParams {
  constructor(expressionProps) {
    this.expressionProps = {
      expression: expressionProps.value
    };
  }

  calculateValues(elements, initParams) {
    const totalElements = elements.length;
    const parserArgs = {
      [dynamicValuesTerms.totalElements]: totalElements,
      [dynamicValuesTerms.initParams]: initParams
    };
    const path = this.expressionProps.expression.substring(this.expressionProps.expression.indexOf('.') + 1);
    const toReturn = [];

    for (let i = 0; i < elements.length; i++) {
      parserArgs[dynamicValuesTerms.elementIndex] = i;
      const itemPath = path.replaceAll(/\[(.*?)\]/g, str => {
        const removedBrackets = str.substring(1, str.length - 1);
        return parse("[{{".concat(removedBrackets, "}}]"), {
          items: parserArgs
        });
      });
      const initParam = getFromNameSpace(itemPath, '', initParams);
      toReturn.push(initParam);
    }

    return toReturn;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var conf$2 = {
  supportedTypes: ["amount", "array", "boolean", "color", "currency", "date", "email", "enum", "measurement", "number", "object", "string", "tuple", "url"],
  preface: 'initParams'
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const initParamsOnlyRegex = new RegExp("^ *@".concat(conf$2.preface, ".[_A-z0-9]* *$"));

function validate$1(expression, logError) {
  if (!initParamsOnlyRegex.test(expression)) {
    logError("Invalid ".concat(conf$2.preface, " expression"));
    return false;
  }

  return true;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var initParams = {
  Handler: InitParams,
  validation: validate$1,
  preface: conf$2.preface,
  supportedTypes: conf$2.supportedTypes
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var conf$1 = {
  supportedTypes: ["amount", "array", "boolean", "color", "currency", "date", "email", "enum", "measurement", "number", "object", "string", "tuple", "url"],
  preface: 'pattern'
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * patternProps: {
 *    dynamicType: 'pattern',
		path:
		unit: '',
		type: 'measurement',
		pattern: [Array]
 * }
 */

class ElementPattern {
  constructor(patternProps) {
    let pattern = extractParenthesisAttrsAsArray(patternProps.value);
    let isAmount = true;
    const numericArray = [];

    for (let i = 0; i < pattern.length; i++) {
      if (!isNumeric(pattern[i])) {
        isAmount = false;
        break;
      }

      numericArray.push(parseFloat(pattern[i]));
    }

    if (isAmount) {
      pattern = numericArray;
    }

    this.patternProps = {
      type: isAmount ? 'amount' : 'measurement',
      pattern
    };
  }

  calculateValues(elements) {
    const length = this.patternProps.pattern.length;
    const values = [];

    for (let i = 0; i < elements.length; i++) {
      values.push(this.patternProps.pattern[i % length]);
    }

    return values;
  }

  resize(fraction) {
    if (this.patternProps.type !== 'amount') {
      return "".concat(conf$1.preface, "(").concat(this.patternProps.pattern.join(), ")");
    }

    const toReturn = [];

    for (let i = 0; i < this.patternProps.pattern.length; i++) {
      toReturn.push(fraction * this.patternProps.pattern[i]);
    }

    return "".concat(conf$1.preface, "(").concat(toReturn.join(), ")");
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const patternRegexp = new RegExp("^@".concat(conf$1.preface, "\\(( *#*[_A-z0-9.%-]+?( *, *#*[_A-z0-9.%-]+)*?)\\)$"));

function validate(expression, logError, checkValues, schema) {
  if (!patternRegexp.test(removeWhitespace(expression))) {
    logError("The ".concat(conf$1.preface, " expression is not valid"));
    return false;
  }

  const patternValues = extractParenthesisAttrsAsArray(expression);

  if (schema.type === 'number') {
    for (let i = 0; i < patternValues.length; i++) {
      if (!isNumeric(patternValues[i])) {
        logError("The @pattern value at index ".concat(i, " is not numeric"));
        return false;
      }

      patternValues[i] = parseFloat(patternValues[i]);
    }
  }

  return checkValues(patternValues);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var pattern = {
  Handler: ElementPattern,
  validation: validate,
  preface: conf$1.preface,
  supportedTypes: conf$1.supportedTypes
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const doublePI = 2 * Math.PI;
const easing = {
  linear(fraction) {
    return fraction;
  },

  easeInQuad(fraction) {
    return fraction * fraction;
  },

  easeOutQuad(fraction) {
    return fraction * (2 - fraction);
  },

  easeInOutQuad(fraction) {
    return fraction < 0.5 ? 2 * fraction * fraction : -1 + (4 - 2 * fraction) * fraction;
  },

  easeInCubic(fraction) {
    return fraction * fraction * fraction;
  },

  easeOutCubic(fraction) {
    return --fraction * fraction * fraction + 1;
  },

  easeInOutCubic(fraction) {
    return fraction < 1 / 2 ? 4 * fraction * fraction * fraction : (fraction - 1) * (2 * fraction - 2) * (2 * fraction - 2) + 1;
  },

  easeInQuart(fraction) {
    return fraction * fraction * fraction * fraction;
  },

  easeOutQuart(fraction) {
    return 1 - --fraction * fraction * fraction * fraction;
  },

  easeInOutQuart(fraction) {
    return fraction < 0.5 ? 8 * fraction * fraction * fraction * fraction : 1 - 8 * --fraction * fraction * fraction * fraction;
  },

  easeInQuint(fraction) {
    return fraction * fraction * fraction * fraction * fraction;
  },

  easeOutQuint(fraction) {
    return 1 + --fraction * fraction * fraction * fraction * fraction;
  },

  easeInOutQuint(fraction) {
    return fraction < 0.5 ? 16 * fraction * fraction * fraction * fraction * fraction : 1 + 16 * --fraction * fraction * fraction * fraction * fraction;
  },

  easeInSine(fraction) {
    return -1 * Math.cos(fraction * (Math.PI / 2)) + 1;
  },

  easeOutSine(fraction) {
    return Math.sin(fraction * (Math.PI / 2));
  },

  easeInOutSine(fraction) {
    return -(Math.cos(Math.PI * fraction) - 1) / 2;
  },

  easeInExpo(fraction) {
    return fraction == 0 ? 1 : 1 * Math.pow(2, 10 * (fraction - 1));
  },

  easeOutExpo(fraction) {
    return fraction == 1 ? 1 : 1 * (-Math.pow(2, -10 * fraction) + 1);
  },

  easeInOutExpo(fraction) {
    if (fraction == 0 || fraction == 1) return fraction;
    if ((fraction *= 2) < 1) return Math.pow(2, 10 * (fraction - 1)) / 2;
    return (-Math.pow(2, -10 * --fraction) + 2) / 2;
  },

  easeInCirc(fraction) {
    if (fraction >= 1) return fraction;
    return -(Math.sqrt(1 - fraction * fraction) - 1);
  },

  easeOutCirc(fraction) {
    return Math.sqrt(1 - (fraction = fraction / 1 - 1) * fraction);
  },

  easeInOutCirc(fraction) {
    if ((fraction *= 2) < 1) return -(Math.sqrt(1 - fraction * fraction) - 1) / 2;
    return (Math.sqrt(1 - (fraction -= 2) * fraction) + 1) / 2;
  },

  easeInElastic(fraction) {
    if (fraction == 0 || fraction == 1) return fraction;
    let p = 0.3;
    let s = p / doublePI * Math.asin(1);
    return -(Math.pow(2, 10 * (fraction -= 1)) * Math.sin((fraction * 1 - s) * doublePI / p));
  },

  easeOutElastic(fraction) {
    if (fraction == 0 || fraction == 1) return fraction;
    let p = 0.3;
    let s = p / doublePI * Math.asin(1);
    return Math.pow(2, -10 * fraction) * Math.sin((fraction - s) * doublePI / p) + 1;
  },

  easeInOutElastic(fraction) {
    if (fraction == 0 || fraction == 1) return fraction;
    let p = 0.3 * 1.5;
    let s = p / doublePI * Math.asin(1);
    if (fraction < 1) return -(Math.pow(2, 10 * (fraction -= 1)) * Math.sin((fraction - s) * doublePI / p)) / 2;
    return Math.pow(2, -10 * (fraction -= 1)) * Math.sin((fraction - s) * doublePI / p) / 2 + 1;
  },

  easeInBack(fraction) {
    const s = 1.70158;
    return fraction * fraction * ((s + 1) * fraction - s);
  },

  easeOutBack(fraction) {
    const s = 1.70158;
    return (fraction -= -1) * fraction * ((s + 1) * fraction + s) + 1;
  },

  easeInOutBack(fraction) {
    let s = 1.70158;
    if ((fraction *= 2) < 1) return fraction * fraction * (((s *= 1.525) + 1) * fraction - s) / 2;
    return ((fraction -= 2) * fraction * (((s *= 1.525) + 1) * fraction + s) + 2) / 2;
  },

  easeInBounce(fraction) {
    return 1 - easing.easeOutBounce(1 - fraction);
  },

  easeOutBounce(fraction) {
    if (fraction < 1 / 2.75) {
      return 1 * (7.5625 * fraction * fraction);
    }

    if (fraction < 2 / 2.75) {
      return 7.5625 * (fraction -= 1.5 / 2.75) * fraction + 0.75;
    }

    if (fraction < 2.5 / 2.75) {
      return 7.5625 * (fraction -= 2.25 / 2.75) * fraction + 0.9375;
    }

    return 7.5625 * (fraction -= 2.625 / 2.75) * fraction + 0.984375;
  },

  easeInOutBounce(fraction) {
    return (fraction < 0.5 ? easing.easeInBounce(fraction * 2) : easing.easeOutBounce(fraction * 2 - 1) + 1) / 2;
  }

};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * @param {string} staggerExpression: a stagger expression such as @stagger(300px, 500px, 0.5, linear)
 * @retuns {object}: the staggerExpression analysed into its ingredients:
 *  {start, end, startFraction, easing}
 **/

function staggerAnalyser(staggerExpression) {
  staggerExpression = removeWhitespace(staggerExpression);
  const onlyWithinParenthesesRegexp = /.*\((.*)\).*/;
  const content = onlyWithinParenthesesRegexp.exec(staggerExpression)[1];
  const staggerParams = content.split(',');
  return {
    start: staggerParams[0],
    end: staggerParams[1],
    startFraction: 1 * staggerParams[2] || 0,
    easing: staggerParams[3] || 'linear',
    mode: staggerParams[4] || 'linear',
    reverse: staggerParams[5] === 'true'
  };
}
/**
 * @param {number} start: the start (minimum) value of the range
 * @param {number} end: the end (maximum) value of the range
 * @param {number} distanceFromStart: the distance of the element from the start (from 0 to 1)
 * @param {string} easing: the easing we want to apply
 **/

function stagger$1(start, end, distanceFromStart, easing$1) {
  if (!easing$1) {
    easing$1 = 'linear';
  } // the position of the element on the range from 0 to 1


  const easedPositionOnSet = easing[easing$1](distanceFromStart);
  return easedPositionOnSet * (end - start) + start;
}
/**
 * Given the stagger params: totalElements, startPoint, mode, and reverse this method calculates the distance of each
 * element of the set (from 0 to 1) from the starting stagger point.
 * @param {integer} totalElements: the number of elements of the set
 * @param {number} startPoint: the starting point of the stagger (0 to 1)
 * @param {string} mode: (defaults to "linear") one of "linear" and "omni"
 * @param {boolean} reverse: (defaults to false). If is set to reverse the stagger will be applied in reverse sequence
 * @returns {array}: an array containing the distance of each element from the starting point (from 0 to 1)
 **/

function calcStaggerDistances(totalElements) {
  let startPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
  let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const distances = [];

  if (mode === 'linear') {
    for (let i = 0; i < totalElements; i++) {
      const position = i / (totalElements - 1);
      let distance = position < startPoint ? position + 1 - startPoint + 1 / (totalElements - 1) : position - startPoint;

      if (reverse) {
        distance = 1 - distance;
      }

      distances.push(distance);
    }
  } else if (mode === 'omni') {
    const maxDistance = 1 - startPoint;

    for (let i = 0; i < totalElements; i++) {
      const absDistance = Math.abs(i / (totalElements - 1) - startPoint);
      let position = absDistance / maxDistance;

      if (reverse) {
        position = 1 - position;
      }

      distances.push(position);
    }
  }

  return distances;
}
class StaggerClass {
  constructor(staggerProps) {
    const analysis = staggerAnalyser(staggerProps.value);
    const startNumberPart = analysis.start.match(numberPartRegexp)[0];
    const endNumberPart = analysis.end.match(numberPartRegexp)[0];
    const units = analysis.start.toString().substring(startNumberPart.length);
    this.staggerProps = {
      from: startNumberPart * 1,
      to: endNumberPart * 1,
      mode: analysis.mode,
      unit: units,
      fraction: analysis.startFraction,
      easing: analysis.easing,
      reverse: analysis.reverse,
      type: units === '' ? 'amount' : 'measurement',
      integer: staggerProps.integer
    };
  }
  /* resizes the stagger to the given fraction */


  resize(fraction) {
    this.staggerProps.from *= fraction;
    this.staggerProps.to *= fraction;

    if (this.staggerProps.integer === true) {
      this.staggerProps.from = Math.round(this.staggerProps.from);
      this.staggerProps.to = Math.round(this.staggerProps.to);
    }

    return "@stagger(".concat(this.staggerProps.from).concat(this.staggerProps.unit, ", ").concat(this.staggerProps.to).concat(this.staggerProps.unit, ", ").concat(this.staggerProps.fraction || 0, ", ").concat(this.staggerProps.easing || 'linear', ", ").concat(this.staggerProps.mode || 'linear', ", ").concat(this.staggerProps.reverse || false, ")");
  }

  calculateValues(elements) {
    const totalElements = elements.length;

    if (totalElements < 2) {
      return [this.staggerProps.from];
    }

    const distances = calcStaggerDistances(totalElements, this.staggerProps.fraction, this.staggerProps.mode, this.staggerProps.reverse);
    const values = [];

    for (let i = 0; i < distances.length; i++) {
      let value = stagger$1(this.staggerProps.from, this.staggerProps.to, distances[i], this.staggerProps.easing);

      if (this.staggerProps.integer === true) {
        value = Math.round(value);
      }

      if (this.staggerProps.type === 'measurement') {
        value += this.staggerProps.unit;
      }

      values.push(value);
    }

    return values;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var conf = {
  supportedTypes: ['amount', 'measurement', 'number'],
  preface: 'stagger'
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const easings = Object.keys(easing);

function validateStagger(staggerExpression, logError, checkValues, schema) {
  staggerExpression = removeWhitespace(staggerExpression);
  const staggerRegex = /^@stagger\(([A-z0-9.%-]+?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+))\)$/; // TODO dynamically get @stagger expression from conf

  if (!staggerRegex.test(staggerExpression)) {
    logError('Invalid @stagger expression');
    return false;
  }

  const analysis = staggerAnalyser(staggerExpression);

  if (analysis.startFraction < 0 || analysis.startFraction > 1) {
    logError("The ".concat(conf.preface, " fraction must be a number >=0 and <=1"));
    return false;
  }

  if (!easings.includes(analysis.easing)) {
    logError("The ".concat(conf.preface, " easing (").concat(analysis.easing, ") is not supported by the system"));
    return false;
  }

  if (analysis.mode !== 'linear' && analysis.mode !== 'omni') {
    logError("The ".concat(conf.preface, " mode should be either \"linear\" or \"omni\""));
    return false;
  }

  if (analysis.reverse !== true && analysis.reverse !== false) {
    logError("The ".concat(conf.preface, " reverse should be either true or false"));
    return false;
  }

  const startNumberPartMatches = analysis.start.match(numberPartRegexp);
  const endNumberPartMatches = analysis.end.match(numberPartRegexp);

  if (startNumberPartMatches === null || endNumberPartMatches === null) {
    logError("The start and end units of a @stagger should always be the same. This doesn't stand for the couple ".concat(analysis.start, ", ").concat(analysis.end));
    return false;
  }

  const startNumberPart = startNumberPartMatches[0];
  const endNumberPart = endNumberPartMatches[0];
  const startUnits = analysis.start.toString().substring(startNumberPart.length);
  const endUnits = analysis.end.toString().substring(endNumberPart.length);

  if (startUnits !== endUnits) {
    logError("The start and end units of a @stagger should always be the same. ".concat(startUnits, ", ").concat(endUnits, " provided"));
    return false;
  } // TODO if analysis start or end are not helper.isNumeric log and schema.type === 'number' logError & return false


  const start = schema.type === 'number' ? parseFloat(analysis.start) : analysis.start;
  const end = schema.type === 'number' ? parseFloat(analysis.end) : analysis.end;
  return checkValues([start, end]);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var stagger = {
  Handler: StaggerClass,
  validation: validateStagger,
  preface: conf.preface,
  supportedTypes: conf.supportedTypes
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const registeredDVs = [];
function registerDV(definition) {
  registeredDVs.push(definition);
}
function getDVs() {
  return registeredDVs;
}
registerDV(attribute);
registerDV(expression);
registerDV(initParams);
registerDV(pattern);
registerDV(stagger);

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const dvs$1 = getDVs();
function identifyDynamicValues(rootObj) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (!rootObj) {
    return [];
  }

  const dynamics = [];

  for (const [key, value] of Object.entries(rootObj)) {
    if (value instanceof Element) {
      // skip the rest of the method if the field is 'host'
      continue;
    } // in the case it is an object or an array pass the responsibility to it


    if (isObject(value)) {
      const tmpDynamics = identifyDynamicValues(value, "".concat(path).concat(path === '' ? '' : '.').concat(key));
      dynamics.push(...tmpDynamics);
      continue;
    } // else if it is anything else but string, just ignore it


    if (!isString(value)) {
      continue;
    }

    const trimmedValue = value.trim();

    for (let i = 0; i < dvs$1.length; i++) {
      const dv = dvs$1[i];

      if (trimmedValue.startsWith("@".concat(dv.preface))) {
        const dvInfo = {
          dynamicType: dv.preface,
          path: "".concat(path).concat(path === '' ? '' : '.').concat(key),
          Handler: dv.Handler,
          value: trimmedValue // TODO here we should know and pass to data whether the field has integer: true

        };
        dynamics.push(dvInfo);
      }
    }
  }

  return dynamics;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _DIRECTIONS = {
  _UP: 'up',
  _DOWN: 'down'
};
const _TARGETTYPES$1 = {
  _ROOTOFTREE: 'native.tree.rootoftree'
};
const _BYPASS = 'native.tree.bypass';

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class Leaf {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // parentNode is a reference to the parent Node the Leaf is attached to (if any)
    this.parentNode = null;
    this.isNode = false;
    this.id = hasOwnProp(props, 'id') ? props.id : getAnId();
    this.props = props;
    this.resetDuration();
  }

  get name() {
    return hasOwnProp(this.props, 'name') ? this.props.name : null;
  }

  set name(newName) {
    this.props.name = newName;
  }

  get delay() {
    return hasOwnProp(this.props, 'delay') ? this.props.delay : 0;
  }

  set delay(val) {
    if (val !== 0) {
      this.props.delay = val;
    }

    this.resetDuration();
  }

  get hiatus() {
    return hasOwnProp(this.props, 'hiatus') ? this.props.hiatus : 0;
  }

  set hiatus(val) {
    if (val !== 0) {
      this.props.hiatus = val;
    }

    this.resetDuration();
  }

  get repeats() {
    return hasOwnProp(this.props, 'repeats') ? this.props.repeats : 1;
  }

  set repeats(val) {
    this.props.repeats = val;
    this.resetDuration();
  }
  /**
   *
   * @param {boolean} triggerUp - if provided to true the reset triggers reset duration on the
   * Leaf's parents too. Defaults to false
   */


  resetDuration() {
    let triggerUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this._duration = this.repeats * (this.delay + this.props.duration + this.hiatus);

    if (triggerUp) {
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });
    }
  }
  /**
   * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and
   * repeats factor
   * */


  get duration() {
    return this._duration;
  }
  /**
   * the setter sets the overall duration of the Leaf by altering all
   * delay, duration and hiatus properties of it
   * */


  set duration(milliseconds) {
    const fraction = milliseconds / this.duration;
    this.props.duration *= fraction;
    this.hiatus *= fraction;
    this.delay *= fraction;
    this.resetDuration();
  }
  /**
   * setNewDuration method sets the new FULL duration as it derives from the
   * delay, duration, hiatus and repeats factors
   * */


  setNewDuration(newDuration) {
    this.duration = newDuration;
    this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
  }

  systoleDiastole(durationFraction) {
    this.duration *= durationFraction;
  }

  get hasParent() {
    return this.parentNode !== null;
  }

  attachToNode(node) {
    this.parentNode = node;
  }

  detachFromParent() {
    this.parentNode = null;
  }
  /**
  @param {string} name - the name of the message
  @param {object} payload - the payload of the message
  @param {object} target - specifies the target of the message in a key-value pairs object
  @param {object} options - in the form:
  {
      direction (either _UP or _DOWN)
      selfExecute (either true which means the Leaf should try to handle the message itself or
          false which means the Leaf should directly forward the message to its parent)
  }
  @returns The expected result of this method is on the form:
  {
      response: an object the structure of which depends on the name of the message
          and maybe even on the payload
      responder: a direct reference to the lead that actually responded
      (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester
  }
  * */


  putMessageOnPipe(name, payload, target) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    // default direction: _DOWN
    if (!hasOwnProp(options, 'direction')) {
      options.direction = _DIRECTIONS._DOWN;
    } // default positionDelta = 0


    if (options.direction === _DIRECTIONS._DOWN && !hasOwnProp(options, 'positionDelta')) {
      options.positionDelta = 0;
    }

    if (options.selfExecute) {
      // if the Leaf has a "handle<name>" method with the first letter of
      // name in Capital it runs it
      const handlingMethodName = "handle".concat(jsUcfirst(name));
      const capable = typeof this[handlingMethodName] === 'function';

      if (capable) {
        const response = this[handlingMethodName](target, payload);

        if (response !== _BYPASS) {
          const result = {
            response,
            responder: this
          };

          if (options.direction === _DIRECTIONS._UP) {
            return result;
          }

          return [{ ...result,
            positionDelta: options.positionDelta
          }];
        }
      }
    }

    if (options.direction !== _DIRECTIONS._UP) {
      return [];
    }

    if (this.hasParent) {
      return this.parentNode.putMessageOnPipe(name, payload, target, {
        selfExecute: true,
        direction: _DIRECTIONS._UP
      });
    } // if the message reaches the top of the tree without finding any liable target


    return {
      response: false,
      responder: null
    };
  }

  bypass() {
    return _BYPASS;
  } // Postion on Pyramidion
  // "Pyramidion" is the uppermost piece or capstone of an Egyptian pyramid.
  // To us "Pyramidion" is the top Node of the TimedTree to which this Leaf belongs to
  // and the following infrastructure implements it


  get positionOnPyramidion() {
    return this.getPositionOnPyramidion();
  }

  getPositionOnPyramidion() {
    let delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!this.hasParent) {
      return delta;
    }

    const result = this.putMessageOnPipe('getPositionOnPyramidion', {
      delta,
      id: this.id
    }, 'Parent', {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
    return result.response;
  }

  editAttributes(newAttrs) {
    if (this.constructor.attrsValidationRules !== null) {
      const validationResult = this.constructor.attrsValidationMethod(newAttrs);

      if (validationResult.length > 0) {
        return {
          result: false,
          errors: validationResult
        };
      }
    }

    const checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES$1._DECISIONAUTHORITY, {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });

    if (checkIfBelongsToClip.response) {
      // if the Group belongs on a Clip
      return this.manageEditAttrProps(newAttrs, 'attrs');
    }

    this.attrs = newAttrs;
    return {
      result: true
    };
  }

  editProperties(newProps) {
    const validation = validateProps(newProps, this.constructor.propsValidationRules, this.constructor);

    if (!validation.result) {
      return validation;
    }

    const checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES$1._DECISIONAUTHORITY, {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });

    if (checkIfBelongsToClip.response) {
      // if the Group belongs on a Clip
      return this.manageEditAttrProps(newProps, 'props');
    }

    this.props = newProps;
    return {
      result: true
    };
  }

  resize(newSize) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      check: true
    };

    if (this.duration === 'dynamic') {
      return {
        result: false,
        reason: _CantBeResized
      };
    }

    if (newSize === this.duration) {
      return {
        result: true,
        meta: {
          unprocessed: true
        }
      };
    }

    if (newSize <= 0) {
      return {
        result: false,
        reason: _SizeBiggerThanZero
      };
    }

    if (options.check && this.hasParent) {
      const mcCheck = this.putMessageOnPipe('checkResize', {
        id: this.id,
        newSize,
        fraction: newSize / this.duration
      }, _TARGETTYPES$1._DECISIONAUTHORITY, {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });

      if (!mcCheck.response.result) {
        return mcCheck.response;
      }
    }

    this.setNewDuration(newSize);
    return {
      result: true
    };
  }

  clone() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let def = this.exportLiveDefinition();

    for (let path in attrs) {
      addToNameSpace(path, attrs[path], true, 'attrs', def);
    }

    for (let path in props) {
      addToNameSpace(path, props[path], true, 'props', def);
    }

    return constructIncident(def);
  }

  selector() {
    if (this.inheritedSelector === null) {
      // if the Incident has no parent selector inherited
      return !hasOwnProp(this.props, 'selector') ? null : this.props.selector; // else, if it has a selector that's its final selector
    } // else if there is an inherited selector


    if (!hasOwnProp(this.props, 'selector')) {
      // and does not have a selector of its own
      return this.inheritedSelector; // then its selector is equal to the inherited selector
    } // else, if it both has an inherited and an own selector


    if (this.props.selector.charAt(0) === '&') {
      return this.inheritedSelector + this.props.selector.substring(1);
    }

    return "".concat(this.inheritedSelector, " ").concat(this.props.selector);
  }

  getElements() {
    if (this.props.host !== null && this.props.host !== undefined) {
      return [this.props.host];
    }

    if (!this.hasParent) {
      return [];
    }

    const checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES$1._DECISIONAUTHORITY, {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });

    if (!checkIfBelongsToClip.response) {
      return [];
    }

    const elementsResponse = this.putMessageOnPipe('getElements', {
      selector: this.selector()
    }, _TARGETTYPES$1._DECISIONAUTHORITY, {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
    return elementsResponse.response;
  }

  setupDynamicValues() {
    /**
     * report is what this method returns. It actually holds for attrs and props
     * the information of how many dynamic values have been identified by type.
     * For example if attrs have two "stagger" and one "expression" dynamic values
     * on the report props would be: {stagger: 2, expression: 1}
     */
    const report = {
      attrs: {},
      props: {}
    };

    for (const key of ['attrs', 'props']) {
      const incidentPropsStaggers = identifyDynamicValues(this[key]);

      for (const stagger of incidentPropsStaggers) {
        const DVHanlder = stagger.Handler;
        const propsToPass = {
          value: stagger.value,
          integer: stagger.integer
        };
        this["".concat(key === 'attrs' ? 'attributes' : 'props', "Staggers")].push({
          path: stagger.path,
          stagger: new DVHanlder(propsToPass)
        }); // if the dynamic value type is undefined on report.props initialise it as 0

        if (!hasOwnProp(report[key], stagger.dynamicType)) {
          report[key][stagger.dynamicType] = 1;
          continue;
        }

        report[key][stagger.dynamicType] += 1;
      }
    }

    return report;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _LEAFALREADYASSIGNED = 'Leaf has already been attached to another Node';
const _NEGATIVEPOSITIONNOTALLOWED = 'Negative positioning of childs on nodes is not allowed';
const _LEAFNOTFOUND = "The Leaf with the requested id couldn't be found on the TimedTree";

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class Node extends Leaf {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);
    this.isNode = true;
    /**
    The object holds the Incidents of the Scene on the format:
    {
        <id>: {
              id // the id of the Incident object
              leaf // the incident object
              position // the position of the incident
        },
        ...
    }
     */

    this.children = {};
    this.calculatedDuration = 0;
    this.resetDuration();
  }
  /**
   * We want to keep our duration as number and avoid getter because of performance.
   * For this each time the duration must be recalculated we can call this method
   */


  resetDuration() {
    this._duration = this.repeats * (this.delay + this.calculatedDuration + this.hiatus);
  }

  get duration() {
    return this._duration;
  }

  set duration(milliseconds) {
    if (this.duration === 0) {
      return;
    }

    const fraction = milliseconds / this.duration;
    this.calculatedDuration *= fraction;
    this.hiatus *= fraction;
    this.delay *= fraction;
    this.resetDuration();

    for (const childKey in this.children) {
      const child = this.children[childKey];
      this.editPosition(child.id, child.position * fraction, true);
      child.leaf.systoleDiastole(fraction);
    }
  }
  /**
   *
   * @param {object} payload - an object with the childId key. This object is provided on addition actions
   * so it executes recalc with better performance
   * @returns {boolean}
   * @private
   */


  _calculateDuration(payload) {
    if (!payload || payload.childId != null) {
      const child = this.children[payload.childId];
      const childEnd = child.leaf.duration + child.position;

      if (childEnd > this.calculatedDuration) {
        this.calculatedDuration = childEnd;
        this.resetDuration();
        return true;
      }

      return false;
    } // plain handling with no input provided


    let duration = 0;

    for (const childKey in this.children) {
      const child = this.children[childKey];

      if (child.position + child.leaf.duration > duration) {
        duration = child.position + child.leaf.duration;
      }
    }

    if (duration === this.calculatedDuration) {
      return false;
    }

    this.calculatedDuration = duration;
    this.resetDuration();
    return true;
  } // eslint-disable-next-line no-unused-vars


  handleRecalcDuration(target, payload) {
    if (this._calculateDuration(payload)) {
      return this.putMessageOnPipe('recalcDuration', payload.childId ? {
        childId: this.id
      } : {}, // if there is childId in the payload we are handling an addition. Only in additions we pass the childId further up
      'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });
    }

    return true;
  }

  getLeafById(id) {
    let onlyDirectChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (hasOwnProp(this.children, id)) {
      return this.children[id].leaf;
    }

    if (!onlyDirectChild) {
      for (const child in this.children) {
        const childLeaf = this.children[child].leaf;

        if (childLeaf.isNode) {
          const leaf = childLeaf.getLeafById(id);

          if (leaf != null) {
            return leaf;
          }
        }
      }
    }

    return null;
  }

  getLeafPosition(id) {
    if (hasOwnProp(this.children, id)) {
      return this.children[id].position;
    }

    const res = this.putMessageOnPipe('getLeafPosition', {
      id
    }, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._DOWN
    });

    if (res.length > 0) {
      return res[0].positionDelta + res[0].response;
    }
  }

  handleGetLeafPosition(target, payload) {
    return this.getLeafPosition(payload.id);
  }

  checkAddition(leaf, position) {
    if (leaf.hasParent) {
      return {
        result: false,
        reason: _LEAFALREADYASSIGNED
      };
    }

    if (position < 0) {
      return {
        result: false,
        reason: _NEGATIVEPOSITIONNOTALLOWED
      };
    }

    return {
      result: true
    };
  }

  addChild(leaf, position) {
    // this hasParent check occurs here as an extra security check so it
    // gets executed regardless if the user wants to perform checks or not
    if (leaf.hasParent) {
      return {
        result: false,
        reason: _LEAFALREADYASSIGNED
      };
    }

    this.children[leaf.id] = {
      id: leaf.id,
      leaf,
      position
    };
    leaf.attachToNode(this);
    return this.putMsgOnPipeWithResult('recalcDuration', {
      childId: leaf.id
    }, 'Groups', {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });
  }

  checkRemoveChild(id) {
    if (!hasOwnProp(this.children, id)) {
      return {
        result: false,
        reason: _LEAFNOTFOUND
      };
    }

    return {
      result: true
    };
  }

  removeChild(id) {
    this.children[id].leaf.detachFromParent();
    delete this.children[id];
    return this.putMsgOnPipeWithResult('recalcDuration', {}, 'Groups', {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });
  }

  checkEditPosition(id, position) {
    if (position < 0) {
      return {
        result: false,
        reason: _NEGATIVEPOSITIONNOTALLOWED
      };
    }

    if (!hasOwnProp(this.children, id)) {
      return {
        result: false,
        reason: _LEAFNOTFOUND
      };
    }

    return {
      result: true
    };
  }

  editPosition(id, position) {
    let bypassRecalcDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!hasOwnProp(this.children, id)) {
      return;
    }

    this.children[id].position = position;

    if (!bypassRecalcDuration) {
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: true,
        direction: _DIRECTIONS._UP
      });
    }

    return {
      result: true
    };
  }
  /**
    The expected result of this method depends on the direction of the message
    The direction might either be _UP or _DOWN.
    In the case of _UP the expected result is identical as on Leaf:
    {
        response: an object the structure of which depends on the name of the message
            and maybe even on the payload
        responder: a direct reference to the lead that actually responded
    }
    In the case of _DOWN though, where multiple Leafs might be eligible in the tree
    for handling the message the result is on the form:
    [
        {
            response: an object the structure of which depends on the name of the message
                and maybe even on the payload
            responder: a direct reference to the lead that actually responded
            positionDelta: the position delta of the responder compared to the requester
        }
    ]
    */


  putMessageOnPipe(name, payload, target) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    // default direction: _DOWN
    if (!hasOwnProp(options, 'direction')) {
      options.direction = _DIRECTIONS._DOWN;
    } // default positionDelta = 0


    if (options.direction === _DIRECTIONS._DOWN && !hasOwnProp(options, 'positionDelta')) {
      options.positionDelta = 0;
    }

    if (options.direction === _DIRECTIONS._UP) {
      // if the direction is up
      return super.putMessageOnPipe(name, payload, target, options); // act exactly as any other Leaf
    }

    let result = super.putMessageOnPipe(name, payload, target, options);

    if (result.length > 0) {
      return result;
    }

    for (const child in this.children) {
      const {
        leaf
      } = this.children[child];
      const newOptions = { ...options,
        selfExecute: true,
        positionDelta: options.positionDelta + this.children[child].position
      };
      result.push(...leaf.putMessageOnPipe(name, payload, target, newOptions));
    }

    return result;
  }

  putMsgOnPipeWithResult(name, payload, target) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.putMessageOnPipe(name, payload, target, options);
    return {
      result: true
    };
  }

  handleGetPositionOnPyramidion(target, payload) {
    const delta = payload.delta + this.getLeafPosition(payload.id);
    return this.getPositionOnPyramidion(delta);
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _MC_Plugin_Name = 'motor-cortex-js';
const _MC_Attribute = "".concat(_MC_Plugin_Name, "-attribute");

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 *
 * @param {string} description: the description of the block (human readable)
 * @param {object} options: an (optional) set of options for the block. For the time being the only supported option
 * is "exceptional" (boolean) value which if it's true the incident that set the block must be excluded from the block
 * This is called "exceptional block" and we use it in cases an incident that blocks need to remain at the playing
 * state in order to keep on trying to get unblocked (e.g. a youtube video play), otherwise we will end up with the
 * "waiting deadlock" where the clip waits for the incident to get unblocked while the incident waits for the clip play
 * so it can keep on trying to do so. In such cases "exceptional" should be true
 */

function block(description) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (this.blockID === undefined && !options.blockId) {
    this.blockID = getAnId();
  }

  this.DescriptiveIncident.putMessageOnPipe('setBlock', {
    id: this.blockID || options.blockId,
    description,
    incidentId: this.DescriptiveIncident.id,
    realIncidentId: this.id,
    options
  }, 'rootClip', {
    selfExecute: true,
    direction: _DIRECTIONS._UP
  });
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function unblock() {
  let blockId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // eslint-disable-line no-unused-vars
  this.DescriptiveIncident.putMessageOnPipe('unBlock', {
    id: blockId !== null && blockId !== void 0 ? blockId : this.blockID
  }, 'rootClip', {
    selfExecute: true,
    direction: _DIRECTIONS._UP
  });
}

class Group extends Node {
  constructor(attrs, props) {
    super(props);

    _defineProperty__default["default"](this, "handleRemoveIncident", this.handleMoveIncident);

    _defineProperty__default["default"](this, "setBlock", block.bind(this));

    _defineProperty__default["default"](this, "unblock", unblock.bind(this));

    this.mc_plugin_npm_name = _MC_Plugin_Name;
    this.plugin_channel_class = Channel;
    this.hasIncidents = true;
    this.onGroupInitialise();
    this.calculatedDuration = 0;
  }

  onGroupInitialise() {// called when group gets initialised
  }

  handleAddIncident(target, payload) {
    if (this.id === target) {
      const incidentFromDescription = payload.incidentFromDescription;
      const theIncident = incidentFromDescription(payload.incident, payload.contextData); // in the case that an audio clip tries to process an non-audio incident or
      // a non-audio incident tries to process an audio incident the result from incidentFromDescription is null
      // in such a case there should be no candidate return, so this.bypass()

      if (theIncident === null) {
        return this.bypass();
      }

      return theIncident;
    }

    return this.bypass();
  }

  handleMoveIncident(target, payload) {
    if (this.id === target) {
      const res = this.getLeafById(payload.incidentId, true);

      if (res === null) {
        return this.bypass();
      }

      return res;
    }

    return this.bypass();
  }
  /**
   * As Group acts as a transparent layer in terms of checks handleRemoveIncident
   * and handleMoveIncident happens to have the exact same definition
   */


  handleResize(target) {
    return this.id === target ? this : this.bypass();
  }

  removeChild(id) {
    this.children[id].leaf.lastWish();
    super.removeChild(id);
  }
  /**
   * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
   * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object
   */


  getIncidentsByChannel() {
    let adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do
    const incidentsByPlugin = {};
    incidentsByPlugin[_MC_Plugin_Name] = [{
      millisecond: adjustMillisecond,
      parentMillisecond,
      incident: this,
      id: this.id
    }]; // proceed to gather the contained incidents as well

    for (const childId in this.children) {
      const child = this.children[childId];
      const incidentsToAdd = child.leaf.getIncidentsByChannel(adjustMillisecond + child.position, adjustMillisecond);

      for (const key in incidentsToAdd) {
        if (hasOwnProp(incidentsByPlugin, key)) {
          incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);
        } else {
          incidentsByPlugin[key] = incidentsToAdd[key];
        }
      }
    }

    return incidentsByPlugin;
  }

  lastWish() {
    for (const childId in this.children) {
      this.children[childId].leaf.lastWish();
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class ClipChannel extends Channel {
  /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
  onInitialise() {
    this.incidents = [];
    this.incidentsById = {};
  }

  _incidentById(id) {
    return this.incidentsById[id];
  }

  _resize(durationFraction) {
    for (let i = 0; i < this.incidents.length; i++) {
      this.incidents[i].millisecond *= durationFraction;
    }
  }
  /**
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */


  checkAddition(incidents) {
    const errors = [];
    const candidateIncidentsById = {};
    const incidentsToConcat = [];

    for (let i = 0; i < incidents.length; i++) {
      candidateIncidentsById[incidents[i].id] = incidents[i].incident;
      incidentsToConcat.push({
        id: incidents[i].id,
        millisecond: incidents[i].millisecond
      });

      if (hasOwnProp(this.incidentsById, incidents[i].id)) {
        helper.error("Incident with the id ".concat(incidents[i].id, " already exists. Addition is rejected."));
        errors.push({
          type: 'Already existing id',
          meta: {
            id: incidents[i].id
          }
        });
      }
    }

    if (errors.length > 0) {
      return {
        result: false,
        errors
      };
    }

    const that = this;

    const exec = function execFunct() {
      that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
      that.incidents.push(...incidentsToConcat);
      that.incidents.sort((a, b) => a.millisecond - b.millisecond);

      for (let i = 0; i < incidents.length; i++) {
        that._incidentById(incidents[i].id)._onGetContextOnce(that.context);
      }
    };

    return {
      result: true,
      execute: exec
    };
  }
  /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */


  checkEdit(incidentsArray, millisecondsDelta) {
    const incidents = this.incidents;

    const exec = function execFunct() {
      let id;

      for (let i = 0; i < incidentsArray.length; i++) {
        id = incidentsArray[i].id;

        for (let j = 0; j < incidents.length; j++) {
          if (incidents[j].id === id) {
            incidents[j].millisecond += millisecondsDelta;
            break;
          }
        }
      }

      incidents.sort((a, b) => a.millisecond - b.millisecond);
    };

    return {
      result: true,
      execute: exec
    };
  }

  checkDelete(incidentsArray) {
    const that = this;
    const incidentIds = [];

    for (let i = 0; i < incidentsArray.length; i++) {
      incidentIds.push(incidentsArray[i].id);
    }

    const exec = function execFunct() {
      const newIncidents = that.incidents.filter(incident => !incidentIds.includes(incident.id));
      that.incidents = newIncidents;

      for (let i = 0; i < incidentIds.length; i++) {
        delete that.incidentsById[incidentIds[i]];
      }
    };

    return {
      result: true,
      execute: exec
    };
  }
  /**
   * @param {array} incidents - [{id, start, end, startDelta}]
   */


  checkResizedIncidents(incidents) {
    const selfIncidents = this.incidents;

    const exec = function execFunct() {
      let id;

      for (let i = 0; i < incidents.length; i++) {
        id = incidents[i].id;

        for (let j = 0; j < selfIncidents.length; j++) {
          if (selfIncidents[j].id === id) {
            selfIncidents[j].millisecond += incidents[i].startDelta;
            break;
          }
        }
      }

      selfIncidents.sort((a, b) => a.millisecond - b.millisecond);
    };

    return {
      result: true,
      execute: exec
    };
  }
  /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  moveTo(from, to, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    // TODO: This function really similar to moveTo from the AttributeChannel.js, refactor it based on that and extract common functions
    if (forceReset) {
      // incidents: [{id, millisecond}, {}, {}...]
      for (let i = 0; i < this.incidents.length; i++) {
        const laneItem = this.incidents[i];

        const incident = this._incidentById(laneItem.id);

        if (to < laneItem.millisecond) {
          incident.onProgress(0, 0, contextId, true);
        } else if (to > laneItem.millisecond + incident.duration) {
          incident.onProgress(1, incident.duration, contextId, true);
        } else {
          incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);
        }
      }

      return;
    }

    const that = this;
    let participatingItems;

    if (to > from) {
      participatingItems = this.incidents.filter(laneItem => // it ends after from and before to millisecond
      // or it ends after the target millisecond but also starts before it
      laneItem.millisecond + that._incidentById(laneItem.id).duration >= from && laneItem.millisecond + that._incidentById(laneItem.id).duration <= to || that._incidentById(laneItem.id).duration + laneItem.millisecond >= to && laneItem.millisecond <= to);
    } else {
      participatingItems = this.incidents.filter(laneItem => // it ends after from and before to millisecond
      // or it ends after the target millisecond but also starts before it
      laneItem.millisecond + that._incidentById(laneItem.id).duration >= to && laneItem.millisecond + that._incidentById(laneItem.id).duration <= from || that._incidentById(laneItem.id).duration + laneItem.millisecond >= from && laneItem.millisecond <= from);
    }

    for (let i = 0; i < participatingItems.length; i++) {
      const laneItem = participatingItems[i];

      const contextAwareClipIncident = this._incidentById(laneItem.id);

      const overcameEnd = (to - laneItem.millisecond) / contextAwareClipIncident.duration >= 1;
      const fraction = overcameEnd ? 1 : (to - laneItem.millisecond) / contextAwareClipIncident.duration;
      const millisecond = overcameEnd ? contextAwareClipIncident.duration : to - laneItem.millisecond;
      contextAwareClipIncident.onProgress(fraction, millisecond, contextId, false);
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function getIncidentsByChannel() {
  let adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const incidentsByPlugin = {};
  incidentsByPlugin[this.mc_plugin_npm_name] = [{
    millisecond: adjustMillisecond,
    parentMillisecond,
    incident: this,
    id: this.id
  }];
  return incidentsByPlugin;
}

/*
dna:
- originalId
- context
*/

class MonoIncident {
  constructor() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let dna = arguments.length > 2 ? arguments[2] : undefined;

    _defineProperty__default["default"](this, "getIncidentsByChannel", getIncidentsByChannel.bind(this));

    _defineProperty__default["default"](this, "setBlock", block.bind(this));

    _defineProperty__default["default"](this, "unblock", unblock.bind(this));

    this.attrs = attrs;
    this.props = props;
    this.dna = dna;
    this.context = dna.context;
    this.mcid = dna.mcid;
    this.id = props.id || getAnId();
    this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
    // is set to true so we prevent multiple executions of the onGetContext method

    this.gotContext = false;
    /*
      these are the default values that define channeling for the default Incidents. These values get ovewriden through
      the loadPlugin method of MC with the values found on the main.js file of the plugin
    */

    this.plugin_channel_class = Channel;
    this.mc_plugin_npm_name = _MC_Plugin_Name;

    if (hasOwnProp(props, 'plugin_channel_class')) {
      this.plugin_channel_class = props.plugin_channel_class;
    }

    if (hasOwnProp(props, 'mc_plugin_npm_name')) {
      this.mc_plugin_npm_name = props.mc_plugin_npm_name;
    }

    this.hasIncidents = false;
    /*
        initialValues is an object holding the automatically computed initial values of the animatedAttrs
        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to
        an AttributesChannel have initialValues).
        The keys set of this object is identical to the object attrs.animatedAttrs
        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
        of a specific element when there are no other Incidents entered on its lanes yet. These values are
        the "scratchValues" and they are strongly dependent on the nature of the lib. E.g. for a CSS animation
        what we are looking for can be found on the computedStyle.
        The initialValues are the values that are actually going to be used by
        the MonoIncident in the real execution of them
        */

    this.initialValues = {};
    /*
        The initial values defined by the user via the initialValues key on the
        attributes (if present)
        */

    this.userDefinedInitialValues = attrs.initialValues || {};
    /*
      The initialValues of the Incident as passed by the Attribute Channel.
      These values are been altered by the userDefinedInitialValues (if any)
      but we need them for passing them on other Incidents on edit and delete operations
    */

    this.pureInitialValues = null;
    /**
     * @member {boolean} - if autoGenerated is set to true, it means that this MonoIncident has been auto-generated by its parent on initialisation.
     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
     * on specific points on their timeline.
     */

    this.autoGenerated = false;

    if (hasOwnProp(this.attrs, 'animatedAttrs')) {
      this.attributeKey = Object.keys(this.attrs.animatedAttrs)[0];
    }

    this.onInitialise();
  }

  get selector() {
    return this.props.selector;
  }
  /* shortcuts for attrs.attrs and attrs.animatedAttrs */


  get animAttributes() {
    return this.attrs.animatedAttrs;
  }

  set animAttributes(value) {
    this.attrs.animatedAttrs[this.attributeKey] = value;
  }
  /**
    This method shoudl be overwritten by the Incidents of the plugins. The method returns
    the initial value that the element of it has as the library calculates / defines them. The
    returned value represents the very initial value of the element's attribute before
    any Incident that alters it gets added.
     @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
    of the Clip gets rendered
    */


  getScratchValue() {
    return 0;
  }

  get element() {
    if (this.context === null) {
      return [];
    }

    if (this.context.getElementByMCID) {
      return this.context.getElementByMCID(this.mcid);
    }

    return this.context.getElements(this.selector)[0];
  } // get attributeKey() {
  //   return Object.keys(this.attrs.animatedAttrs)[0];
  // }


  get targetValue() {
    return this.animAttributes[this.attributeKey];
  }

  getElementAttribute(attr) {
    return this.element.getAttribute(attr);
  }

  getFraction(ms) {
    return ms / this.props.duration;
  }

  hasUserDefinedInitialValue() {
    return hasOwnProp(this.userDefinedInitialValues, this.attributeKey);
  }

  setInitialValue(value) {
    let storePure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (storePure) {
      this.pureInitialValues = deepCopy(value); // keep a copy of the
      // passed initial values
    }

    if (!this.hasUserDefinedInitialValue()) {
      this.initialValues[this.attributeKey] = value;
      return;
    }

    if (isObject(this.targetValue)) {
      // if it is a combo attribute
      for (const key in this.userDefinedInitialValues[this.attributeKey]) {
        value[key] = this.userDefinedInitialValues[this.attributeKey][key];
      }

      this.initialValues[this.attributeKey] = value;
      return;
    }

    this.initialValues[this.attributeKey] = this.userDefinedInitialValues[this.attributeKey];
  }

  get initialValue() {
    return this.initialValues[this.attributeKey];
  }

  _onGetContextOnce() {
    // if the MonoIncident belongs to a fragmented context there absolutely
    // no reason to run the getContext method of it
    try {
      if (this.context.fragment === true) {
        return;
      }

      if (!this.gotContext) {
        this.onGetContext();
        this.gotContext = true;
      }
    } catch (e) {
      helper.error(e);
      helper.error(this.mcid);
    }
  }

  onGetContext() {
    helper.info('Overwrite the "onGetContext" method with the code you want to get executed', 'info');
  }

  lastWish() {}

  onInitialise() {
    helper.info('Overwrite the "onInialise" method with the code you want to get executed', 'info');
  }
  /**
   * Method called on progress of the timed incident.
   * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   */
  // eslint-disable-next-line no-unused-vars


  onProgress(milliseconds) {}

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class ClipCopy extends MonoIncident {
  constructor(attrs, props, dna) {
    super(attrs, props, dna);
    this.runTimeInfo = {
      currentMillisecond: 0
    };
  }

  get duration() {
    return this.DescriptiveIncident.realClip.duration;
  }

  lastWish() {
    if (this.ownClip) {
      this.ownClip.context.unmount();
    }
  }

  onGetContext() {
    // In order to render itself on the given element first it needs the props (including html and css)
    // from the real Clip it copies
    const constructionArgs = this.DescriptiveIncident.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip

    const host = getElementByMCID(this.context, this.mcid);
    const hostedProps = { ...constructionArgs.props,
      selector: undefined,
      host,
      containerParams: this.DescriptiveIncident.props.containerParams || {},
      originalDims: this.DescriptiveIncident.constructor.originalDims || {}
    }; // we create a clip because Clips on creation render and thus have their own context
    // this.dna.descriptiveIncident.constructor.Incident keeps a reference to the non-audio real Clip
    // Class. No audio is involved on this process

    this.ownClip = new this.DescriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps, this.DescriptiveIncident);
    this.ownClip.clipCopyId = this.id; // flushes the realClip with its ownClip's context

    this.DescriptiveIncident.realClip.addContext({
      clipId: this.id,
      context: this.ownClip.context
    }, true); // even though we have created an own clip, we have made no checks at all neither
    // we added the incidents of the real clip to it. That is because playing and moving
    // this clip copy means directly moving the real clip on the context of the own clip.
    // So the only thing we need here is the context and nothing more.
  }

  onProgress(fraction, milliseconds) {
    let forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    // if the context of the Original Clip is still loading block
    if (this.ownClip.ownContext.contextLoaded === false) {
      this.setBlock('context loading', {
        blockId: this.id
      });
      return;
    }

    for (const key in this.DescriptiveIncident.realClip.instantiatedChannels) {
      // it commands the Channels, of its Clip to move to the given progress point
      const channel = this.DescriptiveIncident.realClip.instantiatedChannels[key];
      channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, forceReset);
    }

    this.runTimeInfo.currentMillisecond = milliseconds;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * @param {object} ingredients -
 * {
 *      id
 *      attrs
 *      props
 *      Incident
 *      plugin_npm_name
 *      Channel
 *      context (optional)
 *      mcid (optional)
 * }
 * */

function incidentFromIngredients(ingredients) {
  let isClip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const thirdProp = isClip ? ingredients.DescriptiveIncident : {
    context: ingredients.context,
    mcid: ingredients.mcid
  };
  const incident = new ingredients.Incident(ingredients.attrs, { ...ingredients.props,
    id: ingredients.id || getAnId()
  }, thirdProp); // we keep this code here this way so we have it in just one place and not spread
  // around the various constructors of the various supported Incident types.

  incident.mc_plugin_npm_name = ingredients.plugin_npm_name;
  incident.plugin_channel_class = ingredients.Channel;
  incident.DescriptiveIncident = ingredients.DescriptiveIncident;
  return incident;
}

class ContextAwareClipIncident extends Leaf {
  constructor(constructionIngredients, contextData, mcid, descriptiveIncident) {
    super({ ...constructionIngredients.props,
      id: "".concat(constructionIngredients.incidentId, "_").concat(mcid)
    }); // a property to hold all of the contexts

    _defineProperty__default["default"](this, "getIncidentsByChannel", getIncidentsByChannel.bind(this));

    this.contexts = {};
    this.constructionIngredients = constructionIngredients;
    this.mcid = mcid;
    this.DescriptiveIncident = descriptiveIncident;
    this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
    this.plugin_channel_class = constructionIngredients.Channel;
    this.addContext(contextData);
    this.timeScale = 1;

    if (descriptiveIncident.realClip.duration > 0) {
      this.timeScale = this.props.duration / descriptiveIncident.realClip.duration;
    }
    /*
    resizing a CASI follows a slightly different approach than resizing anything
    else in the MC ecosystem. The differences rely on the fact that resizing a
    HTMLDescriptiveClip, used as CASI, doesn't need to be checked as CASIs are Clips that
    check themselves and resizing can't produce conflicts, and also that CASIs have
    their fragmented clips (realClip) which they should resize as well.
    When resizing a CASI the DC resizes its realClip but it doesn't resize its representation
    on the context of its parent Clip, which is ElementClipSplitter with its ContextAwareClipIncident
    (CACI) children.
    For this, CACI is responsible for that as it subscribes and listens to
    duration changes on its HTMLDescriptiveClip's realClip and it informs its own tree (the
    parent Clip tree), as well as its own duration.
     */


    descriptiveIncident.realClip.subscribeToDurationChange(newDuration => {
      this.props.duration = this.timeScale * newDuration;
      this.resetDuration();
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });
    });
    this.easing = easing.linear;

    if (hasOwnProp(this.props, 'easing')) {
      if (Array.isArray(this.props.easing)) {
        this.easing = bezeasing__default["default"](this.props.easing[0], this.props.easing[1], this.props.easing[2], this.props.easing[3]);
      } else {
        this.easing = easing[this.props.easing];
      }
    }
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  onProgress(fraction, milliseconds, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    // step 1: find the full delay-duration-hiatus duration of one repeat
    const repeatDuration = this.delay + this.props.duration + this.hiatus; // step 2.a: find the running repeat and millisecond of this repeat

    let millisecondWithinRepeat = milliseconds % repeatDuration; // step 2.b: decide between 0 and 1

    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = this.delay + this.props.duration;
    } // step 3: find the millisecond of the MonoIncident


    let MI_millisecond = millisecondWithinRepeat - this.delay;

    if (MI_millisecond < 0) {
      MI_millisecond = 0;
    } else if (MI_millisecond > this.props.duration) {
      // if it has stepped into hiatus
      MI_millisecond = this.props.duration;
    }

    const MI_fraction = this.props.duration === 0 ? 0 : MI_millisecond / this.props.duration;
    const eased_MI_fraction = this.easing(MI_fraction);
    const eased_MI_millisecond = eased_MI_fraction * this.props.duration * (1 / this.timeScale);

    if (this.originalContext.context.contextLoaded !== false) {
      this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond, forceReset);
    }
  }
  /**
   * The method that handles the addContext message from the ExtendableClip
   **/


  addContext(contextData) {
    let forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    // if it's the first context to be added then it's the original
    if (Object.keys(this.contexts).length === 0) {
      this.originalContextKey = contextData.clipId;
    } // instantiates a _ClipCopy for the new context


    const ingredientsToPass = { ...this.constructionIngredients,
      context: contextData.context,
      mcid: this.mcid,
      Incident: ClipCopy,
      DescriptiveIncident: this.DescriptiveIncident
    }; // and puts it on the corresponding context key

    this.contexts[contextData.clipId] = incidentFromIngredients(ingredientsToPass);

    if (forceGetContext) {
      this.contexts[contextData.clipId]._onGetContextOnce();
    }
  } // eslint-disable-next-line no-unused-vars


  handleAddContext(target, payload) {
    this.addContext(payload, true);
    return true;
  } // eslint-disable-next-line no-unused-vars


  handleContextLoaded(target, payload) {
    this._onGetContextOnce();
  }

  // massive editing methods that apply the request massively to all of the
  // Incidents of all of the contexts
  gotContext() {
    for (const context in this.contexts) {
      this.contexts[context].gotContext();
    }
  }

  _onGetContextOnce() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }

    for (const context in this.contexts) {
      this.contexts[context]._onGetContextOnce();
    }
  }

  lastWish() {
    for (const context in this.contexts) {
      this.contexts[context].lastWish();
    }
  }

  onGetContext() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }

    for (const context in this.contexts) {
      this.contexts[context].onGetContext();
    }
  }

}

class ContextAwareIncident extends Leaf {
  constructor(constructionIngredients, contextData, mcid, attribute) {
    super({ ...constructionIngredients.props,
      id: "".concat(constructionIngredients.incidentId, "_").concat(mcid).concat(attribute != null ? '_' + attribute : '')
    }); // a property to hold all of the contexts

    _defineProperty__default["default"](this, "getIncidentsByChannel", getIncidentsByChannel.bind(this));

    this.contexts = {};
    this.constructionIngredients = constructionIngredients;
    this.mcid = mcid;
    this.attribute = attribute; // this._duration = constructionIngredients.props.duration;

    this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
    this.plugin_channel_class = constructionIngredients.Channel;
    this.DescriptiveIncident = constructionIngredients.DescriptiveIncident;
    this.addContext(contextData);

    if (attribute !== null) {
      const animatedAttr = this.constructionIngredients.attrs.animatedAttrs[this.attribute];

      if (Array.isArray(animatedAttr)) {
        this.originalAnimatedAttributeValue = [...animatedAttr];
      } else if (isObject(animatedAttr)) {
        this.originalAnimatedAttributeValue = { ...animatedAttr
        };
      } else {
        this.originalAnimatedAttributeValue = animatedAttr;
      }
    }

    this.easing = easing.linear;

    if (hasOwnProp(this.props, 'easing')) {
      if (Array.isArray(this.props.easing)) {
        this.easing = bezeasing__default["default"](this.props.easing[0], this.props.easing[1], this.props.easing[2], this.props.easing[3]);
      } else {
        this.easing = easing[this.props.easing];
      }
    }

    this._duration = super.duration;
    this.repeatDuration = this.delay + this.props.duration + this.hiatus;
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  get duration() {
    return this._duration;
  }

  set duration(milliseconds) {
    super.duration = milliseconds;

    for (const context in this.contexts) {
      this.contexts[context].duration = milliseconds;
    }

    this._duration = super.duration;
    this.repeatDuration = this.delay + this.props.duration + this.hiatus;
  }

  addContext(contextData) {
    let forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // if it's the first context to be added then it's the original
    let isTheOriginalContext = false;

    if (Object.keys(this.contexts).length === 0) {
      this.originalContextKey = contextData.clipId;
      this.originalClipContext = contextData.context;
      isTheOriginalContext = true;
    }

    const ingredientsToPass = { ...this.constructionIngredients,
      context: contextData.context,
      mcid: this.mcid
    };
    const whatToAdd = incidentFromIngredients(ingredientsToPass);
    this.contexts[contextData.clipId] = whatToAdd; // when we add a new context we must set the inital value of the newly added Incidents
    // but only for Incidents with animatedAttrs

    if (!isTheOriginalContext && this.attribute != null) {
      this.contexts[contextData.clipId].setInitialValue(this.initialValue);
    }

    if (forceGetContext && this.contexts[contextData.clipId].context.contextLoaded) {
      this.contexts[contextData.clipId]._onGetContextOnce();
    }
  } // eslint-disable-next-line no-unused-vars


  handleAddContext(target, payload) {
    this.addContext(payload, true);
    return true;
  } // eslint-disable-next-line no-unused-vars


  handleContextLoaded(target, payload) {
    this._onGetContextOnce();

    return true;
  }

  onProgress(milliseconds, contextId) {
    /* MonoIncidents are totally agnostic about delay, hiatus and repeats.
        CAI is not that's exactly the point where these properties management occurs.
        Having already set the duration of the ContextAwareIncident according to
        all of these props, here the CAI decides on the progress that its MonoIncidents
        are to on at the given millisecond and according to the given props.
        */
    const delay = this.props.delay || 0; // we prefer this from the Leaf's getter for performance reasons
    // step 2.a: find the running repeat and millisecond of this repeat

    let millisecondWithinRepeat = milliseconds % this.repeatDuration; // step 2.b: decide between 0 and 1

    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = delay + this.props.duration;
    } // step 3: find the millisecond of the MonoIncident


    let MI_millisecond = millisecondWithinRepeat - delay;

    if (MI_millisecond < 0) {
      MI_millisecond = 0;
    } else if (MI_millisecond > this.props.duration) {
      // if it has stepped into hiatus
      MI_millisecond = this.props.duration;
    }

    const MI_fraction = MI_millisecond / this.props.duration;
    const eased_MI_fraction = this.easing(MI_fraction);
    const eased_MI_millisecond = eased_MI_fraction * this.props.duration;

    if (contextId == null) {
      for (const context in this.contexts) {
        if (this.originalContextKey !== context || this.originalContext.fragment !== true) {
          this.contexts[context].onProgress(eased_MI_millisecond);
        }
      }

      return;
    } // if (this.contexts[contextId].context.contextLoaded) { we leave this here for future reference. Might cause issues


    this.contexts[contextId].onProgress(eased_MI_millisecond); // }
  }
  /** METHODS THAT ACT AS "PROXY" TO ALL OF THE INCIDENTS BELONGING TO
   * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT
   * */


  get animatedAttributeValue() {
    return this.constructionIngredients.attrs.animatedAttrs[this.attribute];
  }

  set animatedAttributeValue(value) {
    this.constructionIngredients.attrs.animatedAttrs[this.attribute] = value;
  } // massive editing methods that apply the request massively to all of the
  // Incidents of all of the contexts


  gotContext() {
    for (const context in this.contexts) {
      this.contexts[context].gotContext();
    }
  }

  _onGetContextOnce() {
    if (this.originalContext.context.contextLoaded === false) {
      return;
    }

    for (const context in this.contexts) {
      this.contexts[context]._onGetContextOnce();
    }
  }

  lastWish() {
    for (const context in this.contexts) {
      this.contexts[context].lastWish();
    }
  }

  onGetContext() {
    if (this.originalContext.contextLoaded === false) {
      return;
    }

    for (const context in this.contexts) {
      if (this.contexts[context].context.contextLoaded) {
        this.contexts[context].onGetContext();
      }
    }
  }

  get initialValue() {
    return this.originalContext.initialValue;
  }

  get scratchValue() {
    return this.originalContext.scratchValue;
  }

  get pureInitialValues() {
    return this.originalContext.pureInitialValues;
  }

  setInitialValue(value) {
    let store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const val = deepCopy(value !== null && value !== void 0 ? value : this.getScratchValue());

    for (const context in this.contexts) {
      this.contexts[context].setInitialValue(val, store);
    }
  }

  getScratchValue() {
    let contextId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    // if the context is not loaded yet then return a temporary 0. When the context
    // gets loaded the ExtendableClip will force ContextAwareIncidents to recalc
    // and store it
    if (!this.originalContext.context.contextLoaded) {
      return 0;
    }

    if (contextId != null) {
      return this.contexts[contextId].getScratchValue();
    }

    if (hasOwnProp(this.originalClipContext, 'nonFragmentedContext')) {
      const ingredientsToPass = { ...this.constructionIngredients,
        context: this.originalClipContext.nonFragmentedContext,
        mcid: this.mcid
      };
      const tempIncident = incidentFromIngredients(ingredientsToPass);
      return tempIncident.getScratchValue();
    }

    const contextsKeys = Object.keys(this.contexts);

    if (contextsKeys.length === 1) {
      return this.originalContext.getScratchValue();
    } // prefer another (not the original) context to provide scratch values


    return this.contexts[contextsKeys[1]].getScratchValue();
  }

  play(fraction, ms, contextId) {
    return this.contexts[contextId].play(ms);
  }

  stop(contextId) {
    this.contexts[contextId].stop();
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class AnimatedAttributesSplitter extends Group {
  constructor(descriptiveIncident, contextData, mcid, selector, data) {
    super({}, {
      id: "".concat(descriptiveIncident.id, "_").concat(mcid)
    });
    this.mcid = mcid;
    this.selector = selector;
    this.data = data;
    this.setUp(descriptiveIncident, contextData);
  }

  setUp(descriptiveIncident, contextData) {
    for (const attr in this.data.attrs.animatedAttrs) {
      const singleAnimatedAttrs = {};
      singleAnimatedAttrs[attr] = this.data.attrs.animatedAttrs[attr];
      const attrsToPass = { ...this.data.attrs,
        animatedAttrs: singleAnimatedAttrs
      };
      const propsToPass = { ...this.data.props,
        selector: this.selector
      };
      const constructionIngredients = {
        incidentId: descriptiveIncident.id,
        attrs: attrsToPass,
        props: propsToPass,
        Incident: descriptiveIncident.constructor.Incident,
        plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
        Channel: descriptiveIncident.constructor.Channel,
        DescriptiveIncident: descriptiveIncident
      };
      const contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, this.mcid, attr);
      this.addChild(contextAwareIncident, 0);
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function prepareElementsAttrs(staggerAttrs, index) {
  const toReturn = [];

  for (let i = 0; i < staggerAttrs.length; i++) {
    toReturn.push({
      path: staggerAttrs[i].path,
      value: staggerAttrs[i].values[index]
    });
  }

  return toReturn;
}
function prepareElementsProps(staggerProps, index) {
  const toReturn = [];

  for (let i = 0; i < staggerProps.length; i++) {
    toReturn.push({
      path: staggerProps[i].path,
      value: staggerProps[i].values[index]
    });
  }

  return toReturn;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class ElementSplitter extends Group {
  constructor(descriptiveIncident, contextData) {
    // we make sure the DOMAwareIncident takes the same id as the Descriptive Incident
    super({}, {
      id: descriptiveIncident.id
    }); // a property to hold all of the contexts

    this.contexts = {};
    this.contexts[contextData.clipId] = contextData.context;
    this.originalContextKey = contextData.clipId;
    this.initParams = contextData.context.initParams;
    this.instantiatedCopiesContexts = contextData.instantiatedCopiesContexts;
    this.descriptiveIncident = descriptiveIncident;
    /*
    staggerAttrs is an array holding the calculated values of stagger attributes
    per path and per element. So, for example, if animatedAttrs.width and animatedAttrs.height
    attributes have stagger expressions and there are 10 in total elements the
    staggerAttrs will end up with two entries, one for animatedAttrs.width and one for
    animatedAttrs.height attributes.
    Each of these objects will have a "path" key, defining their path in the attriubtes
    and the "values" key which is an array holding the final values per element. In
    our example this will be an array of length = 10, as we have 10 in total elements.
    */

    this.staggerAttrs = [];
    this.staggerProps = [];
    this.setUp(descriptiveIncident, contextData);
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  parsePropsDynamicValues(descriptiveIncident, elements) {
    for (let propStagger, i = 0; i < descriptiveIncident.propsStaggers.length; i++) {
      propStagger = descriptiveIncident.propsStaggers[i];
      this.staggerProps.push({
        path: propStagger.path,
        values: propStagger.stagger.calculateValues(elements, this.initParams)
      });
    }
  }

  parseAttrsDynamicValues(descriptiveIncident, elements) {
    for (let attrStagger, i = 0; i < descriptiveIncident.attributesStaggers.length; i++) {
      attrStagger = descriptiveIncident.attributesStaggers[i];
      this.staggerAttrs.push({
        path: attrStagger.path,
        values: attrStagger.stagger.calculateValues(elements, this.initParams)
      });
    }
  }

  setUp(descriptiveIncident, contextData) {
    // the elements of the original context
    const elements = this.originalContext.getElements(descriptiveIncident.selector()); // calculate stagger (if any) and store values on this.staggerAttrs

    this.parsePropsDynamicValues(descriptiveIncident, elements);
    this.parseAttrsDynamicValues(descriptiveIncident, elements);
    let element, mcid;

    for (let i = 0; i < elements.length; i++) {
      element = elements[i]; // set the mcid of the element on index i of the original context

      mcid = this._getElementMCID(element); // set the same mcid for the elements of the same context in all of the instantiatedCopiesContexts

      for (const contextKey in this.instantiatedCopiesContexts) {
        // TODO perfrormance improvement via selecting once elements per context
        this._setElementMCID(this.instantiatedCopiesContexts[contextKey], this.instantiatedCopiesContexts[contextKey].getElements(descriptiveIncident.selector())[i], mcid);
      }

      this._createElementIncident(element, descriptiveIncident, contextData, i, elements.length, mcid);
    }
  }
  /*
   * handleRecalDuration method is called after a successful addition.
   * Thus this is the chance and the point where the ElementsSplitter can update
   * the dynamicDurationValue of its DescriptiveIncident
   */


  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);

    if (this.descriptiveIncident.propsStaggers.length > 0) {
      this.descriptiveIncident.dynamicDurationValue = this.duration * 1;
    }

    return res;
  }
  /*
   * lastWish is called when and Incident gets detached from a Clip. ElementsSplitter overwrites
   * the default lastWish coming from Group so it clears the dynamicDurationValue from its
   * DescriptiveIncident
   */


  lastWish() {
    if (this.descriptiveIncident.propsStaggers.length > 0) {
      this.descriptiveIncident.dynamicDurationValue = null;
      this.descriptiveIncident.putMessageOnPipe('setDurationDynamic', {}, 'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });
    }

    super.lastWish();
  }

  _getElementMCID(element) {
    let mcid = this.originalContext.getMCID(element);

    if (!mcid) {
      mcid = getAnId(true);
      this.originalContext.setMCID(element, mcid);
    }

    return mcid;
  }

  _setElementMCID(context, element, mcid) {
    const existingMCID = context.getMCID(element);

    if (!existingMCID) {
      context.setMCID(element, mcid);
    }
  }

  _prepareAttrsPropsForElement(descriptiveIncident, elementIndex) {
    // as a first step we need to assign the already calculated dynamic values (if any) of the specific element
    const attrsForElement = prepareElementsAttrs(this.staggerAttrs, elementIndex); // same for props

    const propsForElement = prepareElementsProps(this.staggerProps, elementIndex);
    let attributes = descriptiveIncident.attrs;
    let properties = descriptiveIncident.props; // if there are dynamic values make a copy of the original attrs so we don't change
    // the original values and assign the dynamic values to it

    if (attrsForElement.length > 0) {
      attributes = deepCopy(descriptiveIncident.attrs);

      for (let i = 0; i < attrsForElement.length; i++) {
        assignValueToPath(attributes, attrsForElement[i].path, attrsForElement[i].value);
      }
    }

    if (propsForElement.length > 0) {
      properties = deepCopy(descriptiveIncident.props);

      for (let i = 0; i < propsForElement.length; i++) {
        assignValueToPath(properties, propsForElement[i].path, propsForElement[i].value);
      }
    }

    return {
      attrs: attributes,
      props: properties
    };
  }

  _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {
    const elementData = this._prepareAttrsPropsForElement(descriptiveIncident, elementIndex);
    /* elements splitter might handle either attribute Incidents (that have animatedAttrs) or Incidents
        that do not have animatedAttrs such as MediaPlayback Incidents.
        In the case of an attributed Incident we proceed by creating one AttributeSplitter for each
        while on the case of an non-attribured Incident we go ahead and implement the final
        Incident
        */


    if (hasOwnProp(descriptiveIncident.attrs, 'animatedAttrs')) {
      const animatedAttributeSplitter = new AnimatedAttributesSplitter(descriptiveIncident, contextData, mcid, contextData.context.getElementSelectorByMCID(mcid), elementData);
      this.addChild(animatedAttributeSplitter, 0);
    } else {
      const attrsToPass = elementData.attrs;
      const propsToPass = elementData.props;
      const constructionIngredients = {
        incidentId: descriptiveIncident.id,
        attrs: attrsToPass,
        props: propsToPass,
        Incident: descriptiveIncident.constructor.Incident,
        plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
        Channel: descriptiveIncident.constructor.Channel,
        DescriptiveIncident: descriptiveIncident
      };
      const contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, mcid, null);
      this.addChild(contextAwareIncident, 0);
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * This Class is the Context Aware Incident for Clips. When constructed, the Incident passed to
 * it is a Clip with HTMLFragmented context handler.
 * On add, edit or deletion of Incidents on the Original Clip's tree ElementClipSplitter implements, all updates on lanes
 * and everything that these clips need in order to run are made directly to the
 * ContextAwareIncidents of the HTMLDescriptiveClip's real Clip.
 */

class ElementClipSplitter extends ElementSplitter {
  constructor(descriptiveIncident, contextData) {
    super(descriptiveIncident, contextData);
    this.realClip = descriptiveIncident.realClip;
  }

  _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {
    // we want to apply stagger (and any other dynamic value assignment method)
    // to the allowed props (duration, hiatus, delay)
    const elementData = this._prepareAttrsPropsForElement(descriptiveIncident, elementIndex // we should prevent @stagger and other dynamic expressions from the attrs of the Clip
    ); // here we create the new OriginalCASIClip if the mock one is used. This happens in cases of @initParams on the props of the Clip


    if (descriptiveIncident.realClip.isNullClip) {
      const definition = { ...descriptiveIncident.exportLiveDefinition(),
        ...elementData
      };
      const tempDC = constructIncident(definition);
      descriptiveIncident.realClip = tempDC.realClip; // we connect the subscriptions of the temporary Descriptive Incident with the one the user created and it's on
      // the descriptive tree

      descriptiveIncident.subscribe(getAnId(), (ms, state) => {
        tempDC._setState(state);
      }, 0, 1, true); // all blocks and unblocks coming to the new (temporary) Descriptive Clip are re-handled and re-generated by the
      // original Descriptive Clip so they can travel all the way up to the Descriptive tree until the root

      tempDC.handleSetBlock = (target, payload) => {
        return descriptiveIncident.putMessageOnPipe('setBlock', { ...payload,
          id: tempDC.id
        }, 'rootClip', {
          selfExecute: true,
          direction: _DIRECTIONS._UP
        });
      };

      tempDC.handleUnBlock = () => {
        return descriptiveIncident.putMessageOnPipe('unBlock', {
          id: tempDC.id
        }, 'rootClip', {
          selfExecute: true,
          direction: _DIRECTIONS._UP
        });
      };
    } // as we are going to create a clip copy we want to take the snapshot of our original clip
    // as it is at the moment. For example in the case of HTMLClip this method will make sure all
    // html attributes applied up to this moment will be reflected on the new clip copy


    const constructionArguments = descriptiveIncident.realClip.exportConstructionArguments();
    const propsToPass = { ...descriptiveIncident.props,
      duration: descriptiveIncident.realClip.duration,
      // the original duration of the real Clip
      ...constructionArguments.props,
      ...elementData.props,
      // if duration is dynamic it will be re-set here, overwriting the line above
      selector: contextData.context.getElementSelectorByMCID(mcid) // runTimeInfo: descriptiveIncident.runTimeInfo,

    };
    /**
     * ElementClipSplitter only uses the props that have been produced by the dynamic value parsing method (elementData)
     * It doesn't use attrs and that's because attrs might contain data that can affect the number of Incidents of the
     * Clip, the html of Clip etc, something we certainly don't want as it's mandatory all of our CASIs to have the exact
     * same structure, html and css. Check the comments below inline
     * @type {{Channel: ClipChannel, DescriptiveIncident, Incident: *, incidentId, plugin_npm_name: *, attrs, props: (*&{duration, runTimeInfo, selector: *})}}
     */

    const constructionIngredients = {
      incidentId: descriptiveIncident.id,
      attrs: constructionArguments.attrs,
      // keeps the original attrs
      props: propsToPass,
      // uses the props produced by the dynamic values' parsing
      Incident: descriptiveIncident.constructor.Incident,
      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
      Channel: ClipChannel,
      DescriptiveIncident: descriptiveIncident
    };
    const contextAwareClipIncident = new ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident);
    this.addChild(contextAwareClipIncident, 0);
  }

}

var version = "9.4.1";

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const intRegexp = new RegExp(/^[-+]?\d+$/);
const validator$1 = new Validator__default["default"]({
  messages: {
    color: "The '{field}' field must be an a valid color! Actual: {actual}",
    measurement: "The '{field}' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: {actual}",
    measurementNotAString: 'measurement - The provided value of {field} is not a string',
    measurementMin: "measurement - The provided value of {field} ({actual}) is smaller than the schema's min",
    measurementMax: "measurement - The provided value of {field} ({actual}) is bigger than the schema's max",
    measurementInt: 'measurement - The provided value of {field} ({actual}) is not an integer'
  },
  useNewCustomCheckerFunction: true
}); // eslint-disable-next-line no-unused-vars

validator$1.add('html', function html(_ref, path, context) {
  let {
    messages
  } = _ref;
  return {
    source: "\n      if(value === null){\n        ".concat(this.makeError({
      type: 'html',
      actual: 'value',
      messages
    }), "\n      } else {\n        return value;\n      }\n    ")
  };
}); // eslint-disable-next-line no-unused-vars

validator$1.add('css', function css(_ref2, path, context) {
  let {
    messages
  } = _ref2;
  return {
    source: "\n      if(value === null){\n        ".concat(this.makeError({
      type: 'css',
      actual: 'value',
      messages
    }), "\n      } else {\n        return value;\n      }\n    ")
  };
});
validator$1.add('measurement', // eslint-disable-next-line no-unused-vars
function measurement(_ref3, path, context) {
  let {
    schema,
    messages
  } = _ref3;
  const measurementRegexp = new RegExp('^[+-]?(\\d+([.]\\d*)?|[.]\\d+)(' + schema.units.join('|') + ')$', 'gi');
  return {
    source: "\n      const validUnits = ['".concat(schema.units.join("','"), "'];\n\n      if(typeof value !== 'string' && !(value instanceof String)){\n        ").concat(this.makeError({
      type: 'measurementNotAString',
      actual: 'value',
      messages
    }), "\n        return ;\n      }\n\n      if(!value.match(").concat(measurementRegexp, ")){\n        ").concat(this.makeError({
      type: 'measurement',
      actual: 'value',
      messages
    }), "\n      } else {\n        var numberPart = value.match(").concat(numberPartRegexp, ")[0];\n        if(").concat(hasOwnProp(schema, 'min'), "){\n          if(").concat(schema.min, " > numberPart){\n            ").concat(this.makeError({
      type: 'measurementMin',
      actual: 'value',
      messages
    }), "\n          }\n        }\n        if(").concat(hasOwnProp(schema, 'max'), "){\n          if(").concat(schema.max, " < numberPart){\n            ").concat(this.makeError({
      type: 'measurementMax',
      actual: 'value',
      messages
    }), "\n          }\n        }\n         if(").concat(hasOwnProp(schema, 'integer'), "){\n          if(!numberPart.match(").concat(intRegexp, ")){\n            ").concat(this.makeError({
      type: 'measurementInt',
      actual: 'value',
      messages
    }), "\n          }\n        }\n      }\n      return value;\n    ")
  };
}); // eslint-disable-next-line no-unused-vars

validator$1.add('color', function color(_ref4, path, context) {
  let {
    messages
  } = _ref4;
  return {
    source: "\n    if(typeof value !== 'string' && !(value instanceof String)){\n      ".concat(this.makeError({
      type: 'measurement',
      actual: 'value',
      messages
    }), "\n      return ;\n    }\n    var option;\n    function isColor(strColor) {\n      if (!option ) {\n        option = new Option().style;\n      }\n      option.color = strColor;\n      const res = option.color !== '';\n      option.color = '';\n      return res;\n    }\n    if(!isColor(value)){\n      ").concat(this.makeError({
      type: 'color',
      actual: 'value',
      messages
    }), "\n    }\n    return value;\n    ")
  };
}); // keep amount for backwards compatibility

validator$1.alias('amount', {
  type: 'number'
});

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const dvs = getDVs();
/**
 * Method checkDynamicValues is the one that is called on runtime in order to check any property for dynamic values
 * This method should:
 * - identify whether or not there is a dynamic value expression present
 * - if it is it should execute the corresponding validation method of the corresponding dynamic value implementation
 * - all validation methods provided by the dynamic values implementations will take in the following arguments:
 * -- value
 * -- logError: function to log errors. The only thing that it'll take as argument is what to log
 * @param value
 * @param errors
 * @param key
 * @param schema
 * @param entryName
 * @param compiledCheckFunct
 * @returns {*}
 */

function checkDynamicValues(value, errors, key, schema, entryName, compiledCheckFunct) {
  const logError = function (txt) {
    errors.push({
      type: schema.type,
      message: txt,
      actual: value
    });
  }; // if the value it's not a string we just pass


  if (!isString(value)) {
    logError('Not a dynamic value expression');
    return;
  }
  /**
   * This method accepts one argument of type array which enums all vals that should be checked against the original
   * definition schema of the property. The only property types that support this method are numbers and measurements
   * @param {array} vals
   * @return {boolean}
   */


  const checkVals = function (vals) {
    if (unsupportedDVTypesSchemaCheck.indexOf(schema.type) >= 0) {
      helper.warning("".concat(schema.type, " does not support checkValues method. Returning true without validation"));
      return true;
    }

    let valid = true;

    for (let i = 0; i < vals.length; i++) {
      const check = compiledCheckFunct({
        [entryName]: vals[i]
      });

      if (check !== true) {
        valid = false;
        errors.push(...check);
      }
    }

    return valid;
  };

  for (let i = 0; i < dvs.length; i++) {
    const dv = dvs[i];

    if (value.trim().startsWith("@".concat(dv.preface))) {
      const staggerValid = dv.validation(value, logError, checkVals, schema);

      if (staggerValid) {
        return value;
      }
    }
  }

  logError('Not a valid dynamic value expression');
}

const dynamicValuesChecker = (schema, entryName) => {
  const compiledCheckFunct = validator$1.compile({
    [entryName]: schema
  }); // fastest-validator's schema must be an object's keys

  return function _checkDynamicValues(value, errors, key) {
    return checkDynamicValues(value, errors, key, schema, entryName, compiledCheckFunct);
  };
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function entryName(path) {
  return path[path.length - 1];
}
/**
 * SchemaAdaptor Class does exactly what its name implies. It adapts the schema (targeting the fastest-validator library)
 * so it better serves the special needs of MotorCortex validation mechanism. In order to keep the initial schema untouched
 * SchemaAdaptor uses the ObjectProxy class (of MC)
 * In more details what our Adaptor does is:
 *  - change all type: 'measurement' attrs to type: 'custom' with 'check' method the custom measurement method of ours
 *  - change all type: 'amount' attrs to type: 'custom' with 'check' method the custom amount method of ours
 *  - change all other types so they have dual check (in fastest-validator this is supported by passing an array as schema
 *      each element of which defines the alternative check). The first check is the one defined by the user while the
 *      second is a check that we add so we validate expressions of type "@initParams.<x>.<y>" and support @initParams
 *      dynamic value everywhere.
 * - The same (multiple checks via array) technique is applied on array .items value
 */


class SchemaAdaptor {
  constructor(schema) {
    this.schema = schema;
    this.adapted = createProxy(schema);
  }
  /**
   * It changes the provided entry in the provided path
   * @param (array) path: The path of the entry in array format
   * @param (object) entry: The entry itself
   */


  entryChange(path, entry) {
    const pathToPass = path.join('.'); // fastest-validator supports array values for multiple alternative schemas for
    // the same attribute

    if (Array.isArray(entry)) {
      for (let i = 0; i < entry.length; i++) {
        this.entryChange(path.concat(["".concat(i)]), entry[i]);
      }

      return;
    }

    switch (entry.type) {
      case 'object':
        this.adapted.setValue(pathToPass, this.createObject(entry, entryName(path)));
        break;

      case 'array':
        this.adapted.setValue(pathToPass, this.createArray(entry, entryName(path)));
        break;

      default:
        this.adapted.setValue(pathToPass, [entry, {
          type: 'custom',
          optional: entry.optional !== false,
          check: dynamicValuesChecker(entry, entryName(path))
        }]);
    }
  }
  /**
   * @param {object} obj: The schema of the array (starting from root)
   * @param {string} name: The name of the entry to be checked
   * @returns {array}: A Proxied representation of the original schema
   */


  createArray(arr, name) {
    const propsLikeShcema = {
      items: arr.items
    };
    const localAdaptor = new SchemaAdaptor(propsLikeShcema);
    const adaptedItems = localAdaptor.adaptSchema();
    return [{ ...arr,
      items: adaptedItems.items
    }, {
      type: 'custom',
      optional: arr.optional !== false,
      check: dynamicValuesChecker(arr, name)
    }];
  }
  /**
   *
   * @param {object} obj: The schema of the object (starting from root)
   * @param {string} name: The name of the entry to be checked
   * @returns {array}: A Proxied representation of the original schema
   */


  createObject(obj, name) {
    var _obj$props;

    const localAdaptor = new SchemaAdaptor((_obj$props = obj.props) !== null && _obj$props !== void 0 ? _obj$props : {});
    const adapted = localAdaptor.adaptSchema();
    return [{ ...obj,
      props: adapted
    }, {
      type: 'custom',
      optional: obj.optional !== false,
      check: dynamicValuesChecker(obj, name)
    }];
  }

  adaptSchema() {
    this.objectPropsChange([], this.schema);
    return this.adapted;
  }
  /**
   *
   * @param {array} path: The path of the keys set to analyse
   * @param {object} obj: This object represents the `props` object of an `object`
   */


  objectPropsChange(path, obj) {
    // for each key of the object
    for (let key in obj) {
      // take the entry
      this.entryChange(path.concat([key]), obj[key]);
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

var validator = {
  compile: function (schema) {
    const adaptor = new SchemaAdaptor(schema, validator$1);
    const adapted = adaptor.adaptSchema();
    return validator$1.compile(adapted);
  },
  validate: function (value, schema) {
    const adaptor = new SchemaAdaptor(schema, validator$1);
    const adapted = adaptor.adaptSchema();
    return validator$1.validate(value, adapted);
  }
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const nu$1 = ['cm', 'mm', 'in', 'px', 'pt', 'pc', 'em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', '%'];
const easingRule = [{
  type: 'string',
  optional: true,
  default: 'linear',
  enum: ['linear', 'easeInQuad', 'easeOutQuad', 'easeInOutQuad', 'easeInCubic', 'easeOutCubic', 'easeInOutCubic', 'easeInQuart', 'easeOutQuart', 'easeInOutQuart', 'easeInQuint', 'easeOutQuint', 'easeInOutQuint', 'easeInSine', 'easeOutSine', 'easeInOutSine', 'easeInExpo', 'easeOutExpo', 'easeInOutExpo', 'easeInCirc', 'easeOutCirc', 'easeInOutCirc', 'easeInElastic', 'easeOutElastic', 'easeInOutElastic', 'easeInBack', 'easeOutBack', 'easeInOutBack', 'easeInBounce', 'easeOutBounce', 'easeInOutBounce']
}, {
  type: 'array',
  optional: true,
  length: 4,
  items: {
    type: 'number'
  }
}];
const idRule = {
  type: 'string',
  empty: false,
  trim: true,
  optional: true
};
const nameRule = {
  type: 'string',
  empty: false,
  trim: true,
  optional: true
};
const selectorRule = {
  type: 'string',
  empty: false,
  optional: false
};
const hostRule = {
  type: 'any',
  optional: false
};
const durationRule = {
  type: 'amount',
  optional: false,
  integer: true,
  min: 0
};
const optionalDurationRule = {
  type: 'amount',
  optional: true,
  integer: true,
  min: 0
};
const repeatsRule = {
  type: 'amount',
  integer: true,
  min: 1,
  optional: true
};
const hiatusRule = {
  type: 'amount',
  integer: true,
  min: 0,
  optional: true
};
const delayRule = {
  type: 'amount',
  integer: true,
  min: 0,
  optional: true
};
const optionalHtmlRule = {
  type: 'html',
  optional: true
};
const optionalCssRule = {
  type: 'css',
  optional: true
};
const fontsRule = {
  type: 'array',
  optional: true,
  items: {
    type: 'object',
    props: {
      type: {
        enum: ['google-font'],
        type: 'string'
      },
      src: {
        type: 'string'
      }
    }
  }
};
const audioSourcesRule = {
  type: 'array',
  items: {
    type: 'object',
    strict: true,
    props: {
      src: 'string',
      id: 'string',
      mcid: {
        type: 'string',
        optional: true
      },
      classes: {
        type: 'array',
        optional: true,
        items: 'string'
      },
      base64: {
        type: 'boolean',
        optional: true
      },
      startValues: {
        optional: true,
        type: 'object',
        props: {
          gain: {
            optional: true,
            type: 'number'
          },
          pan: {
            optional: true,
            type: 'number'
          }
        }
      }
    }
  },
  optional: true
};
const incidentPropsRule = validator.compile({
  id: idRule,
  name: nameRule,
  selector: { ...selectorRule,
    optional: true
  },
  // can have no selector as it might inherit it from Group
  easing: easingRule,
  duration: durationRule,
  startFrom: {
    type: 'amount',
    integer: true,
    min: 0,
    optional: true
  },
  repeats: repeatsRule,
  hiatus: hiatusRule,
  delay: delayRule
});
const containerParamsRule = {
  type: 'object',
  optional: true,
  props: {
    width: {
      type: 'measurement',
      units: nu$1,
      optional: true
    },
    height: {
      type: 'measurement',
      units: nu$1,
      optional: true
    }
  }
};
const audioOnClipsRule = {
  type: 'string',
  enum: ['on', 'off', 'only'],
  optional: true
};
const clipPropsRule = validator.compile({
  props: [{
    type: 'object',
    strict: true,
    props: {
      id: idRule,
      name: nameRule,
      selector: { ...selectorRule,
        optional: true
      },
      repeats: repeatsRule,
      hiatus: hiatusRule,
      delay: delayRule,
      easing: easingRule,
      duration: optionalDurationRule,
      html: optionalHtmlRule,
      css: optionalCssRule,
      audioSources: audioSourcesRule,
      audio: audioOnClipsRule,
      containerParams: containerParamsRule,
      fonts: fontsRule,
      initParams: {
        type: 'object',
        optional: true
      }
    }
  }, {
    type: 'object',
    strict: true,
    props: {
      id: idRule,
      name: nameRule,
      host: hostRule,
      duration: optionalDurationRule,
      html: optionalHtmlRule,
      css: optionalCssRule,
      audioSources: audioSourcesRule,
      audio: audioOnClipsRule,
      containerParams: containerParamsRule,
      fonts: fontsRule,
      initParams: {
        type: 'object',
        optional: true
      },
      initParamsValidationRules: {
        type: 'object',
        optional: true
      }
    }
  }, {
    type: 'object',
    strict: true,
    props: {
      root: {
        type: 'boolean',
        optional: true
      },
      name: nameRule,
      id: idRule,
      audioSources: audioSourcesRule,
      audio: { ...audioOnClipsRule,
        enum: ['on']
      }
    }
  }]
});
const groupPropsRule = validator.compile({
  selector: { ...selectorRule,
    optional: true,
    strict: true
  },
  name: nameRule
});
const comboPropsRule = validator.compile({
  selector: { ...selectorRule,
    strict: true,
    optional: true
  },
  name: nameRule,
  repeats: {
    type: 'amount',
    integer: true,
    min: 1,
    optional: true
  },
  hiatus: {
    type: 'amount',
    integer: true,
    min: 0,
    optional: true
  },
  delay: {
    type: 'amount',
    integer: true,
    min: 0,
    optional: true
  }
});
validator.compile({
  selector: selectorRule,
  duration: durationRule
});

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _TARGETTYPES = {
  _DECISIONAUTHORITY: 'mc.descriptive.decisionAuthority'
};

class DescriptiveGroup extends Node {
  constructor() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (props === null) {
      super(attrs);
      this.attrs = {};
      this.props = attrs;
    } else {
      super(props);
      this.attrs = attrs;
      this.props = props;
    }

    const propsValidation = validateProps(this.props, groupPropsRule, this.constructor);

    if (!propsValidation.result) {
      return propsValidation;
    }

    this._inheritedSelector = null;
    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class
    Similarly, propsStaggers hold the same info only this time for props
    */

    this.attributesStaggers = [];
    this.propsStaggers = [];
    this.setupDynamicValues(); // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)

    this.passiveAddition = true;

    this._buildTree();

    this.passiveAddition = false;
  }

  _buildTree() {
    this.buildTree();
  }
  /*
  Overwrites _calculateDuration of Node so it handles dynamic durations
  @param {boolean} forceGroups: if is set to true all Groups must recalc their
    duration, no matter if they have other Groups on their tree that also have
    duration = "dynamic"
  */


  _calculateDuration() {
    let forceGroups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let duration = 0;

    for (const childKey in this.children) {
      const child = this.children[childKey];

      if (forceGroups === true && child.leaf.constructor.isGroup === true) {
        child.leaf._calculateDuration(true);
      }

      if (child.leaf.duration === 'dynamic') {
        duration = 'dynamic';
        break;
      }

      if (child.position + child.leaf.duration > duration) {
        duration = child.position + child.leaf.duration;
      }
    }

    if (duration === this.calculatedDuration) {
      return false;
    }

    this.calculatedDuration = duration; // this method is inherited from Node

    this.resetDuration();
    return true;
  }

  _rebuildTree() {
    // remove all direct passive incidents as they might be dependent on the edited attrs/props
    for (const id in this.children) {
      const theChild = this.children[id];

      if (theChild.leaf.passive === true) {
        this.removeIncident(theChild.id);
      }
    } // run buildTree again


    this.passiveAddition = true;
    this.buildTree();
    this.passiveAddition = false;
  }

  buildTree() {}

  get duration() {
    if (this.calculatedDuration === 'dynamic') {
      return this.calculatedDuration;
    }

    return super.duration;
  }

  set duration(milliseconds) {
    super.duration = milliseconds;
  }

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const {
      parentNode
    } = this; // get the position of the Incident within its parent

    const position = parentNode.getLeafPosition(this.id); // keep a backup of the current attrs / props

    const oldAttrs = deepCopy(this[type]);
    this[type] = newAttrs; // first detach the Incident from its parent

    parentNode.removeIncident(this.id); // remove all direct passive incidents as they might be dependent on the edited attrs/props

    this._rebuildTree(); // try to add the altered Group


    const res = parentNode.addIncident(this, position);

    if (!res.result) {
      this[type] = oldAttrs;

      this._rebuildTree();

      parentNode.addIncident(this, position);
    } // this method is inherited from Node


    this.resetDuration();
    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  get inheritedSelector() {
    return this._inheritedSelector;
  }

  set inheritedSelector(value) {
    this._inheritedSelector = value;

    for (const id in this.children) {
      const theChild = this.children[id].leaf;
      theChild.inheritedSelector = this.selector();
    }
  }

  get selectorToPassToChildren() {
    return this.selector();
  }
  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */


  exportDefinition() {
    const toReturn = {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props,
      incidents: {},
      duration: this.duration
    };

    for (const id in this.children) {
      const theChild = this.children[id];

      if (theChild.leaf.passive === true) {
        continue;
      }

      toReturn.incidents[id] = {
        id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportDefinition()
      };
    }

    return toReturn;
  }
  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */


  exportLiveDefinition() {
    let includeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let propsToReturn = deepCopy(this.props);

    if (!includeId) {
      delete propsToReturn.id;
    }

    const toReturn = {
      Class: this.constructor,
      attrs: deepCopy(this.attrs),
      props: propsToReturn,
      incidents: {}
    };

    for (const id in this.children) {
      const theChild = this.children[id];

      if (theChild.leaf.passive === true) {
        continue;
      }

      toReturn.incidents[id] = {
        // id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportLiveDefinition(includeId)
      };
    }

    return toReturn;
  }

  addIncident(descriptiveIncident, position) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      check: true
    };

    if (!(descriptiveIncident instanceof Leaf)) {
      helper.warning('addIncident rejected, invalid incident provided');
      return {
        result: false,
        errors: 'Invalid Incident provided'
      };
    }

    descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;
    let checkIfBelongsToClip;

    if (options.check === true) {
      const initialCheck = super.checkAddition(descriptiveIncident, position);

      if (!initialCheck.result) {
        descriptiveIncident.inheritedSelector = null;
        return initialCheck;
      }
      /* Check for null or relative selector Incidents with no inherited selector */


      checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {
        selfExecute: true,
        direction: _DIRECTIONS._UP
      });

      if (checkIfBelongsToClip.response === true) {
        // if the Group belongs on a Clip
        const selectorsCheck = descriptiveIncident.putMessageOnPipe('checkForInvalidSelectors', {}, null, {
          selfExecute: true,
          direction: _DIRECTIONS._DOWN
        });

        if (selectorsCheck.length > 0) {
          const errors = [];

          for (let i = 0; i < selectorsCheck.length; i++) {
            errors.push(selectorsCheck[i].response);
          }

          return {
            result: false,
            errors
          };
        }
      } // sends the check request to its root, either a headless root or a Descriptive Clip


      const mcCheck = this.putMessageOnPipe('checkAddition', {
        incident: descriptiveIncident,
        millisecond: position,
        parentGroupId: this.id
      }, _TARGETTYPES._DECISIONAUTHORITY, {
        selfExecute: true,
        direction: _DIRECTIONS._UP
      });

      if (!mcCheck.response.result) {
        helper.error({
          message: 'addIncident rejected',
          incident: {
            attrs: descriptiveIncident.attrs,
            props: descriptiveIncident.props
          },
          position,
          conflicts: mcCheck.response.errors
        });
        descriptiveIncident.inheritedSelector = null;
        return mcCheck.response;
      }
    } // if the passiveAddition flag is true we set the passive flag of the Incident
    // to true before adding it to our Group


    if (this.passiveAddition === true) {
      descriptiveIncident.passive = true;
    }

    const res = this.addChild(descriptiveIncident, position);

    if (!res.result) {
      descriptiveIncident.inheritedSelector = null;
    } // if it has dynamic duration but now it belongs to a Clip all Groups should
    // dynamically recal their duration


    if (descriptiveIncident.duration === 'dynamic' && checkIfBelongsToClip) {
      this._calculateDuration(true);
    }

    return res;
  }
  /**
   * @param input - can either be object or id
   * */


  moveIncident(input, position) {
    let id = input;

    if (isObject(input)) {
      id = input.id;
    }

    const initialCheck = super.checkEditPosition(id, position);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const originalPosition = this.getLeafPosition(id);
    const positionDelta = position - originalPosition;

    if (positionDelta === 0) {
      return {
        result: true
      };
    }

    const mcCheck = this.putMessageOnPipe('checkMove', {
      id,
      millisecond: position,
      positionDelta,
      parentGroupId: this.id
    }, _TARGETTYPES._DECISIONAUTHORITY, {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });

    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    return this.editPosition(id, position);
  }

  removeIncident(input) {
    let id = input;

    if (isObject(input)) {
      id = input.id;
    }

    const initialCheck = super.checkRemoveChild(id);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const mcCheck = this.putMessageOnPipe('checkDeletion', {
      id,
      parentGroupId: this.id
    }, _TARGETTYPES._DECISIONAUTHORITY, {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });

    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    return this.removeChild(id);
  }
  /** ************************* HANDLING METHODS ****************************** */
  // eslint-disable-next-line no-unused-vars


  handleCheckForClip(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return false;
  } // eslint-disable-next-line no-unused-vars


  handleCheckAddition(target, payload) {
    /*
        The DescriptiveGroup handles the checkAddition command which has the UP
        direction. If the DG has a parent it forwards the command to it. If not
        it just returns true, as it is a deadless tree
        */
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true
    };
  } // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions


  handleCheckMove(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true
    };
  } // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions


  handleCheckDeletion(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true
    };
  } // eslint-disable-next-line no-unused-vars,sonarjs/no-identical-functions


  handleCheckResize(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true
    };
  } // eslint-disable-next-line no-unused-vars


  handleSetDurationDynamic(target, payload) {
    this.calculatedDuration = 'dynamic';
    this.putMessageOnPipe('setDurationDynamic', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
  }

}

_defineProperty__default["default"](DescriptiveGroup, "Incident", Group);

_defineProperty__default["default"](DescriptiveGroup, "plugin_npm_name", _MC_Plugin_Name);

_defineProperty__default["default"](DescriptiveGroup, "version", version);

_defineProperty__default["default"](DescriptiveGroup, "Channel", Channel);

_defineProperty__default["default"](DescriptiveGroup, "ClassName", 'Group');

_defineProperty__default["default"](DescriptiveGroup, "isGroup", true);

_defineProperty__default["default"](DescriptiveGroup, "attrsValidationRules", null);

_defineProperty__default["default"](DescriptiveGroup, "propsValidationRules", groupPropsRule);

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const dot = '-';
const CascadingHanlder = {
  isCombo: function (item) {
    return item.incidentClass.isCombo;
  },
  getItem: function (descriptiveIncident, path) {
    return getFromNameSpace(path.join('.'), 'attrs', descriptiveIncident);
  },

  getRepeatPosition(delay, hiatus, duration, index) {
    return index * (hiatus || 0) + (index + 1) * (delay || 0) + index * duration;
  },

  /**
   * Combo Incident's children, defined strictly on its attrs.incidents attribute,
   * might or might not have a selector. If they don't they are directly applied to
   * the elements of the Combo's selection.
   * Also, Combos might host other Combos on their attrs.incidents, which may host
   * others and so on. The selection inheritance is spread down all the way, as soon
   * as no selector is defined on the children-Combos.
   * The purpose of this method is to decide whether a given path of the descriptive
   * incident's attrs refer directly to the Combo's element
   **/
  refersToOwnSelector: function (descriptiveIncident, path) {
    let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let arPath = path;

    if (Array.isArray(path) === false) {
      arPath = path.split('.');
    }

    const item = this.getItem(descriptiveIncident, arPath.slice(0, 2 + startIndex)); // the item always points to an Incident defined on a Combo's attributes
    // if the item has selector return false

    if (item.props.selector !== '' && item.props.selector !== undefined && item.props.selector !== null) {
      return false;
    } else if (arPath[2] === 'props') {
      // else if the dynamic value is applied to its props, look no further, return true
      return true;
    } else if (!this.isCombo(item)) {
      // else if the item is not a combo then return true
      return true;
    } else {
      return this.refersToOwnSelector(descriptiveIncident, arPath, startIndex + 3);
    }
  },

  /**
   * Takes as input the rootSelector and the incidents. Returns a list of paths
   * and values that should be applied on the incidents
   * e.g.
   * [
   *  {
   *    path: "0.props.selector",
   *    value: "new selector"
   *  }, ...
   * ]
   **/
  cascadeSelectors(rootSelector, incidents) {
    let initialPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let changes = [];

    for (let i = 0; i < incidents.length; i++) {
      const item = incidents[i];
      let selectorToApply;

      if (hasOwnProp(item.props, 'selector')) {
        selectorToApply = "".concat(rootSelector, " ").concat(item.props.selector);
      } else {
        selectorToApply = rootSelector;
      }

      changes.push({
        path: "".concat(initialPath).concat(initialPath === '' ? '' : '.').concat(i, ".props.selector"),
        value: selectorToApply
      });

      if (this.isCombo(item)) {
        const nestedChanges = this.cascadeSelectors(selectorToApply, item.attrs.incidents, "".concat(initialPath).concat(initialPath === '' ? '' : '.').concat(i, ".attrs.incidents"));
        changes = changes.concat(nestedChanges);
      }
    }

    return changes;
  },

  /**
   * Takes in an Incident defined in the supported format of the Combo attrs and
   * returns an object that has all the necessary properties in order to be further
   * used by the standard analysis process, further down the way. The necessary properties
   * to have are:
   * - audio
   * - attrs
   * - props
   * - id
   * - selector
   * - selector()
   * - audioClip
   * - constructor.Incident
   * - constructor.plugin_npm_name
   * - constructor.Channel
   * - constructor.isClip
   * - attributesStaggers
   * - propsStaggers
   * - dynamicDurationValue
   **/
  createDescriptiveIncidentLikeObject(incident, attributesStaggers, propsStaggers, attrs, props) {
    return {
      constructor: {
        Incident: incident.incidentClass.targetClass.Incident,
        plugin_npm_name: incident.incidentClass.targetClass.plugin_npm_name,
        Channel: incident.incidentClass.targetClass.Channel,
        isClip: false
      },
      attrs: attrs || incident.attrs,
      props: props || incident.props,
      selector: () => incident.props.selector,
      id: incident.props.id,
      audioClip: null,
      audio: 'no',
      dynamicDurationValue: null,
      putMessageOnPipe: doNothing,
      attributesStaggers: attributesStaggers,
      propsStaggers: propsStaggers
    };
  },

  parseElementsDynamics(staggerAttrs, originalAttrs, originalProps, elementIndex, incidentIndex) {
    const attrsStartPattern = "incidents.".concat(incidentIndex, ".attrs");
    const propsStartPattern = "incidents.".concat(incidentIndex, ".props");
    const attrsProxy = createProxy(originalAttrs);
    const propsProxy = createProxy(originalProps);

    for (let i = 0; i < staggerAttrs.length; i++) {
      if (staggerAttrs[i].path.indexOf(attrsStartPattern) === 0) {
        const path = staggerAttrs[i].path.substring(attrsStartPattern.length + 1);
        attrsProxy.setValue(path, staggerAttrs[i].values[elementIndex]);
      } else if (staggerAttrs[i].path.indexOf(propsStartPattern) === 0) {
        const path = staggerAttrs[i].path.substring(propsStartPattern.length + 1);
        propsProxy.setValue(path, staggerAttrs[i].values[elementIndex]);
      }
    }

    return {
      incidentAttrs: attrsProxy.exportFlattened(),
      incidentProps: propsProxy.exportFlattened()
    };
  },

  /**
   * Gets a list of dynamics in the form (example):
   * [
   *  {
   *    path: "incidents.<index>.attrs.alpha",
   *    stagger: [StaggerClass] // or ElementAttributeC, MathC
   *  }
   * ] (This type of information is stored on the properties "attributesStaggers" and
   *    "propsStaggers" of any DescriptiveIncident)
   * the index of the incident (on the attrs.incidents array, needed for path resolving)
   * and the type of data (either attrs or props) of our Combo that the dynamic
   * lives in. (It helps us easily separate attrributesStaggers from propsStaggers)
   **/
  getStaggersForChild(attributesStaggers, index, type) {
    const remainingDynamics = [];
    const identifiedDynamics = [];

    for (let i = 0; i < attributesStaggers.length; i++) {
      // if the path of the dynamic starts with "incidents.<index>.<type>", e.g.
      // incidents.0.attrs we pass the dynamic to the child otherwise we keep it
      // on our remaining attributesStaggers
      if (type === 'position' && attributesStaggers[i].path.indexOf("incidents.".concat(index, ".").concat(type)) === 0) {
        identifiedDynamics.push({
          path: 'position',
          stagger: attributesStaggers[i].stagger
        });
      } else if (attributesStaggers[i].path.indexOf("incidents.".concat(index, ".").concat(type)) === 0) {
        identifiedDynamics.push({
          path: attributesStaggers[i].path.substring("incidents.".concat(index, ".").concat(type).length + 1),
          stagger: attributesStaggers[i].stagger
        });
      } else {
        remainingDynamics.push(attributesStaggers[i]);
      }
    }

    return {
      identifiedDynamics,
      remainingDynamics
    };
  },

  createElementProxy(descriptiveIncident, selector, elementIndex, staggerAttrs, staggerProps) {
    const elementProxy = createProxy(descriptiveIncident);
    /* we need to apply selector's cascading down to the Combo's attrs.incidents tree.
     For this we gather all selector changes that should be applied on an array (a collection)
     containing {path, value} pairs, totally compatible for feeding our proxy.
    */

    const selectorChanges = this.cascadeSelectors(selector, descriptiveIncident.attrs.incidents, 'attrs.incidents');
    /* we need to apply changes on the tree coming from the element's dynamic values (e.g. stagger)
      ElementComboSplitter has this information as :
        this.staggerProps and this.staggerAttrs (that have been calculated by the methods
        this.parsePropsDynamicValues and this.parseAttrsDynamicValues that ran on setUp).
        this.staggerProps and this.staggerAttrs, each are arrays holding {path, values}
        entries. Each entry has the path to the attr or prop and an array with the values
        that should be applied in all of the elements (e.g. values[100, 110, 120])
    */
    // we now feed our changes to our ObjectProxy

    for (let i = 0; i < staggerAttrs.length; i++) {
      elementProxy.setValue("attrs.".concat(staggerAttrs[i].path), staggerAttrs[i].values[elementIndex]);
    }

    for (let i = 0; i < staggerProps.length; i++) {
      elementProxy.setValue("props.".concat(staggerProps[i].path), staggerProps[i].values[elementIndex]);
    }

    for (let i = 0; i < selectorChanges.length; i++) {
      elementProxy.setValue(selectorChanges[i].path, selectorChanges[i].value);
    } // and we are now good to proceed with the implementation of our element-specific Combo
    // with all the selectors and the dynamic values already parsed for it


    return elementProxy;
  }

};

class ElementComboSplitter extends ElementSplitter {
  // only puts on its staggerAttrs the staggers that refer to its own elements
  parseAttrsDynamicValues(descriptiveIncident, elements) {
    this.childrenStaggers = [];

    for (let i = 0; i < descriptiveIncident.attributesStaggers.length; i++) {
      if (CascadingHanlder.refersToOwnSelector(descriptiveIncident, descriptiveIncident.attributesStaggers[i].path)) {
        this.staggerAttrs.push({
          path: descriptiveIncident.attributesStaggers[i].path,
          values: descriptiveIncident.attributesStaggers[i].stagger.calculateValues(elements, this.initParams)
        });
      } else {
        this.childrenStaggers.push(descriptiveIncident.attributesStaggers[i]);
      }
    }
  }
  /*
   * handleRecalDuration method is called after a successful addition.
   * Thus this is the chance and the point where the ElementsSplitter can update
   * the dynamicDurationValue of its DescriptiveIncident
   */


  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);
    this.descriptiveIncident.dynamicDurationValue = this.duration * 1;
    return res;
  }
  /*
   * lastWish is called when and Incident gets detached from a Clip. ElementsComboSplitter overwrites
   * the default lastWish coming from Group so it clears the dynamicDurationValue from its
   * DescriptiveIncident
   */


  lastWish() {
    this.descriptiveIncident.dynamicDurationValue = null;
    this.descriptiveIncident.putMessageOnPipe('setDurationDynamic', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
    super.lastWish();
  }

  _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {
    // let's frist create a proxy of the descriptive incident (to apply element-specific changes)
    // so we can mess with it without affecting our original data at all.
    const elementDI = CascadingHanlder.createElementProxy(descriptiveIncident, contextData.context.getElementSelectorByMCID(mcid), elementIndex, this.staggerAttrs, this.staggerProps);

    for (let i = 0; i < this.staggerAttrs.length; i++) {
      elementDI.setValue("attrs.".concat(this.staggerAttrs[i].path), this.staggerAttrs[i].values[elementIndex]);
    } // we then create a real Group instance that represents / contains all of the action of the element


    const elementGroup = incidentFromIngredients({
      id: "".concat(this.id, "_element").concat(dot).concat(elementIndex),
      attrs: {},
      props: {},
      Incident: DescriptiveGroup.Incident,
      plugin_npm_name: DescriptiveGroup.plugin_npm_name,
      Channel: DescriptiveGroup.Channel,
      DescriptiveIncident: new DescriptiveGroup()
    }); // then we create Groups, one per elementDI's repeats, we fill them with the
    // incidents of attrs.incidents array. We will position each according to
    // the delay and hiatus of elementDI

    for (let repeatIndex = 0; repeatIndex < (elementDI.props.repeats || 1); repeatIndex++) {
      const repeatGroup = incidentFromIngredients({
        id: "".concat(this.id, "_element").concat(dot).concat(elementIndex, "_repeat").concat(dot).concat(repeatIndex),
        attrs: {},
        props: {},
        Incident: DescriptiveGroup.Incident,
        plugin_npm_name: DescriptiveGroup.plugin_npm_name,
        Channel: DescriptiveGroup.Channel,
        DescriptiveIncident: new DescriptiveGroup()
      }); // --- we handle the iteration on elementDI.attrs.incidents array ---
      // we will divide the identified staggers of our Combo by passing down to each
      // incident only the ones that concern it. For performance reasons instead of
      // iterating for each incident to the full list of the attributesStaggers
      // the getStaggersForChild method always returns the remaining (not matched) so we can
      // use them instead for every next child/incident.
      // remainingStaggers just represent the reduced original attributesStaggers after each child filtering

      let remainingStaggers = this.childrenStaggers;
      elementDI.attrs.incidents.forEach((incident, incidentIndex) => {
        const {
          incidentAttrs,
          incidentProps
        } = CascadingHanlder.parseElementsDynamics(this.staggerAttrs, incident.attrs, incident.props, elementIndex, incidentIndex);
        const inc_attrsStaggersResult = CascadingHanlder.getStaggersForChild(remainingStaggers, incidentIndex, 'attrs');
        const inc_propsStaggersResult = CascadingHanlder.getStaggersForChild(inc_attrsStaggersResult.remainingDynamics, incidentIndex, 'props');
        const inc_positionStaggersResult = CascadingHanlder.getStaggersForChild(inc_attrsStaggersResult.remainingDynamics, incidentIndex, 'position');
        remainingStaggers = inc_propsStaggersResult.remainingDynamics; // assign id to our incident

        elementDI.setValue("attrs.incidents.".concat(incidentIndex, ".props.id"), "".concat(this.id, "_element").concat(dot).concat(elementIndex, "_repeat").concat(dot).concat(repeatIndex, "_incident").concat(dot).concat(incidentIndex)); // we now have all the data needed to create a DescriptiveIncident - like object
        // reprensenting our incident

        const inc_di = CascadingHanlder.createDescriptiveIncidentLikeObject(incident, inc_attrsStaggersResult.identifiedDynamics, inc_propsStaggersResult.identifiedDynamics, incidentAttrs, incidentProps);
        const inc_incident = incidentFromDescription(inc_di, contextData);
        let position = incident.position;

        if (inc_positionStaggersResult.identifiedDynamics.length === 1) {
          position = inc_positionStaggersResult.identifiedDynamics[0].stagger.calculateValues(new Array(totalElements), this.initParams)[elementIndex];
        }

        repeatGroup.addChild(inc_incident, position);
      }); // now that we have our repeat Group ready we only have to position it on
      // the elementGroup taking in consideration the hiatus, the delay of the
      // elementDI as well as the index of the iteration itself

      elementGroup.addChild(repeatGroup, CascadingHanlder.getRepeatPosition(elementDI.props.delay, elementDI.props.hiatus, repeatGroup.duration, repeatIndex));
    }

    this.addChild(elementGroup, 0);
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * Creates a real Incident (with all of its real tree) out of the Descriptive Incident.
 * @param {object} descriptiveIncident - the Descriptive Incident that defines the Incident
 * @param {contextData} - the context data (object containing id and actual context) to be used for real
 *      Incidents init
 * @returns {object} - the real Incident
 * */

function incidentFromDescription(descriptiveIncident, contextData) {
  /*
  RULES:
  - Clips can only have selectors (and not hosts) as they participate on a Desc. TimedTree
      and thus they are Clips As Incidents. The DescriptiveClips are treated a bit
      different compared to the rest of the Incidents as they copy all of the
      Description channels and lanes
  - Descriptive Incidents can either have or not have selectors
  - Descriptive Compos always have selectors
   All Incidents of the tree, no matter their type have the static properties:
  - Incident (which is the Incident class they need to initialise)
  - plugin_npm_name (the plugin name they bolong to)
  - Channel (the Channel class to handle the instance)
  */

  /* check for the descriptive incident and audio compatibility. If audio is true then we're
    working on the audioClip and we need incidents that are at least "on" while if the audio==false
    and we are working on the real tree then we reject the cases that the incident is audio "only".
    This check is targeting the top-level Incidents, the Clips, which are the ones that have the
    "audio" property.
  */
  const audio = contextData.context.audio;
  /*
  if it is on audio context and descriptive incident's audio cpabilities are set to "off"
  or if it's not on audio context and the descriptive incident is audio only
   */

  if (!!audio && descriptiveIncident.audio === 'off' || !audio && descriptiveIncident.audio === 'only') {
    return null;
  }

  let incidentToReturn;
  /*
  if it has a selector and
    it's not audio context but the selector starts with "~"
    or we are on audio context and the selector doesn't start with "~"
      and the Incident is not a clip
   */

  if (hasOwnProp(descriptiveIncident.props, 'selector') && (!audio && descriptiveIncident.props.selector.charAt(0) === '~' || !!audio && descriptiveIncident.props.selector.charAt(0) !== '~' && !descriptiveIncident.constructor.isClip)) {
    return null;
  }

  if (descriptiveIncident.constructor.isClip) {
    if (hasOwnProp(descriptiveIncident.props, 'selector') && !audio) {
      incidentToReturn = new ElementClipSplitter(descriptiveIncident, contextData);
      incidentToReturn.plugin_channel_class = Channel;
    } else {
      // TODO This block needs review
      if (audio) {
        return descriptiveIncident.audioClip; // here we are
      }

      return descriptiveIncident.realClip;
    }
  } else if (descriptiveIncident.constructor.isCombo) {
    incidentToReturn = new ElementComboSplitter(descriptiveIncident, contextData);
  } // else if (descriptiveIncident.constructor.Incident === Group) {
  else if (descriptiveIncident.constructor.isGroup) {
    incidentToReturn = incidentFromIngredients({
      id: descriptiveIncident.id,
      attrs: descriptiveIncident.attrs,
      props: descriptiveIncident.props,
      Incident: descriptiveIncident.constructor.Incident,
      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
      Channel: descriptiveIncident.constructor.Channel,
      DescriptiveIncident: descriptiveIncident
    });

    for (const incId in descriptiveIncident.children) {
      const childIncident = incidentFromDescription(descriptiveIncident.children[incId].leaf, contextData);

      if (childIncident === null) {
        continue;
      }

      incidentToReturn.addChild(childIncident, descriptiveIncident.children[incId].position);
    }
  } else {
    // if it is an Incident that extends the Incident (not a Group) then
    // we should anaylse it to its element/attribute Incidents starting from
    // the elements, that's why we create an ElementSplitter. It is our
    // starting point to which the Incident will be analysed to its
    // element/attributes children.
    incidentToReturn = new ElementSplitter(descriptiveIncident, contextData);
  }

  return incidentToReturn;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const selfContainedIncidentsNpmName = '@donkeyclip/self-contained-incidents';

function turnIntoReturnExecuteFunction(toReturnExecutables) {
  return function toReturnExecuteFunct() {
    for (let i = 0; i < toReturnExecutables.length; i++) {
      toReturnExecutables[i]();
    }
  };
}
/**
 * As its name implies, ExtendableClip's one and only use is to extend it in order
 * to create new Clip types. All channel handling, add / edit / remove / resize checks are
 * handled by ExtendableClip itself.
 * ExtendableClip's only need is the this.ownContext property to be defined. All
 * of the class's functionality is based on this object. The expected keys of this object
 * are the following:
 * {
 *  getElements()
 *  getMCID()
 *  setMCID()
 *  getElementSelectorByMCID()
 *  getElementByMCID()
 *  isHostedClip
 *  contextLoaded
 *  unmout()
 * }
 * Clips that extend ExtendableClip need to define this property ("this.ownContext")
 * on their constructor. ExtendableClip itself does NOT define this.ownContext and
 * thus it's not meant to be used alone/directly.
 **/


class ExtendableClip extends Group {
  /**
   * @param {object} attrs - an object with the attrs exactly as passed by the user to the HTMLDescriptiveClip
   * @param {object} props - an object that should contain all of the props passed to the HTMLDescriptiveClip plus:
   * - runTimeInfo: the runTimeInfo of its corresponding Descriptive Clip
   * @param {DescriptiveClip} DescriptiveIncident: the Descriptive Clip of the Clip, itself
   */
  constructor(attrs, props, DescriptiveIncident) {
    super(attrs, props);
    this.attrs = attrs;
    this.props = props;
    this.DescriptiveIncident = DescriptiveIncident;
    this.blockingWaitings = {};
    /**
     * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
     * this attribute is only valuable when the Group becomes the Clip
     * The format of the attribute is:
     *  key-value pairs in the manner:
     * <mc_plugin_npm_name>: Channel object
     */

    this.instantiatedChannels = {};
    this.isHostedClip = true;
    /**
     * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
     * contexts of all instantiated ClipCopies
     * */

    this.instantiatedCopiesContexts = {};
    this.onClipInitialise();
    this.runTimeInfo = this.props.runTimeInfo;
    this.durationSubs = [];
  }

  get contextReady() {
    return this.context.contextLoaded;
  }

  onClipInitialise() {// called when group gets initialised
  }
  /*********************************************************
    Context loading and the contextReady parameter
    *********************************************************
  There are cases that the Clip might need time in order to prepare its context,
  such as asynch sources loading. For this reason we use the contextReady parameter,
  which is set to true by default, and which can change state by the use of the two
  methods: contextLoading and contextLoaded.
  When contextLoading method is executed and the context gets to the loading state
  Incidents might be added to the Clip. While contextReady is set to false the
  onGetContext method of MonoIncidents and ClipCopies will be postponed and run when the context
  is actually loaded
  */


  contextLoading() {
    // this.contextReady is used on onProgress. If it's set to false it blocks the execution
    this.context.contextLoaded = false;
  }
  /**
   * This method will be invoked once the context (that is currently loading) has
   * finished loading. In case the Clip is been used as CAsI, ClipCopies might
   * have fired block() so they need to get unblocked. If so, the instantiatedCopiesUnblockingMethods
   * variable will contain the unblocking methods of them and the method will
   * execute them.
   **/


  contextLoaded() {
    this.context.contextLoaded = true;
    this.putMessageOnPipe('contextLoaded', {}, {}, {
      selfExecute: false,
      direction: _DIRECTIONS._DOWN
    });

    for (const key in this.instantiatedChannels) {
      this.instantiatedChannels[key].recalcScratchValues();
    }

    this.unblock(this.clipCopyId || null);
  }

  getElements(selector) {
    if (this.props.host !== null && this.props.host !== undefined) {
      return this.context.getElements(selector);
    }

    const elements = [];

    for (const contextKey in this.instantiatedCopiesContexts) {
      const contextElements = this.instantiatedCopiesContexts[contextKey].getElements(selector);

      for (let i = 0; i < contextElements.length; i++) {
        elements.push(contextElements[i]);
      }
    }

    return elements;
  }
  /**
   * This method is been called when a new _ClipCopy enters the real tree successfully.
   * @param {object} contextData - keys: clipId, context
   * */


  addContext(contextData) {
    this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
    contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
    return this.putMessageOnPipe('addContext', contextData, {}, {
      selfExecute: false,
      direction: _DIRECTIONS._DOWN
    });
  }
  /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */


  exportConstructionArguments() {
    return {
      attrs: this.attrs,
      props: this.props
    };
  }
  /**
   * completely resizes the Clip without any checks
   */


  _resize(durationFraction) {
    for (const key in this.instantiatedChannels) {
      this.instantiatedChannels[key]._resize(durationFraction);
    }

    this.setNewDuration(this.duration * durationFraction);

    for (let i = 0; i < this.durationSubs.length; i++) {
      this.durationSubs[i](this.duration);
    }
  }
  /** *******************************************************
    Editing commands input methods
    ******************************************************** */

  /**
   * This command is proxied form the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  incident: the Descriptive Incident to be added
   *  millisecond: the millisecond to add it
   *  targetGroupId: the id of the Group to which we want to the Incident to be placed
   * }
   */


  addIncident(payload) {
    const candidates = this.putMessageOnPipe('addIncident', {
      incident: payload.incident,
      millisecond: payload.millisecond,
      incidentFromDescription: incidentFromDescription,
      contextData: {
        clipId: this.id,
        context: this.context,
        instantiatedCopiesContexts: this.instantiatedCopiesContexts
      }
    }, payload.parentGroupId, {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN
    }); // concatenate candidates

    const totalIncidentsByPlugin = {};

    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }

        totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
      }
    }

    const res = this.checkAddition(totalIncidentsByPlugin);

    if (res.result) {
      const successCallback = () => {
        res.execute(); // up to that point the only context Incident that has been initialised on the
        // ContextAwareIncidents of the candidates is the original context of the
        // ExtendableClip.

        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.addChild(candidates[i].response, payload.millisecond); // recalculate duration the groups that we added
          // the incidents to along with their parents

          candidates[i].responder.putMessageOnPipe('recalcDuration', {
            childId: candidates[i].response.id
          }, 'Groups', {
            selfExecute: true,
            direction: _DIRECTIONS._UP
          }); // we also need to add every existing (copied) context to the ContextAwareIncidents
          // created on the candidates process

          for (const contextKey in this.instantiatedCopiesContexts) {
            candidates[i].response.putMessageOnPipe('addContext', {
              clipId: contextKey,
              context: this.instantiatedCopiesContexts[contextKey]
            }, 'ContextAwareIncidents', {
              selfExecute: false,
              direction: _DIRECTIONS._DOWN
            });
          }
        }
      };

      return {
        result: true,
        execute: successCallback
      };
    }

    return res;
  } // *******************************************************
  // INCIDENTS MANAGEMENT METHODS

  /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */


  checkAddition(incidentsById) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all-or-nothing';
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = []; // for each key of the incidentsById object perform the check

    for (const npmName in incidentsById) {
      // if the clip had no channel instantiated for the specific key (plugin id) yet create it
      if (!hasOwnProp(this.instantiatedChannels, npmName)) {
        // instantiate the channel of the plugin by using the reference to the class definition which can be found on
        // the Incidents of the plugin. Incidents of the plugin can be found easily here on incidentsById[npmName]
        // an array that holds all of them, and just take the info from the first (0 index), as it'll certainly exist
        const Channel = incidentsById[npmName][0].incident.plugin_channel_class;
        this.instantiatedChannels[npmName] = new Channel({
          runTimeInfo: this.runTimeInfo,
          context: this.context,
          subscribe: this.DescriptiveIncident.subscribe.bind(this.DescriptiveIncident) // all channels can subscribe to state or current millisecond changes. This is very useful for Channels
          // such as MediaPlayback as listening to state changes is mandatory to start or stop play. The only timer AND
          // the single source of truth in terms of the play state of a Clip in MC is the HTMLDescriptiveClip.
          // Thus we pass to the Channels a the subscribe method of HTMLDescriptiveClip itself so they have direct access

        });
      } // perform the check


      const pluginResult = this.instantiatedChannels[npmName].addIncidents(incidentsById[npmName], type);
      toReturnResult = toReturnResult && pluginResult.result;

      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
      } else {
        toReturnExecutables.push(pluginResult.execute);
      }
    } // enf of iteration on the incidentsById keys


    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables)
    };
  }
  /**
   * This command comes form the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  incident: the Descriptive Incident to be repositioned
   *  millisecond: the new millisecond to put it
   *  targetGroupId: the id of the
   * }
   */


  moveIncident(payload) {
    const candidates = this.putMessageOnPipe('moveIncident', {
      incidentId: payload.id,
      millisecond: payload.millisecond,
      parentGroupId: payload.parentGroupId,
      contextData: {
        clipId: this.id,
        context: this.context
      }
    }, payload.parentGroupId, {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN
    });
    const totalIncidentsByPlugin = {};

    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }

        totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
      }
    }

    const res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);

    if (res.result) {
      // eslint-disable-next-line no-inner-declarations
      function successCallback() {
        res.execute();

        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.editPosition(candidates[i].response.id, payload.millisecond); // recalculate duration the groups that we added
          // the incidents to along with their parents

          candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
            selfExecute: true,
            direction: _DIRECTIONS._UP
          });
        }
      }

      return {
        result: true,
        execute: successCallback
      };
    }

    return res;
  }
  /**
   * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident
   * (edit of Incident's position given in milliseconds delta)
   * is valid and accepted, according to the rules defined on the channels.
   * The method boobles up until it reaches the Clip.
   * @param {object} incidentsById - the incident to edit, provided in an object by id
   * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
   The method should return either:
      {
          result:true,
          execute: // an array of functions that when executed it will edit the Incidents on the Channels
      }
      or
      {
          result: false,
          errors
      }
  */


  checkMove(incidentsById, millisecondsDelta) {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = []; // for each key of the incidentsById object perform the check

    for (const key in incidentsById) {
      // perform the check
      const pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
      toReturnResult = toReturnResult && pluginResult.result;

      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
      } else {
        toReturnExecutables.push(pluginResult.execute);
      }
    } // enf of iteration on the incidentsById keys


    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables)
    };
  }

  removeIncident(payload) {
    const candidates = this.putMessageOnPipe('removeIncident', {
      incidentId: payload.id,
      parentGroupId: payload.parentGroupId,
      contextData: {
        clipId: this.id,
        context: this.context
      }
    }, payload.parentGroupId, {
      selfExecute: true,
      direction: _DIRECTIONS._DOWN
    });
    const totalIncidentsByPlugin = {};

    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel();

      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }

        totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
      }
    }

    const res = this.checkDelete(totalIncidentsByPlugin);

    if (!res.result) {
      return res;
    }

    const successCallback = () => {
      res.execute();

      for (let i = 0; i < candidates.length; i++) {
        candidates[i].responder.removeChild(candidates[i].response.id); // recalculate duration the groups that we added
        // the incidents to along with their parents

        candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
          selfExecute: true,
          direction: _DIRECTIONS._UP
        });
      }
    };

    return {
      result: true,
      execute: successCallback
    };
  }
  /**
   * The checkDelete method serves exactly what its name implies. To check if the deletion of some Incidents
   * is valid and accepted, according to the rules defined on the channels.
   * @param {object} incidentsById - the incident to remove in an object, by id
    The result might be either:
      {
          result:true,
          execute: // an array of functions that when executed it will remove the Incident on the Channels
      }
      or
      {
          result: false,
          errors
      }
  */


  checkDelete(incidentsById) {
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = []; // for each key of the incidentsById object perform the check

    for (const key in incidentsById) {
      // perform the check
      const pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);
      toReturnResult = toReturnResult && pluginResult.result;

      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        continue;
      }

      toReturnExecutables.push(pluginResult.execute);
    } // enf of iteration on the incidentsById keys


    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables)
    };
  }
  /**
   * This command is invoked by the Clip's parent Descriptor class. The payload
   * is identical to the payload that comes to the Description class:
   * {
   *  id: the id of the Incident to resize
   *  newSize: the milliseconds of the new duration
   *  fraction: the division of the new duration to the current
   * }
   */


  resizeIncident(payload) {
    const candidates = this.putMessageOnPipe('resize', {
      incidentId: payload.id,
      newSize: payload.newSize,
      fraction: payload.fraction,
      contextData: {
        clipId: this.id,
        context: this.context
      }
    }, payload.id, {
      selfExecute: false,
      direction: _DIRECTIONS._DOWN
    });
    const totalIncidentsByPlugin = {};

    for (let i = 0; i < candidates.length; i++) {
      const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);

      for (const pluginName in incidentsByPlugin) {
        if (!hasOwnProp(totalIncidentsByPlugin, pluginName)) {
          totalIncidentsByPlugin[pluginName] = [];
        }

        totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
      }
    }

    let positionDelta = 0;

    if (candidates.length > 0) {
      positionDelta = candidates[0].positionDelta;
    }

    const res = this.checkResize(payload.fraction, totalIncidentsByPlugin, positionDelta);

    if (res.result) {
      const successCallback = () => {
        res.execute();

        for (let i = 0; i < candidates.length; i++) {
          candidates[i].responder.setNewDuration(payload.newSize);
        }
      };

      return {
        result: true,
        execute: successCallback
      };
    }

    return res;
  }
  /**
   * checks if a duration edit is feasible and doesn't cause conflicts
   * @param {number} durationFraction - the duration fraction
   * @param {object} incidentsById - the Incidents to resize
   * @param {number} adjustMillisecond - a time adjustment very useful on repulsiveness
   * */


  checkResize(durationFraction, incidentsById) {
    let adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // prepare the return payload
    let toReturnResult = true;
    let toReturnErrors = [];
    const toReturnExecutables = []; // for each key of the incidentsById object perform the check

    for (const key in incidentsById) {
      // perform the check
      const adjustedIncidents = systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
      const pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
      toReturnResult && (toReturnResult = pluginResult.result);

      if (!pluginResult.result) {
        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        continue;
      }

      toReturnExecutables.push(pluginResult.execute);
    } // enf of iteration on the incidentsById keys


    return {
      result: toReturnResult,
      errors: toReturnErrors,
      execute: turnIntoReturnExecuteFunction(toReturnExecutables)
    };
  }

  get context() {
    var _this$ownContext, _this$ownContext$cont;

    /*
    prevent possible bugs from clips that extend ExtendableClip
    and don't define contextLoaded = true
    on their constructor
    */
    (_this$ownContext$cont = (_this$ownContext = this.ownContext).contextLoaded) !== null && _this$ownContext$cont !== void 0 ? _this$ownContext$cont : _this$ownContext.contextLoaded = true;
    return this.ownContext;
  }
  /**
   * Returns an object with keys the keys of all the plugins Incidents of which appear in the
   * tree of the Group. All Incidents are projected to the Group's timeline.
   * The array includes the Group's projection too
   */


  getIncidentsByChannel() {
    let adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const incidentsByPlugin = {};
    incidentsByPlugin[selfContainedIncidentsNpmName] = [{
      millisecond: adjustMillisecond,
      incident: this,
      id: this.id
    }];
    return incidentsByPlugin;
  }

  setVolume(newVal) {
    this.volume = parseFloat(newVal);
  }
  /**
   * Eventual Clips have their own context, still they might belong to another Clip's
   * tree (CASI). In such a case this method gives the opportunity to set things up
   * and do operations related with their parent's context (such as subscribing to audio effect nodes)
   * */
  // eslint-disable-next-line no-unused-vars


  _onGetContextOnce(parentClipContext) {} // special recalcDuration handling so any potential clip copies update their trees
  // eslint-disable-next-line no-unused-vars


  handleRecalcDuration(target, payload) {
    if (this._calculateDuration(payload)) {
      for (let i = 0; i < this.durationSubs.length; i++) {
        this.durationSubs[i](this.duration);
      }
    }

    return true;
  }
  /**
   * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
   *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
   *      a reference to this Clip via their "realClip" property. Whenever any
   *      of these ClipCopies progresses (via the onProgress method) calls
   *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
   *      that will also progress via the Channels know which specific Incident to progress.
   *      That's the result of keeping just one real tree, belonging always to the realClip
   *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
   *      are the ones to hold the ClipCopies instances.
   * @param {boolean} forceReset - set to true in cases we want full flash of the state
   */


  onProgress(fraction, milliseconds, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (this.contextReady === false) {
      this.setBlock();
      return;
    }

    if (!contextId) {
      contextId = this.id;
    }

    for (const key in this.instantiatedChannels) {
      const channel = this.instantiatedChannels[key];
      channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);
    }
  }
  /*
  Channels' moveTo method first two arguments define the start and end point of the time delta we want to execute so Channels can
  start their journey on their lanes and gradually calculate just the differences between the two time points and apply it.
  Normally, when a Clip is executed, the time difference is very small and only few diffs (if not none) are applied.
  flash() method of ExtendableClip gives the ability to recalculate the state of the full Clip from 0 to the current
  millisecond. This method is extremely useful (actually is mandatory) when editing a Clip (add / edit / remove / resize).
   */


  flash() {
    if (!this.contextReady) {
      return;
    }

    for (const key in this.instantiatedChannels) {
      const channel = this.instantiatedChannels[key];
      channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
    }
  } // duration changes pub/sub


  subscribeToDurationChange(method) {
    this.durationSubs.push(method);
  }
  /** ***************************************************** */

  /** ****** BLOCKING WAITINGS SET / REMOVE ************** */
  // eslint-disable-next-line no-unused-vars


  handleSetBlockingWaiting(target, payload) {} // eslint-disable-next-line no-unused-vars


  handleRemoveBlockingWaiting(target, payload) {}

  setCustomEntity(id, entity) {
    let classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return this.context.setCustomEntity(id, entity, classes);
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * This Class acts more as an Abstract Class. Developers that want to create new Clip types
 * need to extend this Class and implement the methods listed here
 */

class ExtendableContextHandler {
  /**
   * @param {object} props
   * The constructor makes sure it assigns all methods of the ContextHandler to
   * the context object it creates.
   */
  constructor(props) {
    this.props = props;
    this.customEntities = {};
    this.elementsByMCID = {};
    this.setContext();
  }

  setContext() {
    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.context = {
      audio: false,
      contextLoaded: false,
      getElements: this._getElements.bind(this),
      getElementSelectorByMCID: this._getElementSelectorByMCID.bind(this),
      getElementByMCID: this.getElementByMCID.bind(this),
      setCustomEntity: this.setCustomEntity.bind(this),
      getMCID: this._getMCID.bind(this),
      setMCID: this.setMCID.bind(this),
      unmount: this.unmount.bind(this),
      ...obj
    };
  }
  /**
   * _getElements method is not overwritten by the child Classes. What it
   * does is to make sure the provided selector is valid and handle the case
   * of the special selector (starting with "!") which returns custom entities
   * @param {string} selector
   * @return {*[]|Array}
   * @private
   */


  _getElements(selector) {
    if (selector === null || selector === undefined || selector === '') {
      return [];
    }

    if (selector.charAt(0) === '!') {
      selector = selector.substr(1);

      if (selector.charAt(0) === '#') {
        return [this.customEntities[selector.substr(1)]];
      }

      if (selector.charAt(0) === '.') {
        const toReturn = [];

        for (const key in this.customEntities) {
          const entity = this.customEntities[key];

          if (entity.classes.includes(selector.substr(1))) {
            toReturn.push(entity);
          }
        }

        return toReturn;
      }
    }

    return this.getElements(selector);
  }
  /**
   * Acts as a proxy before forwarding the call the getMCID implementation
   * of each ContextHandler, after it has first checked customEntities
   * @param {element} element: Given an element it provides back its mcid
   * @return {string}: The MC id of the provided element
   * @private
   */


  _getMCID(element) {
    return element.customEntity ? element.id : this.getMCID(element);
  }
  /**
   * Given an mcid the ContextHandler will provide a string selector that selects the
   * element that has this mcid
   * @param {string} mcid
   * @return {string}
   * @private
   */


  _getElementSelectorByMCID(mcid) {
    if (hasOwnProp(this.customEntities, mcid)) {
      return "!#".concat(mcid);
    }

    return this.getElementSelectorByMCID(mcid);
  }
  /**
   * Given an mcid ContextHandler will return the element that has it
   * @param {string} mcid
   */


  getElementByMCID(mcid) {
    if (hasOwnProp(this.customEntities, mcid)) {
      return this.customEntities[mcid];
    }

    if (hasOwnProp(this.elementsByMCID, mcid)) {
      return this.elementsByMCID[mcid];
    }

    const element = this._getElements(this._getElementSelectorByMCID(mcid))[0];

    this.elementsByMCID[mcid] = element;
    return element;
  }
  /**
   * @param {string} selector: A selector string to select the elements
   * @return {array}: An array of all elements that apply to the selector
   */
  // eslint-disable-next-line no-unused-vars


  getElements(selector) {
    return [];
  }
  /**
   * @param {element} element: Given an element it provides back its mcid
   * @return {string}: The MC id of the provided element
   */
  // eslint-disable-next-line no-unused-vars


  getMCID(element) {}
  /**
   * Given an element and an mc id the ContextHandler assigns the mc id to the element
   * @param {element} element
   * @param {string} mcid
   */
  // eslint-disable-next-line no-unused-vars


  setMCID(element, mcid) {}
  /**
   * Given an mcid the ContextHandler will provide a string selector that selects the
   * element that has this mcid
   * @param {string} mcid
   * @return {string}
   */
  // eslint-disable-next-line no-unused-vars


  getElementSelectorByMCID(mcid) {}
  /**
   * This method unmounts the Clip
   */


  unmount() {}
  /**
   * Sets a custom entity. Custom entities are analysed on docs.motorcortex.com
   * @param {string} id: The id of the custom entity
   * @param {any} entity: The entity itself. Can be any type
   * @param {array} classes: A list of classes the user wants to assign to its custom entity
   * @return {boolean}
   */


  setCustomEntity(id, entity) {
    let classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (hasOwnProp(this.customEntities, id)) {
      helper.error("Clip ".concat(this.id, " already has custom Entity with id: ").concat(id));
      return false;
    }

    this.customEntities[id] = {
      id,
      entity,
      classes,
      customEntity: true
    };
    return true;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class DOMContextHandler extends ExtendableContextHandler {
  /**
   * Depending on the containerParams and the originalDims status this method
   * decides which width and height values should be used for setting the dimensions
   * of the Clip (and if there should be dimensions set on the Clip)
   */
  calcClipDims(props) {
    // dims initialisation
    let dims = {
      use: false,
      // don't even set dimensions for the Clip
      width: null,
      height: null
    }; // if there are originalDims we certainly prefer them

    if (hasOwnProp(props, 'originalDims') && props.originalDims.width != null && props.originalDims.height != null) {
      return {
        use: true,
        width: props.originalDims.width.number + props.originalDims.width.unit,
        height: props.originalDims.height.number + props.originalDims.height.unit
      };
    }

    if (hasOwnProp(props, 'containerParams')) {
      if (hasOwnProp(props.containerParams, 'width')) {
        dims.use = true;
        dims.width = props.containerParams.width;
      }

      if (hasOwnProp(props.containerParams, 'height')) {
        dims.use = true;
        dims.height = props.containerParams.height;
      }
    }

    return dims;
  }
  /**
   * returns and object with keys: width, height
   * each of these keys define the scaling that should be applied to both dimensions of the Clip
   **/


  scalingCalculator(props) {
    // first decide IF a scaling should be applied:
    // Firstly, both "containerParams" and "originalDims" should be present and
    // should both contain meaningful data
    if (!hasOwnProp(props, 'containerParams') || !hasOwnProp(props, 'originalDims') || // Skip if the originalDims contain null values
    props.originalDims.width == null && props.originalDims.height == null) {
      return {
        width: 1,
        height: 1
      };
    } // The next thing to analyse the container params into number & units


    const analysedContainerParams = analyseContainerParams(props.containerParams); // identify the scaling factors per each axis

    let widthScale = null,
        heightScale = null;

    if (analysedContainerParams.width !== null && props.originalDims.width !== null) {
      if (analysedContainerParams.width.unit === props.originalDims.width.unit) {
        widthScale = analysedContainerParams.width.number / props.originalDims.width.number;
      } else {
        helper.warning("containerParams and originalDims width of Incident have different dimensions.\ncontainerParams.width will be ignored");
      }
    }

    if (analysedContainerParams.height != null && props.originalDims.height != null) {
      if (analysedContainerParams.height.unit === props.originalDims.height.unit) {
        heightScale = analysedContainerParams.height.number / props.originalDims.height.number;
      } else {
        helper.warning('containerParams and originalDims height of Incident have different dimensions.\ncontainerParams.height will be ignored');
      }
    }

    if (widthScale == null && heightScale == null) {
      return {
        width: 1,
        height: 1
      };
    }

    if (widthScale != null && heightScale == null) {
      heightScale = widthScale;
    } else if (heightScale != null && widthScale == null) {
      widthScale = heightScale;
    }

    return {
      width: widthScale,
      height: heightScale
    };
  }

  getElements(selector) {
    return Array.from(this.context.rootElement.querySelectorAll(selector));
  }

  getMCID(element) {
    return element.getAttribute(elementsDataAttributeName);
  }

  setMCID(element, mcid) {
    element.setAttribute(elementsDataAttributeName, mcid);
  }

  getElementSelectorByMCID(mcid) {
    return "[".concat(elementsDataAttributeName, "=\"").concat(mcid, "\"]");
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function compileHTML(template, initParams) {
  let isHTML = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isFunction(template)) {
    return template(initParams);
  }

  const res = parse(template, {
    items: {
      initParams
    },
    keys: {}
  }, isHTML);

  if (isString(res)) {
    return res;
  }

  return res.outerHTML;
}

function addCSSToNode(node, css, doc) {
  if (node.styleSheet) {
    node.styleSheet.cssText = css;
  } else {
    node.appendChild(doc.createTextNode(css));
  }
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function loadGoogleFont(doc, theFont) {
  const fontTag = doc.createElement('link');
  fontTag.setAttribute('rel', 'stylesheet');

  if (!validateGoogleFontUrl(theFont.src)) {
    helper.error("Only valid google font url are accepted on src of a google-font. ".concat(theFont.src, " provided. No font will loaded"));
    return fontTag;
  }

  fontTag.setAttribute('href', theFont.src);
  return fontTag;
}

function createFontTag(doc, theFont) {
  if (theFont.type === 'google-font') {
    return loadGoogleFont(doc, theFont);
  } // return a generic font tag


  helper.error("The provided font type is not one of the supported. ".concat(theFont.type, " provided. Aborting loading font."));
  const fontTag = doc.createElement('link');
  fontTag.setAttribute('rel', 'stylesheet');
  return fontTag;
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const iframeCSSID = '@donkeyclip/motorcortex/iframeContextHandler/css';

class IframeContextHandler extends DOMContextHandler {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);
    const {
      ownerDocument
    } = props.host;

    if (!ownerDocument.getElementById(iframeCSSID)) {
      const seamlessCSS = "iframe[seamless]{background-color:transparent;border:0 none transparent;padding:0;overflow: hidden;}";
      const iframesCSS = ownerDocument.createElement('style');
      iframesCSS.id = iframeCSSID;
      addCSSToNode(iframesCSS, seamlessCSS, ownerDocument);
      (ownerDocument.head || ownerDocument.getElementsByTagName('head')[0]).appendChild(iframesCSS);
    } // Create an iframe:


    const iframe = ownerDocument.createElement('iframe');
    props.host.appendChild(iframe);
    const scale = this.scalingCalculator(props);
    const clipDims = this.calcClipDims(props);
    iframe.setAttribute('seamless', 'seamless');

    if (clipDims.use === true) {
      if (clipDims.width !== null) {
        iframe.setAttribute('width', clipDims.width);
      }

      if (clipDims.height !== null) {
        iframe.setAttribute('height', clipDims.height);
      }
    }

    iframe.style.transform = "scale(".concat(scale.width, ", ").concat(scale.height, ")");
    iframe.style.transformOrigin = 'top left';
    iframe.style.position = 'absolute'; // Initialise the iframe

    iframe.src = ''; // Put it in the document (but hidden):

    let iframeDocument = iframe.contentWindow || iframe.contentDocument;

    if (iframeDocument.document) {
      iframeDocument = iframeDocument.document;
    }

    iframeDocument.write(compileHTML(props.html, props.initParams, true));
    const css = "".concat(compileHTML(props.css, props.initParams), "body{padding:0;margin:0;}");
    const styleTag = iframeDocument.createElement('style');
    addCSSToNode(styleTag, css, ownerDocument);
    const head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];
    head.appendChild(styleTag);

    if (hasOwnProp(props, 'fonts')) {
      for (let i = 0; i < props.fonts.length; i++) {
        const theFont = props.fonts[i];
        const fontTag = createFontTag(iframeDocument, theFont);
        head.appendChild(fontTag);
      }
    }

    this.rootElement = iframe;
    iframeDocument.close();
    this.setContext({
      document: iframeDocument,
      window: iframe.contentWindow || iframe,
      clipContainer: iframe,
      rootElement: iframeDocument.body,

      unmount() {
        props.host.removeChild(iframe);
      }

    });
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const mcContainerDataAttr = 'data-motorcortex-container';

class WebComponentContextHandler extends DOMContextHandler {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);
    /*
    We will construct the following structure:
    this.targetHost  context.clipContainer  (= in the case of a fragmented clip is a div we create in the memory. In the
                                            case of a WCCH (this) it's the provided host from the props (props.host))
    #shadow          -                      the shadow root of the targetHost
    wrapper          context.rootElement    the container of the Clip itself. Both clipDims AND scale are applied to
                                            this element. The logic is simple, clipDims define the pixels of the
                                            wrapper while the scale its scale. There are plenty of originalDims /
                                            containerParams combinations covered here.
    */

    const wrapper = document.createElement('div');
    this.styleWrapper(wrapper, this.props);
    wrapper.innerHTML = compileHTML(props.html, props.initParams, true);
    this.rootElement = wrapper; // if shadow root is not yet implemented, implement it

    let shadow = this.targetHost.shadowRoot;

    if (!shadow) {
      shadow = this.targetHost.attachShadow({
        mode: 'open'
      });
    } // append wrapper into the shadow


    shadow.appendChild(wrapper);
    const slotElement = document.createElement('slot');
    shadow.appendChild(slotElement); // append style tag into the shadow

    const styleTag = document.createElement('style');
    addCSSToNode(styleTag, "".concat(styleTag.styleSheet ? '[' + mcContainerDataAttr + '] { all: initial; }' : '').concat(compileHTML(props.css, props.initParams)), document);
    shadow.appendChild(styleTag); // append fonts into document

    this.fontTags = [];

    if (hasOwnProp(props, 'fonts')) {
      for (let i = 0; i < props.fonts.length; i++) {
        const theFont = props.fonts[i];
        const fontTag = createFontTag(document, theFont);
        document.getElementsByTagName('head')[0].appendChild(fontTag);
        this.fontTags.push(fontTag);
      }
    }

    this.setContext({
      contextLoaded: true,
      document,
      window,
      clipContainer: this.targetHost,
      rootElement: wrapper,

      unmount() {
        try {
          shadow.innerHTML = '';

          for (let i = 0; i < this.fontTags.length; i++) {
            document.getElementsByTagName('head')[0].removeChild(this.fontTags[i]);
          }
        } catch (er) {
          helper.warning('The element of the Clip to be removed seems not to exist any more');
        }
      }

    });
  }

  styleWrapper(wrapper, props) {
    const scale = this.scalingCalculator(props);
    const clipDims = this.calcClipDims(props);
    wrapper.setAttribute(mcContainerDataAttr, 'true');

    if (clipDims.use === true) {
      if (clipDims.width !== null) {
        wrapper.style.width = clipDims.width;
      }

      if (clipDims.height !== null) {
        wrapper.style.height = clipDims.height;
      }
    }

    wrapper.style.transform = "scale(".concat(scale.width, ", ").concat(scale.height, ")");
    wrapper.style.transformOrigin = 'top left';
    wrapper.style.position = 'absolute';
    wrapper.style.overflow = 'hidden';
  }

  unstyleWrapper(wrapper) {
    while (wrapper.attributes.length > 0) {
      wrapper.removeAttribute(wrapper.attributes[0].name);
    }

    wrapper.setAttribute(mcContainerDataAttr, true);
  }

  get targetHost() {
    return this.props.host;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * It's the Browser version of a MotorCortex Clip. BrowserClip extends ExtendableClip and, as
 * it should, it defines its ownContext on its constructor (see ExtendableClip
 * for details re this.ownContext property). Also, it renders itself either on
 * iframe or via shadow Browser, depending on browser support.
 * BrowserClip, via the use of the customEntities, provided by ExtendableClip, can be
 * used to create other kinds of Clips (not HTML/Browser), such as webGL that all run on
 * the browser, on a given Browser elment should be implemented by extending this Class.
 * The rest can be handled by customEntities, check on documentation how to use them.
 * For Clips that do not live on the browser developers can extend ExtendableClip,
 * follow the paradigm of BrowserClip and create a Clip for a totally different platform.
 *
 **/

class BrowserClip extends ExtendableClip {
  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameters that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  constructor() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let DescriptiveIncident = arguments.length > 2 ? arguments[2] : undefined;
    super(attrs, props, DescriptiveIncident);
    props = { ...props,
      html: this.html !== '' ? this.html : props.html,
      css: this.css !== '' ? this.css : props.css,
      fonts: this.fonts.length > 0 ? this.fonts : props.fonts
    }; // that means the Clip is hosted or, in other words a host has been
    // provided on the props (and not a selector)
    // this.isHostedClip = true;

    let ContextHandler = null;

    if (document.head.createShadowRoot || document.head.attachShadow) {
      ContextHandler = WebComponentContextHandler;
    } else {
      ContextHandler = IframeContextHandler;
    }

    const contextHandler = new ContextHandler(props);
    this.ownContext = { ...contextHandler.context,
      initParams: props.initParams
    };
    this.iframe = contextHandler.iframeElement;
    this.onAfterRender();
  }

  onAfterRender() {// implement here
  } // this getter can be overwritten by plugins developers when extending the BrowserClip. This html is going to be the
  // html that will be rendered


  get html() {
    return '';
  } // this getter can be overwritten by plugins developers when extending the BrowserClip. This css is going to be the
  // css that will be rendered


  get css() {
    return '';
  } // this getter can be overwritten by plugins developers when extending the BrowserClip. The fonts are going to be the
  // fonts that will be loaded


  get fonts() {
    return [];
  }

  get rootElement() {
    return this.context.rootElement;
  }
  /**
   * exportConstructionArguments is a method already defined and provided by ExtendableClip.
   * Though BrowserClip overwrites it as it wants the exportedConstructionArguments to reflect
   * the changes already made on the actual DOM.
   * @return {{attrs: Object, props: (*&{host: undefined, html: (string|*)})}}
   */


  exportConstructionArguments() {
    // TODO also export CSS and fonts taking in account the potential existence
    // of them on the get methods
    return {
      attrs: this.attrs,
      props: { ...this.props,
        host: undefined,

        /*
        all custom Clips defined in plugins (as classes extending the BrowserClip) are marked
        on their constructor (as static variable) as custom clips (customClip = true).
        Custom BrowserClips should always export blank html as most of the time this
        html is produced in the onAfterRender method which runs on clip copies
        */
        html: this.DescriptiveIncident.constructor.customClip === true ? '' : this.context.rootElement.innerHTML
      }
    };
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function yesToAll() {
  return {
    result: true
  };
}

function NBEC(clip, errors) {
  const handler = {
    get: function (target, prop) {
      if (isFunction(target[prop])) {
        return yesToAll;
      }

      if (prop === 'nonBlockingErrorClip') {
        return true;
      }

      if (prop === 'errors') {
        return errors;
      }

      return target[prop];
    }
  };
  return new Proxy(clip, handler);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class Playable extends DescriptiveGroup {
  constructor(attrs, props) {
    super(attrs, props);
    this.runTimeInfo = {
      currentMillisecond: 0,
      state: 'idle' // supported states: idle, playing, paused, blocked, armed

    };
    /**
          @member {object} - listeners are functions to be executed on time change of the Clip.
          It has the following format:
         listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */

    this.listeners = {}; // previousTimeStamp is a property holding the last timestamp that the
    // requestAnimationFrame ran

    this.previousTimeStamp = -1;
    this.speed = 1;
  }
  /** ********************* execution methods  *********************
   *************************************************************** */

  /**
   *
   * @param {string} newState: the new state
   * @param {object} options: an optional options object that might provide extra info for the status change
   * @private
   */


  _setState(newState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (newState !== this.runTimeInfo.state) {
      this.runTimeInfo.state = newState; // the only timer and the only responsible for Clip execution is the Clip
      // All Incidents contained on a Clip are been executed by the Clip itself via its channels.
      // Thus, the only Incidents that need to know about the state of the root Clip
      // at any time are only the Clips

      this.putMessageOnPipe('setState', {
        newState,
        options
      }, 'Clips', {
        selfExecute: false,
        direction: _DIRECTIONS._DOWN
      });

      for (const key in this.listeners) {
        const listener = this.listeners[key];
        listener.funct(this.runTimeInfo.currentMillisecond, newState, options);
      }
    }
  }

  handleSetState(target, payload) {
    this._setState(payload.newState, payload.options || {});
  } // execution methods


  play() {
    let debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'armed' || this.runTimeInfo.state === 'transitional' || this.runTimeInfo.state === 'blocked') {
      if (this.runTimeInfo.state === 'paused') {
        const delta = new Date().getTime() - this.pauseMoment;
        this.previousTimeStamp += delta;
      }

      this._setState('playing');

      this.onPlay();

      if (!debug) {
        window.requestAnimationFrame(timestamp => {
          this.step(timestamp);
        });
      }
    }
  }

  pause() {
    if (this.runTimeInfo.state === 'playing') {
      this._setState('paused');

      this.pauseMoment = new Date().getTime();
      this.onWait();
    }
  }
  /* armed state means the Clip is on paused state after transition */


  arm() {
    if (this.runTimeInfo.state === 'transitional' || this.runTimeInfo.state === 'blocked') {
      this._setState('armed');
    }
  }

  complete() {
    this._setState('idle');

    this.previousTimeStamp = -1;
  }
  /* in order to start a journey via the TimeCapsule the Playable needs first to stop */


  stop() {
    this._setState('transitional');

    this.previousTimeStamp = -1;
  }
  /**
   *
   * @param {object} options: An optional options object for the block.
   * Currently it supports the key "except" which can hold the id of an Incident that we want to exclude from the block
   */


  block() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    /*
    incidents that have exceptional blocks can't apply a block on the Clip if the Clip is not
    on the playing state
     */
    if (hasOwnProp(options, 'exception') && this.runTimeInfo.state !== 'playing') {
      return;
    }

    this._setState('blocked', options);

    this.previousTimeStamp = -1;
  }

  onPlay() {}

  onWait() {}

  playableProgress(fraction, millisecond) {
    if (this.isTheRootClip) {
      for (const key in this.listeners) {
        const listner = this.listeners[key]; // if the listener is only for state change continue

        if (listner.onlyOnStateChange === true) {
          continue;
        }

        if (Math.abs(millisecond + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {
          listner.funct(roundNumberTo(millisecond, listner.roundTo), this.runTimeInfo.state);
          listner.cavaDelta = 0;
        } else {
          listner.cavaDelta += Math.abs(millisecond - this.runTimeInfo.currentMillisecond);
        }
      }

      this.onProgress(fraction, millisecond);
      this.runTimeInfo.currentMillisecond = millisecond;
      return true;
    }

    return false;
  }

  set executionSpeed(speed) {
    if (!this.isTheRootClip) {
      return;
    }

    this.speed = parseFloat(speed);
  } // *******************************************************
  // STEP FUNCTION


  step(timestamp) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.runTimeInfo.state !== 'playing') {
      return;
    }

    const that = this;

    if (this.previousTimeStamp === -1) {
      this.previousTimeStamp = timestamp;
    } // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]


    const progress = {
      milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),
      fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration
    };

    if (progress.fraction >= 1) {
      this.playableProgress(1, this.duration);
      this.complete();
      return;
    }

    if (progress.fraction < 0) {
      this.playableProgress(0, 0);
      this.complete(); // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });

      return;
    }

    this.playableProgress(progress.fraction, progress.milliseconds);
    this.previousTimeStamp = timestamp;

    if (!debug) {
      window.requestAnimationFrame(that.step.bind(that));
    }
  } // ************ PUB SUB ********************
  // *****************************************

  /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cycle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */


  subscribe(id, funct, threshold, roundTo) {
    let onlyOnStateChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (!threshold) {
      threshold = 0;
    }

    if (!roundTo) {
      roundTo = 1; // round second to its units, meaning leave it as it is
    }

    this.listeners[id] = {
      funct,
      threshold,
      roundTo,
      cavaDelta: 0,
      onlyOnStateChange
    };
  }

  unsubscribe(id) {
    if (hasOwnProp(this.listeners, id)) {
      delete this.listeners[id];
    }
  }

  subscribeToDurationChange(funct) {
    if (this.isTheRootClip) {
      this.realClip.subscribeToDurationChange(funct);
      return true;
    }

    return false;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * validateObject function takes as input a schema (compatible with fastest-validator) and an object and
 * checks if the provided props match the schema
 *
 * @param {object} schema
 * @param {object} props
 * @param {string} errorMsg
 * @returns {{result: boolean, errors: *}|{result: boolean}|{result: boolean, errors: [string]}}
 */

function validateObject(schema, props) {
  let errorMsg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Error on validation';

  try {
    const check = validator.compile(schema);
    const validationCheckResult = check(props);

    if (validationCheckResult === true) {
      return {
        result: true
      };
    }

    let errorMessage = "".concat(errorMsg, ":");

    for (let i = 0; i < validationCheckResult.length; i++) {
      errorMessage += "\n - ".concat(validationCheckResult[i].message, ". ").concat(validationCheckResult[i].actual, " provided");
    }

    helper.error(errorMessage);
    return {
      result: false,
      errors: validationCheckResult
    };
  } catch (e) {
    const error = "".concat(errorMsg, ". Invalid schema provided");
    helper.error(error);
    return {
      result: false,
      errors: [error]
    };
  }
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class AudioNodeSet {
  constructor() {
    // audio context initialisation
    this.output = audioContext.createGain();
    this.gainNode = audioContext.createGain();

    if (audioContext.createStereoPanner) {
      this.pannerNode = audioContext.createStereoPanner(); // if it is supported by the browser
    } // this.highpassNode = audioContext.createBiquadFilter();
    // this.lowpassNode = audioContext.createBiquadFilter();
    // this.lowpassNode.connect(this.highpassNode);
    // this.highpassNode.connect(this.pannerNode);


    if (audioContext.createStereoPanner) {
      this.pannerNode.connect(this.gainNode);
      this.gainNode.connect(this.output);
      this.input = this.pannerNode;
    } else {
      this.gainNode.connect(this.output);
      this.input = this.gainNode;
    }
  }

  connect(master) {
    this.output.connect(master);
  }

  disconnect() {
    // eslint-disable-line no-unused-vars
    this.output.disconnect();
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function _base64ToArrayBuffer(base64) {
  const binary_string = window.atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);

  for (let i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }

  return bytes.buffer;
}

const datamcidRegex = /\[data(-mcid="+\w+")+\]/g;

class PubSub {
  constructor() {
    this.subscribers = [];
  }

  sub(id, method) {
    this.subscribers.push(method);
  }

  pub(argument) {
    for (let i = 0; i < this.subscribers.length; i++) {
      this.subscribers[i](argument);
    }
  }

}
/**
 * Specs:
 * AudioContext Handler keeps all the audio sources.
 * The audio sources are passed in the following format:
 * - src (the source of the sound)
 * - base64 (boolean, defaults to false. If the sound is base64 it's been treated
 *      in a different way)
 * - id (must be unique)
 * - classes (an array of belonging classes)
 *
 * The SoundContextHanlder creates a media element of the following format:
 * media: {
 *  src
 *  id
 *  classes
 *  base64
 *  buffer
 *  nodes: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 *      audioNodeSet
 *  }
 * }
 *
 * Finally the SoundContextHandler has its own nodes (the master) which look like this:
 * master: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 * }
 * */


class AudioContextHandler extends ExtendableContextHandler {
  constructor() {
    let audioSources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let masterNode = arguments.length > 1 ? arguments[1] : undefined;
    super(); // variables to be used for checking context rediness

    this.totalSources = audioSources.length; // initialisation of the final audio resources colleciton

    this.audioSources = {}; // iterate on audioSource to create the audioSources collection

    for (let i = 0; i < audioSources.length; i++) {
      const audioSource = audioSources[i];
      const audioResource = {
        mcid: audioSource.mcid || getAnId(),
        id: audioSource.id,
        src: audioSource.src,
        classes: audioSource.classes || [],
        base64: audioSource.base64 || false,
        pubSub: new PubSub(),
        soundLoaded: false,
        startValues: audioSource.startValues || {}
      };
      this.audioSources[audioResource.id] = audioResource;
      this.elementsByMCID[audioResource.mcid] = audioResource;

      if (audioSource.base64) {
        audioContext.decodeAudioData(_base64ToArrayBuffer(audioSource.src), buffer => {
          this._setBuffer(audioResource, buffer, masterNode);
        });
      } else {
        const request = new XMLHttpRequest();
        request.open('GET', audioResource.src, true);
        request.responseType = 'arraybuffer'; // Decode asynchronously

        this.soundLoaded = false;

        request.onload = () => {
          audioContext.decodeAudioData(request.response, buffer => {
            this._setBuffer(audioResource, buffer, masterNode);
          }, this.onError);
        };

        request.send();
      }
    }

    this.setContext({
      contextLoaded: true,
      audio: true,
      document,
      window,
      rootElement: document.body,
      unmount: doNothing,
      masterNode,
      audioContext
    });
  }

  _setBuffer(audioResource, buffer, masterNode) {
    audioResource.soundLoaded = true;
    audioResource.buffer = buffer;
    audioResource.audioNodeSet = new AudioNodeSet();
    audioResource.audioNodeSet.connect(masterNode.input);
    audioResource.pubSub.pub();
  }

  getElementByMCID(mcid) {
    if (hasOwnProp(this.elementsByMCID, mcid)) {
      return this.elementsByMCID[mcid];
    }

    return null;
  }

  getElements(selector) {
    if (selector.charAt(0) === '~') {
      selector = selector.substr(1);

      if (selector.charAt(0) === '#') {
        if (hasOwnProp(this.audioSources, selector.substr(1))) {
          return [this.audioSources[selector.substr(1)]];
        }

        return [];
      }

      if (selector.charAt(0) === '.') {
        const className = selector.substr(1);
        const toReturn = [];

        for (const source in this.audioSources) {
          if (source.classes.indexOf(className) >= 0) {
            toReturn.push(source);
          }
        }

        return toReturn;
      }
    } else if (datamcidRegex.exec(selector)) {
      const mcid = selector.split('"')[1];
      return this.elementsByMCID[mcid];
    } else {
      return [];
    }
  }

  getMCID(element) {
    return element.mcid;
  }

  setMCID(element, mcid) {
    element.mcid = mcid;
  }

  getElementSelectorByMCID(mcid) {
    return "[data-mcid=\"".concat(mcid, "\"]");
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class AudioClip extends ExtendableClip {
  constructor(attrs, props) {
    super(attrs, props); // Our AudioNodeSet Class represents an audio routing graph of connected Nodes (pan->gain->master)
    // connected in this exact order. Our AudioNodeSet exposes the "input" and "output" props as well
    // as the "connect" method which connects it with a Web WebAudio API Node.

    this.audioNodeSet = new AudioNodeSet(); // initially we connect our AudioNodeSet with the window.audioContext.destination
    // treating our AudioClip as root. This will change on the _onGetContextOnce method
    // which is only invoked if AudioClip is used as CASI. In this method the destination
    // changes to target the input of its parent node

    this.audioNodeSet.connect(audioContext.destination);
    const contextHandler = new AudioContextHandler(this.props.audioSources, this.audioNodeSet);
    this.ownContext = { ...contextHandler.context,
      initParams: props.initParams
    };
  }
  /**
   * As AudioClip does not accept a selector and does not get analysed to ContextAwareIncidents, the mechanism that
   * triggers recalcDuration to the parents does not get executed. For this we overwrite its parent's method so
   * whenever there is a change on the duration the parents get informed as well
   * @param target
   * @param payload
   */


  handleRecalcDuration(target, payload) {
    const res = super.handleRecalcDuration(target, payload);

    if (res) {
      this.putMessageOnPipe('recalcDuration', payload.childId ? {
        childId: this.id
      } : {}, // only in additions there is childId which we should further apply
      'Groups', {
        selfExecute: false,
        direction: _DIRECTIONS._UP
      });
    }
  }

  onProgress(fraction, milliseconds, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (milliseconds > this.duration) {
      return super.onProgress(1, this.duration, this.id, forceReset);
    }

    const repeatDuration = this.delay + this.calculatedDuration + this.hiatus; // step 2.a: find the running repeat and millisecond of this repeat

    let millisecondWithinRepeat = repeatDuration === 0 ? 0 : milliseconds % repeatDuration; // step 2.b: decide between 0 and 1

    if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
      millisecondWithinRepeat = this.delay + this.calculatedDuration;
    } // step 3: find the millisecond of the MonoIncident


    let MI_millisecond = millisecondWithinRepeat - this.delay;

    if (MI_millisecond < 0) {
      return;
    }

    if (MI_millisecond > this.calculatedDuration) {
      // if it has stepped into hiatus
      MI_millisecond = this.calculatedDuration;
    }

    const MI_fraction = this.calculatedDuration === 0 ? 0 : MI_millisecond / this.calculatedDuration;
    super.onProgress(MI_fraction, MI_millisecond, this.id, forceReset); // super.onProgress(fraction, milliseconds, this.id, forceReset);
  }

  _onGetContextOnce(parentClipContext) {
    /*
        context.master {gain, pan, highpass, lowpass}
        */
    // as highpass is the first node of master in row
    this.audioNodeSet.disconnect();
    this.parentClipContext = parentClipContext; // the connect method of our AudioNodeSet expects a Web WebAudio API Node as input
    // parentClipContext.masterNode is the AudioNodeSet of the parent and thus on its "input"
    // property its Web WebAudio API input Node is exposed

    this.audioNodeSet.connect(parentClipContext.masterNode.input);
  }

  lastWish() {
    this.audioNodeSet.output.disconnect(); // returns back to the root state

    this.audioNodeSet.output.connect(audioContext.destination);
  }

  get volume() {
    return this.audioNodeSet.output.gain.value;
  }

  setVolume(vol) {
    this.audioNodeSet.output.gain.value = vol;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class HTMLFragmentedContextHandler extends WebComponentContextHandler {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);
    this.context.fragment = true; // this context property lets the developer know at any time if the context is on
    // fragmented state or not

    this.rendered = false;
    this.removeDOMTimeout = null;
  }

  get targetHost() {
    if (!this._targetHost) {
      this._targetHost = document.createElement('div');
      this._targetHost.style.zIndex = '-1';
      this._targetHost.style.width = '0px';
      this._targetHost.style.height = '0px';
      this._targetHost.style.overflow = 'hidden';
      this._targetHost.style.position = 'relative';
    }

    return this._targetHost;
  }

  checkProps() {
    if (!isObject(this.props)) {
      helper.error("HTMLFragmentContextHandler expects an object on its constructor. ".concat(typeof this.props, " passed"));
      return false;
    }

    if (!hasOwnProp(this.props, 'html')) {
      this.props.html = '';
    }

    if (!hasOwnProp(this.props, 'css')) {
      this.props.css = '';
    }

    return true;
  }

  renderOnDOM() {
    if (this.removeDOMTimeout) {
      clearTimeout(this.removeDOMTimeout);
    }

    if (!this.rendered) {
      document.body.append(this._targetHost);
      this.rendered = true;
    }
  }

  removeFromDOM() {
    if (this.removeDOMTimeout) {
      clearTimeout(this.removeDOMTimeout);
    }

    this.removeDOMTimeout = setTimeout(() => {
      try {
        document.body.removeChild(this._targetHost);
        this.rendered = false;
      } catch (e) {
        helper.info("Clip's DOM element was not found and thus not removed from DOM");
      }
    }, 50);
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class OriginalCASIClip extends ExtendableClip {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let DescriptiveIncident = arguments.length > 2 ? arguments[2] : undefined;
    let attrsToPass;
    let propsToUse;
    /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is
        the new way of initialising a Group (only props).
        */

    if (oldProps === null) {
      attrsToPass = {};
      propsToUse = props;
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = props;
      propsToUse = oldProps;
    }

    super(attrsToPass, propsToUse, DescriptiveIncident);
    const contextHanlder = new HTMLFragmentedContextHandler({ ...propsToUse,
      html: hasOwnProp(propsToUse, 'html') ? propsToUse.html : this.html,
      css: hasOwnProp(propsToUse, 'css') ? propsToUse.css : this.css,
      fonts: hasOwnProp(propsToUse, 'fonts') ? propsToUse.fonts : this.fonts
    });
    this.ownContext = { ...contextHanlder.context,
      isHostedClip: false
    };
    this.iframe = contextHanlder.iframeElement;
    this.contextHandler = contextHanlder;
    this.onDOMCLipInitialise(); // as soon as a Fragmented Clip is been initialised that means the Descriptive
    // Clip has a selector and not a host. Thus is not a hosted clip
    // this.isHostedClip = false;
  }

  exportConstructionArguments() {
    // TODO also export CSS and fonts taking in account the potential existence
    // of them on the get methods
    return {
      attrs: this.attrs,
      props: { ...this.props,
        html: this.context.rootElement.innerHTML
      }
    };
  }

  onDOMCLipInitialise() {// implement here
  }

  get rootElement() {
    return this.context.rootElement;
  }
  /**
   * renderOnDOM method renders the Clip on the DOM
   */


  renderOnDOM() {
    this.contextHandler.renderOnDOM();
  }
  /**
   * removeFromDOM removes the Clip from the DOM
   */


  removeFromDOM() {
    this.contextHandler.removeFromDOM();
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class NullClip {
  constructor() {
    this.isNullClip = true;
  }

  get duration() {
    return 0;
  }

  addIncident() {
    return successWithEmptyExecution;
  } // eslint-disable-next-line sonarjs/no-identical-functions


  moveIncident() {
    return successWithEmptyExecution;
  } // eslint-disable-next-line sonarjs/no-identical-functions


  removeIncident() {
    return successWithEmptyExecution;
  } // eslint-disable-next-line sonarjs/no-identical-functions


  resizeIncident() {
    return successWithEmptyExecution;
  }

  getIncidentsByChannel() {
    return {};
  }

  flash() {// this is left intentionally empty
  }

  _resize() {// this is left intentionally empty
  }

  onProgress() {// this is left intentionally empty
  }

  renderOnDOM() {// this is left intentionally empty
  }

  removeFromDOM() {// this is left intentionally empty
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/*
dna: {
    host
    descriptiveIncident
}
*/

class ClipClone {
  constructor(dna) {
    this.runTimeInfo = {
      currentMillisecond: 0,
      state: 'transitional'
    };
    this.id = getAnId();
    this.realClip = dna.descriptiveIncident.realClip; // In order to render itself on the given element first it needs the props (including html and css)
    // from the real Clip it copies

    const constructionArgs = dna.descriptiveIncident.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip

    const hostedProps = { ...constructionArgs.props,
      selector: undefined,
      host: dna.host,
      id: this.id
    }; // we create a clip because Clips on creation render and thus have their own context

    this.ownClip = new dna.descriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps); // flushes the realClip with its ownClip's context

    dna.descriptiveIncident.realClip.addContext({
      clipId: this.id,
      context: this.ownClip.context,
      synchronize: dna.synchronize,
      runTimeInfo: this.runTimeInfo
    }, true);
  } // eslint-disable-next-line no-unused-vars


  onProgress(fraction, milliseconds) {

    for (const key in this.realClip.instantiatedChannels) {
      const channel = this.realClip.instantiatedChannels[key];
      channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, true);
    }

    this.runTimeInfo.currentMillisecond = milliseconds;
  }

}

function check(_this, func, payload) {
  const res = _this.realClip[func](payload);

  const audioRes = _this.audioClip[func](payload);

  if (!res.result || !audioRes.result) {
    // TODO: Shouldn't we return the result of the audioRes?
    return res;
  }

  res.execute();
  audioRes.execute();
  return _this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
    selfExecute: true,
    direction: _DIRECTIONS._UP
  });
}
/**
 * Along with the expected props for the Clip on the props support the audio key.
 * The audio can take one of the 3 following values:
 * - "on": The Clip has audio enabled
 * - "off": The Clip has audio disabled
 * - "only": The Clip is only audio
 *
 * Also, in the case audio is on or only the user should pass the "audioSources"
 * key containing all the audio sources they want to pass on the WebAudio Context
 * of their clip. Please check AudioClip for details on the expected format
 * */


class HTMLDescriptiveClip extends Playable {
  // eslint-disable-next-line sonarjs/cognitive-complexity
  constructor(attrs) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let attrsToPass;
    let propsToUse;

    if (props === null) {
      attrsToPass = {};
      propsToUse = attrs;
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = attrs;
      propsToUse = props;
    }

    super(attrsToPass, propsToUse); // mustHaveNullClip is a property that gets true in the case the Clip is a CASI and on the same time
    // has @expression dynamic values either on its attrs or props

    this.mustHaveNullClip = false;
    this.initParams = propsToUse.initParams || {}; // check if the Clip has initParamsValidationRules

    if (hasOwnProp(propsToUse, 'initParamsValidationRules')) {
      const ipValidation = validateObject(propsToUse.initParamsValidationRules, this.initParams, 'Error on initParams validation');

      if (!ipValidation.result) {
        helper.error("Clip initParams validation failed. Switching to non-blocking blank Clip");
        return NBEC(this, ipValidation.errors);
      }
    }

    const propsValidation = validateProps({
      props: this.props
    }, clipPropsRule, this.constructor, this.id);

    if (!propsValidation.result) {
      return propsValidation;
    }
    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class.
    Similarly, propsStaggers hold the same info only this time for props
    */


    this.attributesStaggers = [];
    this.propsStaggers = [];
    const dynamicValuesReport = this.setupDynamicValues(); // isTheRootClip defines whether the Clip is the root or not. It depends on
    // the host or selector parameter passed on props (if host is present then
    // the Clip is the root Clip while if the Clip gets initialised by a selector
    // is not)

    this.isTheRootClip = false; // a list of subscribers (functions) to volume change of the clip

    this.volumeChangeSubsribers = {};
    const ingredients = {
      id: this.id,
      attrs: attrsToPass,
      props: { ...propsToUse,
        html: hasOwnProp(propsToUse, 'html') ? propsToUse.html : this.html,
        css: hasOwnProp(propsToUse, 'css') ? propsToUse.css : this.css,
        fonts: hasOwnProp(propsToUse, 'fonts') ? propsToUse.fonts : this.fonts,
        runTimeInfo: this.runTimeInfo,
        subscribe: this.subscribe.bind(this),
        // cleanup any delay, hiatus and repeats
        repeats: 1,
        delay: 0,
        hiatus: 0
      },
      plugin_npm_name: this.constructor.plugin_npm_name,
      Channel: this.constructor.Channel,
      DescriptiveIncident: this
    }; // Decide what kind of audio (or non-audio) Clip we are dealing with

    this.audio = 'on';

    if (hasOwnProp({ ...this.constructor
    }, 'audio')) {
      this.audio = this.constructor.audio;
    }

    if (hasOwnProp(propsToUse, 'audio')) {
      this.audio = propsToUse.audio;
    } // decide if this is the root clip


    if ( // if it's a CASI of a BrowserClip then ingredients get OriginalCASIClip as Incident
    hasOwnProp(propsToUse, 'selector') && propsToUse.selector !== undefined && this.constructor.customClip !== true) {
      ingredients.Incident = OriginalCASIClip; // TODO it doesn't take in account the get html and get css of the Descriptive Clip
    } else if ( // if it's a CASI of a custom Clip then the technique of passing the Incident
    // it's different. We wrap it on a temporary FrgmentedClip and we position it in there
    hasOwnProp(propsToUse, 'selector') && propsToUse.selector !== undefined && this.constructor.customClip === true) {
      delete ingredients.props.selector;
      const FragmentWrapper = new OriginalCASIClip({
        html: '<div id="clip-container"></div>',
        css: '',
        fonts: []
      });
      ingredients.props.host = FragmentWrapper.rootElement;
      ingredients.Incident = this.constructor.Incident;
    } else if ( // else if it's a root Clip but it's an WebAudio. No Incident is passed,
    // this case is not allowed
    this.audio === 'only' && this.props.root !== true) {
      // audioClips can never be the root
      this.isTheRootClip = false;
    } else {
      // finally, if it's a root (non-WebAudio) Clip we pass as Incident directly the
      // constructor defined by the Incident itself. No need for fragments here
      this.isTheRootClip = true;
      /*
            blockingWaitings are been triggered by Incidents when there is the
            need to halt the Clip's execution and wait. As an example a blocking
            waiting can be set by an WebAudio Playback Incident when the audio has
            not been loaded yet.
            Each blocking waiting has an id and via the same id the waiting can be
            unblocked.
            The blockingWaitings property of the root Clip is a collection with
            keys the blocking waitings ids and values the description of each waiting
            which consists of:
            {
                id
                description
                incidentId
            }
            The blocking waitings are triggered by real Incidents living on the real
            Clips of the Descriptive Clip (either the audioClip or the realClip).
            The root that a waiting set or unset follows is from any real incident
            up to its ContextAware Incident and from there
            up to the real Clip and from there to its DescriptiveTree and from there
            all the way up to the root Descriptive Clip.
            Blocking waitings must always be triggered on the "onProgress" or on
            the "play" methods of Incidents. Setting a blocking waiting from anywhere
            else is an error
            */

      this.blockingWaitings = {};
      ingredients.Incident = this.constructor.Incident;
    } // we initialise real and audio clips of the Clip by checking the static audio
    // property
    // the property this.audio helps incidentFromDescription identify if the Incident
    // participates or not on the audioClip. By default is "on" but if the props.audio is set to off
    // it turns to "off" so the DC gets totally ignored on the addition process on audio clip

    /* The audio value is set in the following manner
        - first we check if the Class has a static audio parameter and if yes we keep it
        - then we check if this.props has the audio key and if yes we keep this one
        - otherwise we use the default ("on")
    */

    /**************** AUDIO CLIP SETUP START ***********************/


    if (this.audio === 'on' || this.audio === 'only') {
      // if there are audioSources related dynamic values we need to initialise them right here and now
      const audioIngredients = {
        id: this.id,
        attrs: {},
        props: {
          audioSources: hasOwnProp(propsToUse, 'audioSources') ? propsToUse.audioSources : this.audioSources,
          runTimeInfo: this.runTimeInfo,
          subscribe: this.subscribe.bind(this),
          hiatus: this.hiatus,
          delay: this.delay,
          repeats: this.repeats,
          initParams: this.initParams
        },
        plugin_npm_name: this.constructor.plugin_npm_name,
        Channel: this.constructor.Channel,
        Incident: AudioClip,
        DescriptiveIncident: this
      }; // in the case the audioSources contain @initParams we should resolve here using the initParams passed to the Clip

      if (hasOwnProp(propsToUse, 'audioSources')) {
        audioIngredients.props.audioSources = this.resolveAudioSources(propsToUse.audioSources);
      }

      this.audioClip = incidentFromIngredients(audioIngredients);
    } else {
      this.audio = 'off';
      this.audioClip = new NullClip();
    }
    /**************** AUDIO CLIP SETUP END ************************/

    /**************** REAL CLIP SETUP START ***********************/


    if (this.audio === 'only') {
      // only audio means we should create a Null clip
      this.realClip = new NullClip();
    } else if ( // if either attrs or props has at least one expression then we should create a
    // Null Clip instead of a OriginalCASIClip.
    // TODO check from more dynamic values and decide on their handling
    !this.isTheRootClip && ( // in the case of root clip we want to allow the use of dynamic values such as @initParams
    hasOwnProp(dynamicValuesReport.attrs, 'expression') || hasOwnProp(dynamicValuesReport.props, 'expression') || hasOwnProp(dynamicValuesReport.attrs, 'initParams') || hasOwnProp(dynamicValuesReport.props, 'initParams'))) {
      this.mustHaveNullClip = true;
      this.realClip = new NullClip();
    } else {
      // happy path
      this.realClip = incidentFromIngredients(ingredients, true);
    }
    /**************** REAL CLIP SETUP END ************************/

    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */


    this.dynamicDurationValue = null; // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)

    this.passiveAddition = true;

    this._buildTree();

    this.passiveAddition = false;

    if (this.constructor.isAnimation && hasOwnProp(this.props, 'duration')) {
      this.resize(this.duration);
    }
  }

  get selectorToPassToChildren() {
    return null; // the Clip (any Clip) resets the selection cascading
  }

  get inheritedSelector() {
    return this._inheritedSelector;
  }

  set inheritedSelector(value) {
    this._inheritedSelector = value;
  }

  get html() {
    return '';
  }

  get css() {
    return '';
  }

  get fonts() {
    return [];
  }

  get audioSources() {
    return [];
  }

  resolveAudioSources(audioSources) {
    const toReturn = deepCopy(audioSources);

    for (let i = 0; i < this.propsStaggers.length; i++) {
      const dvalue = this.propsStaggers[i];

      if (dvalue.path.indexOf('audioSources') === 0) {
        assignValueToPath(toReturn, dvalue.path.replace('audioSources.', ''), dvalue.stagger.calculateValues([0], this.initParams)[0]);
      }
    }

    return toReturn;
  } // we overwrite detachFromParent so we can reset the Clip's realClip to NullClip in the case
  // there are expressions present on its dymaicValues


  detachFromParent() {
    super.detachFromParent();

    if (this.mustHaveNullClip) {
      this.realClip = new NullClip();
    }
  }

  get duration() {
    /*
    if the duration of the Incident is dynamic (because of staggers) the dynamicDurationValue
    which is the real duration of the Incident as it's calculated after applying it in the
    real world is #1 choice and it represents the truth for this Incident
     */
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    }
    /*
    if there is no dynamicDurationValue but there are props staggers then the Incident
    should inform its user that its duration is dynamic and can't be calculated yet
    as there is no context to be applied. This should only apply to CASIs and not root
    Clips though as root Clips can accept only the @initParams dynamic value which is directly
    transformed to the value of the initParam
     */


    if (this.propsStaggers.length > 0 && !this.isTheRootClip) {
      return 'dynamic';
    }
    /*
    Otherwise if props.duration is set then calculate duration using it
     */


    if (hasOwnProp(this.props, 'duration')) {
      return this.repeats * (this.delay + this.props.duration + this.hiatus);
    }
    /*
    if none of this is true then pass the classic duration value as define on Node
    which is the real duration of the Incident based on the calculations on its
    children
     */


    return super.duration;
  }
  /*
  Overwrites set duration of Node in order to support stagger props
  */


  set duration(milliseconds) {
    if (this.propsStaggers.length == 0) {
      super.duration = milliseconds;
      return;
    }

    for (let i = 0; i < this.propsStaggers.length; i++) {
      if (this.propsStaggers[i].path === 'repeats') {
        continue;
      }

      const newStaggerExpression = this.propsStaggers[i].stagger.resize(milliseconds / this.duration);
      assignValueToPath(this.props, this.propsStaggers[i].path, newStaggerExpression);
    }

    this.dynamicDurationValue = milliseconds;
  }
  /*
  systoleDiastole (which is defined in Node) is a method that is called by parent Groups
  to its children whenever they get resized. DescriptiveClips (when used as Animations)
  have the characteristic that they need to store the resize to their props as this is
  exportable and considered as the source of truth when it comes to their duration
   */


  systoleDiastole(durationFraction) {
    if (this.constructor.isAnimation) {
      if (!this.props.duration) {
        this.props.duration = durationFraction * this.calculatedDuration;
      } else {
        this.props.duration *= durationFraction;
      }
    }

    this.realClip._resize(durationFraction);

    super.systoleDiastole(durationFraction);
  }

  exportLiveDefinition() {
    let includeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let def = super.exportLiveDefinition(includeId); // we add duration on props

    if (this.constructor.isAnimation) {
      def.props.duration = this.props.duration ? this.props.duration : this.calculatedDuration;
    }

    if (isFunction(this.props.html)) {
      def.props.html = this.props.html;
    }

    if (isFunction(this.props.css)) {
      def.props.css = this.props.css;
    }

    return def;
  }
  /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */


  _buildTree() {
    if (this.realClip === undefined) {
      return;
    }

    this.buildTree();
  }
  /**
   * When the resize command is given directly to a HTMLDescriptiveClip no checks
   * need to be performed.
   * HTMLDescriptiveClip directly invokes the _resize method of ExtendableClip which
   * resizes the full clip
   */


  resize(newSize) {
    if (this.duration === 'dynamic') {
      return {
        result: false,
        reason: _CantBeResized
      };
    }

    const scale = newSize / this.duration;

    this.realClip._resize(scale);

    this.audioClip._resize(scale);

    this.duration = newSize; // update this.props.duration accordingly

    if (this.constructor.isAnimation) {
      if (!this.props.duration) {
        this.props.duration = this.calculatedDuration;
      } else {
        this.props.duration *= scale;
      }
    }

    this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP
    });
    return this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });
  } // eslint-disable-next-line no-unused-vars


  manageEditAttrProps(newAttrs, type) {
    return {
      result: false,
      errors: ['Clips attributes and properties can not be edited']
    };
  }
  /** ************************* HANDLING METHODS ****************************** */
  // eslint-disable-next-line no-unused-vars


  handleCheckForClip(target, payload) {
    return true;
  }

  handleGetElements(target, payload) {
    return this.realClip.getElements(payload.selector);
  }

  handleCheckAddition(target, payload) {
    /* Is the responsibility of the HTMLDescriptiveClip to pass the addition request
        to its real clip and expect for a response.
     Before doing so, and only in the case of CASI, our DescriptiveClip will temporarily render the contents of the Clip
     on DOM so all initial values and everything else can be properly calculated and after the end of the process it will
     remove it from the DOM
    */
    if (!this.isTheRootClip && this.audio !== 'only' && this.constructor.customClip !== true) {
      this.realClip.renderOnDOM();
    }

    let res = this.realClip.addIncident(payload);
    const audioRes = this.audioClip.addIncident(payload);

    if (res.result && audioRes.result) {
      res.execute();
      audioRes.execute();
      res = this.putMsgOnPipeWithResult('flash', {}, 'RootClip', {
        selfExecute: true,
        direction: _DIRECTIONS._UP
      });
    }

    if (!this.isTheRootClip && this.audio !== 'only' && this.constructor.customClip !== true) {
      this.realClip.removeFromDOM();
    }

    return res;
  }

  handleCheckMove(target, payload) {
    return check(this, 'moveIncident', payload);
  }

  handleCheckDeletion(target, payload) {
    return check(this, 'removeIncident', payload);
  }

  handleCheckResize(target, payload) {
    return check(this, 'resizeIncident', payload);
  } // eslint-disable-next-line no-unused-vars


  handleFlash(target, payload) {
    if (!this.isTheRootClip) {
      return this.bypass();
    }

    this.flash();
  }
  /**
   * We overwrite exportDefinition of Groups so we add duration on the props
   * of the Clip
   */


  exportDefinition() {
    const toReturn = super.exportDefinition();

    if (this.constructor.isAnimation) {
      // only to Animations imported from plugins
      toReturn.props.duration = this.props.duration ? this.props.duration : this.calculatedDuration;
    }

    return toReturn;
  }
  /** **************** BLOCKING WAITINGS HANDLING ************************* */

  /** ******************************************************************** */


  handleSetBlock(target, payload) {
    // only accepts blocks if is the root clip and if it's playing
    if (this.isTheRootClip) {
      if (this.runTimeInfo.state === 'transitional') {
        return;
      }

      if (this.runTimeInfo.state !== 'blocked') {
        this.statusBeforeBlock = this.runTimeInfo.state;
      }

      this.blockingWaitings[payload.id] = payload;
      const options = {};

      if (payload.options.exceptional) {
        options.exception = payload.incidentId;
      } // We do setTimeout here because we want the block command to run after each and
      // every onProgress already scheduled to run


      const that = this;
      setTimeout(() => {
        that.block(options);
      }, 0);
    } else {
      return this.bypass();
    }
  }

  handleUnBlock(target, payload) {
    if (this.isTheRootClip) {
      if (hasOwnProp(this.blockingWaitings, payload.id)) {
        delete this.blockingWaitings[payload.id];

        if (Object.keys(this.blockingWaitings).length === 0) {
          if (this.statusBeforeBlock === 'playing') {
            this.previousTimeStamp = -1;
            this.play();
          } else {
            this.arm();
          }
        }
      }
    } else {
      return this.bypass();
    }
  }
  /* empty blocking waitings on transition start */


  stop() {
    super.stop();
    this.blockingWaitings = {};
  }
  /** ******************************************************************** */

  /** ******************************************************************** */


  onProgress(fraction, millisecond) {
    // fraction represents the fraction of the overall Descriptive Clip which equals the max duration between
    // realClip duration and audioClip duration
    // TODO we need to adjust the fraction here as the two clips might have different duration. The system works because the implemented Clips only use millisecond
    this.realClip.onProgress(fraction, millisecond);
    this.audioClip.onProgress(fraction, millisecond);
  }
  /** ********************************************************** */


  paste(host) {
    if (this.isTheRootClip) {
      return new ClipClone({
        host,
        descriptiveIncident: this
      });
    }

    return null;
  }

  flash() {
    this.realClip.flash();
    this.audioClip.flash();
  }

  get volume() {
    if (this.audio === 'off') {
      return 0;
    }

    return this.audioClip.volume;
  }
  /**
   *
   * @param {number} vol: a number from 0 to 1
   * @returns {{result: boolean}|{result: boolean, errors: [{type: string}]}}
   */


  setVolume(vol) {
    if (vol < 0 || vol > 1) {
      return {
        result: false,
        errors: [{
          type: 'invalid volume number'
        }]
      };
    }

    if (this.audio === 'off') {
      return {
        result: false,
        errors: [{
          type: 'can not set volume of Clip with audio off'
        }]
      };
    }

    this.audioClip.setVolume(vol);

    for (const id in this.volumeChangeSubsribers) {
      this.volumeChangeSubsribers[id](vol);
    }

    return {
      result: true
    };
  } // AUDIO RELATED METHODS
  // TODO there might might the need of detaching attached audioNodes from audioNodeSet on incident deletion

  /**
   * This method provides the ability to attach MediaElementAudioSourceNodes to the DI's audioClip's input
   * The method is mainly used by BrowserClips that have some kind of audio output which should be heard on playback
   * (such as the VideoClip of the video plugin)
   * @param {MediaElementAudioSourceNode} source
   */


  attachMediaElementSource(source) {
    if (this.audio === 'off') {
      return;
    }

    this.audioClip.context.audioContext.createMediaElementSource(source).connect(this.audioClip.context.masterNode.input);
  } // The following two methods subscribe and unsubscribe callbacks to volume change event.
  // This is particularly useful for autonomous sound sources

  /**
   *
   * @param {string} id: the unique subscription id
   * @param {function} funct: the callback function to listen to volume changes
   */


  volumeChangeSubscribe(id, funct) {
    return this.putMessageOnPipe('volumeChangeSubscribe', {
      type: 'subscribe',
      id,
      funct
    }, 'RootClip', {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    }).response;
  }

  volumeChangeUnsubscribe(id) {
    this.putMessageOnPipe('volumeChangeSubscribe', {
      type: 'unsubscribe',
      id
    }, 'RootClip', {
      selfExecute: true,
      direction: _DIRECTIONS._UP
    });
    return 0;
  }

  handleVolumeChangeSubscribe(target, payload) {
    if (!this.isTheRootClip) {
      return this.bypass();
    }

    switch (payload.type) {
      case 'subscribe':
        this.volumeChangeSubsribers[payload.id] = payload.funct;
        return this.volume;

      case 'unsubscribe':
        delete this.volumeChangeSubsribers[payload.id];
        return 0;
    }

    return false;
  }

}

_defineProperty__default["default"](HTMLDescriptiveClip, "isClip", true);

_defineProperty__default["default"](HTMLDescriptiveClip, "Incident", BrowserClip);

_defineProperty__default["default"](HTMLDescriptiveClip, "plugin_npm_name", '@donkeyclip/self-contained-incidents');

_defineProperty__default["default"](HTMLDescriptiveClip, "version", version);

_defineProperty__default["default"](HTMLDescriptiveClip, "Channel", ClipChannel);

_defineProperty__default["default"](HTMLDescriptiveClip, "ClassName", 'HTMLClip');

_defineProperty__default["default"](HTMLDescriptiveClip, "propsValidationRules", clipPropsRule);

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class DescriptiveAudioClip extends HTMLDescriptiveClip {
  constructor(attrs) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let attrsToPass;
    let propsToUse;

    if (props === null && hasOwnProp(attrs, 'audioSources')) {
      attrsToPass = {};
      propsToUse = attrs;
    } else if (props === null) {
      attrsToPass = attrs;
      propsToUse = {};
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = attrs;
      propsToUse = props;
    }

    propsToUse.audio = 'only';
    super(attrsToPass, propsToUse);
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * Effect class takes on constructor:
 * attrs:
 *  - animatedAttrs: valid animated attributes are "gain", "pan"
 *  -
 * */

class Effect extends MonoIncident {
  onProgress(ms) {
    const fraction = this.getFraction(ms); // eslint-disable-line no-unused-vars

    if (!this.element.soundLoaded) {
      this.setBlock('loading sound');
      this.element.pubSub.sub(this.id, () => {
        this.unblock();
      });
      return false;
    }

    if (this.attributeKey === 'gain') {
      const gain = (this.targetValue - this.initialValue) * fraction + this.initialValue;
      this.element.audioNodeSet.gainNode.gain.value = gain;
    } else if (this.attributeKey === 'pan') {
      const pan = (this.targetValue - this.initialValue) * fraction + this.initialValue;
      this.element.audioNodeSet.pannerNode.pan.value = pan;
    }
  }

  getScratchValue() {
    if (this.attributeKey === 'pan') {
      if (hasOwnProp(this.element.startValues, 'pan')) {
        return this.element.startValues.pan;
      }

      return 0;
    }

    if (this.attributeKey === 'gain') {
      if (hasOwnProp(this.element.startValues, 'gain')) {
        return this.element.startValues.gain;
      }

      return 1;
    }
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const dataSeparator = '|||';

class AudioPlaybackChannel extends ClipChannel {
  constructor(props) {
    super(props); // keeps the list of the ids of MediaIncidents that are currently been played
    // in the form `${id}|||$[contextId}`

    this.playingIncidentsIds = []; // when the Channel's Clip enters the transitional state the Channel ignores
    // moveTos. When the transition ends though, no matter the currentMillisecond
    // its Clip was it should recalc which sources to play as if we were going from
    // 0 to the the target millisecond because of the different way the Playback operates
    // (it has no onProgress). For this, it's very important to store the information
    // that it entered the transitional state so on the next playing state moveTo
    // to force as from ms 0.

    this.transitioned = false;
    props.subscribe(getAnId(), this._stateChange.bind(this), 0, 1, true);
  }
  /**
   *
   * @param {integer} ms: the millisecond of the incident
   * @param {string} state: the new state
   * @param {object} options: an optional options object. In the case of the exceptional block this object carries the
   * info and it should be considered as it directs our Channel not to stop a specific Incident
   * @private
   */


  _stateChange(ms, state) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (state === 'paused' || state === 'idle' || state === 'blocked') {
      this._stopPlayingIncidents(options);

      this.transitioned = true;
    }
  }
  /**
   *
   * @param {object} options: An options object. Currently supports the "exception" key that if present it holds the id
   * of an Incident that we want to exclude from our stop
   * @private
   */


  _stopPlayingIncidents() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    for (let i = 0; i < this.playingIncidentsIds.length; i++) {
      const incidentInfo = this.playingIncidentsIds[i].split(dataSeparator);

      if (!incidentInfo[0].startsWith(options.exception)) {
        this._incidentById(incidentInfo[0]).stop(incidentInfo[1]);
      }
    }

    this.playingIncidentsIds = [];
  }
  /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  moveTo(from, to, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (this.runTimeInfo.state === 'transitional' || !!forceReset) {
      this.transitioned = true;

      this._stopPlayingIncidents();

      for (let i = 0; i < this.incidents.length; i++) {
        const {
          id,
          millisecond
        } = this.incidents[i];

        const incident = this._incidentById(id);

        let end;

        if (to < millisecond) {
          end = 0;
        } else if (to > millisecond + incident.duration) {
          end = incident.duration;
        } else {
          end = to - millisecond;
        }

        incident.onProgress(end, contextId, true);
      }

      return;
    }

    if (this.transitioned) {
      from = 0;
      this.transitioned = false;
    } // the only way AudioPlaybackChannel can accept from > to is when its owner Clip is starting a fresh loop
    // as the AudioPlaybackChannel does not execute on seek command. In this case we should stop everything and
    // set from equals to 0


    const freshLoop = from > to;
    const incidents = this.incidents;

    for (let i = 0; i < incidents.length; i++) {
      const laneItem = incidents[i];
      const millisecond = laneItem.millisecond;

      const MediaIncident = this._incidentById(laneItem.id);

      const duration = MediaIncident.duration;
      const end = millisecond + duration;
      const incidentID = "".concat(laneItem.id).concat(dataSeparator).concat(contextId); // Finishing animations

      if (end > from && end <= to || freshLoop) {
        MediaIncident.stop(contextId);
        const index = this.playingIncidentsIds.indexOf(incidentID);

        if (index > -1) {
          this.playingIncidentsIds.splice(index, 1);
        }
      } // Starting animations


      const fromToUse = freshLoop ? 0 : from;

      if (millisecond >= fromToUse && millisecond < to && end > to) {
        const overcameEnd = (to - millisecond) / duration >= 1;
        const fraction = overcameEnd ? 1 : (to - millisecond) / duration;
        const ms = overcameEnd ? duration : to - millisecond;
        const startAttempt = MediaIncident.play(fraction, ms, contextId);

        if (startAttempt) {
          this.playingIncidentsIds.push(incidentID);
        }
      }
    }

    this.runTimeInfo.currentMillisecond = to;
  }

}

/*
dna:
- originalId
- context
*/

class MediaPlay {
  constructor() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let dna = arguments.length > 2 ? arguments[2] : undefined;

    _defineProperty__default["default"](this, "getIncidentsByChannel", getIncidentsByChannel.bind(this));

    _defineProperty__default["default"](this, "setBlock", block.bind(this));

    _defineProperty__default["default"](this, "unblock", unblock.bind(this));

    // super(props);
    this.attrs = attrs;
    this.props = props;
    this.dna = dna;
    this.context = dna.context;
    this.mcid = dna.mcid;
    this.id = props.id || getAnId();
    this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
    // is set to true so we prevent multiple executions of the onGetContext method

    this.gotContext = false;
    /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */

    this.plugin_channel_class = AudioPlaybackChannel;
    this.mc_plugin_npm_name = 'motor-cortex-js-media-playback';

    if (hasOwnProp(props, 'plugin_channel_class')) {
      this.plugin_channel_class = props.plugin_channel_class;
    }

    if (hasOwnProp(props, 'mc_plugin_npm_name')) {
      this.mc_plugin_npm_name = props.mc_plugin_npm_name;
    }

    this.hasIncidents = false;
    /**
     * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
     * on specific points on their timeline.
     */

    this.autoGenerated = false;
    this.onInitialise(attrs, props);
  }

  get selector() {
    return this.props.selector;
  }

  get element() {
    return this.context.getElementByMCID(this.mcid);
  }

  _onGetContextOnce() {
    // if the Incident belongs to a fragmented context there absolutely
    // no reason to run the getContext method of it
    if (this.context.fragment === true) {
      return;
    }

    try {
      if (!this.gotContext) {
        this.onGetContext();
        this.gotContext = true;
      }
    } catch (e) {
      helper.error(e, this.mcid);
    }
  }

  onGetContext() {
    helper.info('Overwrite the "onGetContext" method with the code you want to get executed', 'info');
  }

  lastWish() {}

  onInitialise() {
    helper.info('Overwrite the "onInialise" method with the code you want to get executed', 'info');
  }
  /**
   * Method called on progress of the timed incident.
   * @param {int} milliseconds - the number of milliseconds passed from start of the incident
   */
  // eslint-disable-next-line no-unused-vars


  onProgress(milliseconds) {}
  /**
   * starts the execution of the media from the specified millisecond
   * @returns {boolean}
   * */
  // eslint-disable-next-line no-unused-vars


  play(millisecond) {
    return true;
  }
  /**
   * stops the execution of the media
   * */


  stop() {}

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/**
 * expects on its props:
 * - selector
 * - duration
 * - startFrom (optional)
 * */

class AudioPlayback$1 extends MediaPlay {
  play(millisecond) {
    if (!this.element.soundLoaded) {
      this.setBlock('loading sound');
      this.element.pubSub.sub(this.id, () => {
        this.unblock();
      });
      return false;
    }

    let startFrom = 0;

    if (hasOwnProp(this.props, 'startFrom')) {
      startFrom = this.props.startFrom;
    } // TODO the audioNode can be created on the _setBuffer method of AudioContextHandler once and stored on the element's
    // object so we don't need to recreate it every time here


    this.audioNode = audioContext.createBufferSource();
    this.audioNode.buffer = this.element.buffer;
    this.audioNode.connect(this.element.audioNodeSet.input);
    this.audioNode.start(0, (millisecond + startFrom) / 1000);
    return true;
  }

  stop() {
    if (this.audioNode) this.audioNode.stop();
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const npm_name = '@donkeyclip/motorcortex-soundsystem';
const name = 'Internal MotorCortex Soundsystem';
const incidents = [{
  exportable: AudioPlayback$1,
  name: 'AudioPlayback'
}, {
  exportable: Effect,
  name: 'AudioEffect'
}];
const Clip = {
  exportable: AudioClip
};
const audio = 'only';
var audioPlugin = {
  npm_name,
  name,
  incidents,
  Clip,
  audio
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

function updateFinalValues(affectedIncident, initialValues, originalFinalValues, finalValues) {
  let change = false;
  const keys = Object.keys(initialValues);

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];

    if (!hasOwnProp(originalFinalValues, key)) {
      change = true;
      finalValues[key] = initialValues[key];
    }
  }

  affectedIncident.animatedAttributeValue = finalValues;
  return change;
}
/**
 * This function takes as input the index of the affected incident on the lane,
 * the lane and it re-calculates the
 * initial and final values of all the following incidents in the lane.
 * The function is used only in cases of combo attributes
 *
 * @param {boolean} store - if set to true the first Incident to be edited stores the
 *      initial values as its pureInitialValues
 * */


function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {
  let store = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const affectedItem = lane[affectedIndex];
  const affectedIncident = incidentsById[affectedItem.id];
  affectedIncident.setInitialValue(newInitialValues, store);
  const change = updateFinalValues(affectedIncident, affectedIncident.initialValue, affectedIncident.originalAnimatedAttributeValue, affectedIncident.animatedAttributeValue); // / if the final values have changed according to the new initial values and there is
  // a following incident on the lane

  if (change) {
    affectedIncident.lastWish();
    affectedIncident.onGetContext();
  }

  if (change && affectedIndex < lane.length - 1) {
    setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1, false);
  }
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class LanesHandler {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    /**
     * Keeps the lanes of the Channel in the form:
     * {
     *  <motorcortex-id>_<attribute>: [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
     * }
    /** @type {{}}
     */
    this.lanes = {};

    if (props.lanes) {
      this.lanes = props.lanes;
    }
    /**
     * An object that will will hold the index of the last animated item of the lane per contextid
     * This information is useful for the faster identification of the items that should
     * be animated when progressing from ms1 to ms2
     * The information will be kept in the form:
     * {
     *   <contextid>: {
     *    {
     *      <lane_id>: <index>,
     *      ...
     *    }
     *  }
     * @type {{}}
     */


    this.lastAnimatedItemPerLane = {};
    this.comboAttributes = {};

    if (props.comboAttributes != null) {
      this.comboAttributes = props.comboAttributes;
    }
    /**
      Keeps an indexing of the lanes each Animation belongs to. The form is the following:
      belongingLaneKeysByAnimationId: {
          <animation_id>: [laneKey1, laneKey2, ...],
          <animation_id>: [laneKey2, laneKey3, ...],
          ...
      }
     * @type {{}}
    */


    this.belongingLaneKeysByAnimationId = {};

    if (props.belongingLaneKeysByAnimationId) {
      this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;
    }
    /*
        keeps all Incidents (that appear on the lanes) mapped on a key - value pair
        object on which the keys are the ids and the values the corresponding Incidents.
        The Incidents of this object are ContextAwareIncidents
        */


    this.incidentsById = {}; // we need to keep this

    if (props.incidentsById) {
      this.incidentsById = props.incidentsById;
    }
  }
  /**
   * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
   * No checks are performed.
   * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
   * run.
   * @param {number} durationFraction: the fraction between the new duration and the current
   */


  _resize(durationFraction) {
    const keys = Object.keys(this.lanes); //._keys();

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const theLane = this.lanes[key];

      for (let j = 0; j < theLane.length; j++) {
        theLane[j].millisecond = theLane[j].millisecond * durationFraction;
      }
    }
  }
  /**
   * it creates a new LanesHandler that acts as a sanbox for testing changes
   */


  createTestLanesSanbox() {
    const props = {
      lanes: createProxy(this.lanes),
      belongingLaneKeysByAnimationId: createProxy(this.belongingLaneKeysByAnimationId),
      incidentsById: { ...this.incidentsById
      }
    };

    if (this.comboAttributes) {
      props.comboAttributes = this.comboAttributes;
    }

    return new LanesHandler(props);
  }

  getLane(mcid, attr) {
    return this.lanes[getLaneKey(mcid, attr)];
  }

  applySandboxChanges(SanboxObject) {
    this.lanes = SanboxObject.lanes.exportFlattened();
    this.belongingLaneKeysByAnimationId = SanboxObject.belongingLaneKeysByAnimationId.exportFlattened();
    this.incidentsById = { ...SanboxObject.incidentsById
    };
  }
  /**
   * return true if lane exists or false otherwise
   * @param {String} mcid
   * @param {String} attr
   * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false
   */


  laneExists(mcid, attr) {
    let ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const laneKey = getLaneKey(mcid, attr); // TODO: Figure out why using the hasOwnProp here breaks the tests
    // eslint-disable-next-line no-prototype-builtins

    if (this.lanes.hasOwnProperty(laneKey)) {
      return true;
    }

    if (ifNotCreateIt) {
      this.lanes.setValue(laneKey, []);
    }

    return false;
  }
  /**
   * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
   * @param {string} mcid
   * @param {String} attr
   * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
   *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
   *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
   *  of them together guarantees that there is going to be no conflict between them even after the edit
   * @param {Number} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
   *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)
   * @retuns {array} - a list of all overlapping animations of the lane
   */


  getOverlappingAnims(_ref, mcid, attr) {
    let {
      millisecond,
      incident
    } = _ref;
    let excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    let testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    const lane = this.lanes[getLaneKey(mcid, attr)];
    if (!lane) return [];
    const arr = [];

    for (let i = 0; i < lane.length; i++) {
      const existingAnim = lane[i];
      let durationToUseOnChecks = testDuration !== null && testDuration !== void 0 ? testDuration : incident.duration;
      const duration = this.incidentsById[existingAnim.id].duration;

      if (existingAnim.id !== incident.id && !excludeIdsFromCheck.includes(existingAnim.id) && ( // existing anim starts within the new anim's extend
      existingAnim.millisecond >= millisecond && existingAnim.millisecond < durationToUseOnChecks + millisecond || // or ends within the new anim's extend
      existingAnim.millisecond + duration > millisecond && existingAnim.millisecond + duration <= durationToUseOnChecks + millisecond || // or it starts before and ends after the new anim's extend
      existingAnim.millisecond < millisecond && existingAnim.millisecond + duration > durationToUseOnChecks + millisecond)) {
        arr.push(existingAnim);
      }
    }

    return arr;
  }
  /**
   * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
   * No checks are performed, just execution.
   * This method is executed on the context of SandboxLanesHandler
   * @param {String} mcid
   * @param {String} attr
   * @param {Number} millisecond
   * @param {Object} incident
   */


  addElementToLane(mcid, attr, millisecond, incident) {
    const executables = [];
    const laneKey = getLaneKey(mcid, attr);
    this.incidentsById[incident.id] = incident;
    const laneElement = {
      millisecond,
      id: incident.id
    };
    this.laneExists(mcid, attr, true);
    this.lanes.pushValue(laneKey, laneElement);
    this.lanes[laneKey].sortBy('millisecond'); // uses the ObjectProxy's sortBy (we're on Sandbox env)

    const sortedLane = Array.from(this.lanes[laneKey]); // we use the spread operator as we want to work on the snapshot of the lanes before the rest of the Incidents enter

    const newAnimsIndex = sortedLane.findIndex(item => item.id === incident.id); // uses ObjectProxy's findIndex
    // indexing stuff

    if (!hasOwnProp(incident.id)) {
      this.belongingLaneKeysByAnimationId.setValue(incident.id, [laneKey]);
    } else {
      this.belongingLaneKeysByAnimationId.pushValue(incident.id, laneKey);
    } // step 1: set the initial values of the new Animation


    if (newAnimsIndex === 0) {
      // if the newly entered animation is the first of the lane
      if (sortedLane.length > 1) {
        // and it has other animations too
        const pureInitialValues = this.incidentsById[sortedLane[1].id].pureInitialValues;
        executables.push(() => {
          incident.setInitialValue(pureInitialValues);
        });
      } else {
        executables.push(() => {
          incident.setInitialValue();
        });
      }
    } else {
      executables.push(() => {
        const previousAnimValues = this.incidentsById[sortedLane[newAnimsIndex - 1].id].animatedAttributeValue;
        incident.setInitialValue(previousAnimValues);
      });
    }
    /* if the attribute of the lane is a compo attribute */


    if (hasOwnProp(this.comboAttributes, attr)) {
      executables.push(() => {
        setInitialValue(sortedLane, this.incidentsById, incident.initialValue, newAnimsIndex);
      });
    } // step 2: set the initial values of the following Animation (if any).


    if (newAnimsIndex + 1 < sortedLane.length) {
      const nextAnimeId = sortedLane[newAnimsIndex + 1].id;
      executables.push(() => {
        this.incidentsById[nextAnimeId].setInitialValue(incident.animatedAttributeValue);

        if (this.incidentsById[nextAnimeId].gotContext) {
          this.incidentsById[nextAnimeId].lastWish();
          this.incidentsById[nextAnimeId].onGetContext();
        }
      });
    }

    return executables;
  }
  /**
   * it justs updates the lane
   * It gets executed on the context of the real LanesHanlder and not of the Sanbox
   * No checks are performed, just execution
   * @param {array} affectedAnimationsIds
   * @param {int} millisecondDelta
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  updateLane(affectedAnimationsIds, millisecondsDelta) {
    // first we group the affected animations by lanes
    const affectedLanes = {};
    const that = this;

    for (let i = 0; i < affectedAnimationsIds.length; i++) {
      const belongingLanes = this.belongingLaneKeysByAnimationId[affectedAnimationsIds[i]];

      for (let j = 0; j < belongingLanes.length; j++) {
        const laneKey = belongingLanes[j];

        if (!hasOwnProp(affectedLanes, laneKey)) {
          affectedLanes[laneKey] = {
            animations: [],
            lane: that.lanes[laneKey],
            laneData: getMCIDandAttrOutOfLaneKey(belongingLanes[j])
          };
        }

        affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);
      }
    } // for each of the affected lanes


    for (const laneKey in affectedLanes) {
      const {
        laneData,
        lane,
        animations
      } = affectedLanes[laneKey];
      const shallowLaneCopy = [...lane];
      shallowLaneCopy.sort((a, b) => a.millisecond - b.millisecond);
      const isComboAttr = hasOwnProp(this.comboAttributes, laneData.attribute); // edit lane items millisecond

      for (let k = 0; k < lane.length; k++) {
        if (animations.includes(lane[k].id)) {
          lane[k].millisecond += millisecondsDelta;
        }
      } // end for searching for the animations within the lane


      lane.sort((a, b) => a.millisecond - b.millisecond);
      this.lanes[laneKey] = lane;

      for (let i = 0; i < animations.length; i++) {
        const animationToCheck = animations[i];
        const animationIndexBeforeEdit = shallowLaneCopy.findIndex(item => item.id === animationToCheck);
        const animationIndexAfterEdit = lane.findIndex(item => item.id === animationToCheck);

        if (animationIndexBeforeEdit === animationIndexAfterEdit && animationIndexAfterEdit <= 1) {
          continue;
        }

        const animation = this.incidentsById[lane[animationIndexAfterEdit].id];

        if (animationIndexBeforeEdit + 1 < lane.length) {
          // if the animation was not the last animation on the lane before the edit
          // we should take care of the initial values of the animation's previous successor
          if (animationIndexBeforeEdit === 0) {
            // if the edited animation was the first one before the edit
            // pass its initial values to its previous successor as its new initial values
            if (isComboAttr) {
              setInitialValue(lane, this.incidentsById, animation.pureInitialValues, 0, true);
            } else {
              const animationIncident = this.incidentsById[shallowLaneCopy[1].id];
              animationIncident.setInitialValue(animation.pureInitialValues);
              animationIncident.onGetContext();
            }
          } else {
            // else if the edited animation was not the first one before the edit
            // meaning its previous successor is not the first one on the lane after the edit
            // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value
            if (isComboAttr) {
              const indexToAffect = animationIndexAfterEdit > animationIndexBeforeEdit ? animationIndexBeforeEdit : animationIndexAfterEdit;
              setInitialValue(lane, this.incidentsById, this.incidentsById[shallowLaneCopy[animationIndexBeforeEdit - 1].id].animatedAttributeValue, indexToAffect, true);
            } else {
              this.incidentsById[shallowLaneCopy[animationIndexBeforeEdit + 1].id].setInitialValue(this.incidentsById[shallowLaneCopy[animationIndexBeforeEdit - 1].id].animatedAttributeValue);
              this.incidentsById[shallowLaneCopy[animationIndexBeforeEdit + 1].id].onGetContext();
            }
          }
        } // for the edited animation itself now:


        if (animationIndexAfterEdit === 0) {
          // is it the first one (after edit)?
          // get the initial values of the previously 0 indexed animation of the lane
          if (isComboAttr) {
            setInitialValue(lane, this.incidentsById, this.incidentsById[shallowLaneCopy[0].id].pureInitialValues, animationIndexAfterEdit, true);
          } else {
            animation.setInitialValue(this.incidentsById[shallowLaneCopy[0].id].pureInitialValues);
            animation.onGetContext();
          }
        } else {
          // else if it is not the first one after editd
          // just grab the target value of the previous animation on the updated lane and set it as its initial value
          if (isComboAttr) {
            setInitialValue(lane, this.incidentsById, this.incidentsById[lane[animationIndexAfterEdit - 1].id].animatedAttributeValue, animationIndexAfterEdit, true);
          } else {
            animation.setInitialValue(this.incidentsById[lane[animationIndexAfterEdit - 1].id].animatedAttributeValue);
            animation.onGetContext();
          }
        } // for its new next animation (if it has one)


        if (animationIndexAfterEdit + 1 >= lane.length) {
          continue;
        } // set its initial value to equal the target value of the edited animation


        if (isComboAttr) {
          setInitialValue(lane, this.incidentsById, animation.animatedAttributeValue, animationIndexAfterEdit + 1, true);
          continue;
        }

        const incident = this.incidentsById[lane[animationIndexAfterEdit + 1].id];
        incident.setInitialValue(animation.animatedAttributeValue);
        incident.onGetContext();
      }
    } // end for each of the belonging lanes of the animation

  }
  /**
   * removes the list of animations as provided
   * @param {array} removedAnimations - an array with the removed animations' ids
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  deleteAnimations(removedAnimations) {
    const affectedLanes = {};

    for (let i = 0; i < removedAnimations.length; i++) {
      const id = removedAnimations[i]; // for each lane the affected Animation appears in

      const belongingLanes = this.belongingLaneKeysByAnimationId[id];

      for (let j = 0; j < belongingLanes.length; j++) {
        let lane = this.lanes[belongingLanes[j]];
        let animationIndexBeforeEdit = -1;

        for (let k = 0; k < lane.length; k++) {
          if (lane[k].id === id) {
            animationIndexBeforeEdit = k;
            break;
          }
        }

        const animationToDelete = { ...lane[animationIndexBeforeEdit]
        };
        const animationObjectToDelete = this.incidentsById[animationToDelete.id];
        const laneData = getMCIDandAttrOutOfLaneKey(belongingLanes[j]); // gets the lane without the removed animation

        const newLane = [];

        for (let k = 0; k < lane.length; k++) {
          if (lane[k].id !== id) {
            newLane.push(lane[k]);
          }
        }

        this.lanes[belongingLanes[j]] = newLane;
        lane = this.lanes[belongingLanes[j]];

        if (lane.length === 0) {
          // in case there are no more animations on the lane any more we reset
          // the lane by running the progress(0,0), so that the affected elements
          // will get back to their original attribute value
          animationObjectToDelete.onProgress(0);
          delete this.lanes[belongingLanes[j]];

          if (hasOwnProp(affectedLanes, belongingLanes[j])) {
            delete affectedLanes[belongingLanes[j]];
          }

          continue;
        }

        affectedLanes[belongingLanes[j]] = getMCIDandAttrOutOfLaneKey(belongingLanes[j]);
        const pureInitialValues = this.incidentsById[animationToDelete.id].pureInitialValues;

        if (animationIndexBeforeEdit >= lane.length || pureInitialValues === false) {
          continue;
        }

        if (hasOwnProp(this.comboAttributes, laneData.attribute)) {
          setInitialValue(lane, this.incidentsById, pureInitialValues, animationIndexBeforeEdit, true);
          continue;
        }

        const incident = this.incidentsById[lane[animationIndexBeforeEdit].id];
        incident.setInitialValue(pureInitialValues);
        incident.onGetContext();
      }

      delete this.belongingLaneKeysByAnimationId[removedAnimations[i]];
    }

    return affectedLanes;
  }
  /**
   * This method is responsible for recalculating the scratch values of the first
   * Incident of each of the lanes of the LanesHandler according to the provided
   * context id
   * */


  recalcScratchValues(contextId) {
    const keys = Object.keys(this.lanes);

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const theLane = this.lanes[key];

      if (theLane.length > 0) {
        const firstIncident = this.incidentsById[theLane[0].id];
        const newScratchValue = firstIncident.getScratchValue(contextId);
        const laneData = getMCIDandAttrOutOfLaneKey(key);

        if (hasOwnProp(this.comboAttributes, laneData.attribute)) {
          // if it is a combo
          setInitialValue(theLane, this.incidentsById, newScratchValue, 0, true);
        } else {
          // else if it's not a combo attribute
          firstIncident.setInitialValue(newScratchValue);
        }

        firstIncident.lastWish();
        firstIncident.onGetContext();
      }
    }
  } // lastAnimatedItemPerLane related methods


  getLastAffectedIndex(contextid, laneid, forceReset) {
    if (!this.lastAnimatedItemPerLane[contextid]) {
      this.lastAnimatedItemPerLane[contextid] = {
        [laneid]: [0, this.incidentsById[this.lanes[laneid][0].id].duration + this.lanes[laneid][0].millisecond]
      };
    } else if (!this.lastAnimatedItemPerLane[contextid][laneid] || forceReset) {
      this.lastAnimatedItemPerLane[contextid][laneid] = [0, this.incidentsById[this.lanes[laneid][0].id].duration + this.lanes[laneid][0].millisecond];
    }

    return this.lastAnimatedItemPerLane[contextid][laneid];
  }

  setLastAffectedIndex(contextid, laneid, index) {
    if (!this.lastAnimatedItemPerLane[contextid]) {
      this.lastAnimatedItemPerLane[contextid] = {};
    }

    this.lastAnimatedItemPerLane[contextid][laneid] = [index, this.incidentsById[this.lanes[laneid][index].id].duration + this.lanes[laneid][index].millisecond];
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const _FWDS = 'forwards';
const _BWDS = 'backwards';

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class IReMa {
  constructor() {
    /**
     * An object with numeric keys that keep the executionSubscribers per given iteration ms as array
     * In other words whichever lane has subscribed to a given period (e.g. from 100 to 200 on
     * the key 1 of our object) will be called if the target millisecond of the move is
     * within this area.
     * This object is stored per contextid
     * @type {{}}
     */
    this._executionSubscribers = {};
    this._bwExecutionSubscribers = {};
    /**
     * The interval (period) of milliseconds that we want to keep our Incident subscribers
     * @type {number}
     */

    this.subPeriod = 10;
    /**
     * The current period the execution is in (e.g. "0" or "100")
     * @type {number}
     */

    this._currentPeriod = {};
    this._nextIterationLanes = {};
  }

  reset() {
    this._executionSubscribers = {};
    this._bwExecutionSubscribers = {};
    this._nextIterationLanes = {};
  }

  executionSubscribers(contextid, direction) {
    var _toReturn$contextid;

    const toReturn = direction === _FWDS ? this._executionSubscribers : this._bwExecutionSubscribers;
    (_toReturn$contextid = toReturn[contextid]) !== null && _toReturn$contextid !== void 0 ? _toReturn$contextid : toReturn[contextid] = {};
    return toReturn[contextid];
  }

  subscribe(contextid, direction, step, laneid, lane) {
    var _subs$step;

    const subs = this.executionSubscribers(contextid, direction);
    (_subs$step = subs[step]) !== null && _subs$step !== void 0 ? _subs$step : subs[step] = {};

    subs[step][laneid] = () => {
      var _this$_nextIterationL, _this$_nextIterationL2;

      (_this$_nextIterationL2 = (_this$_nextIterationL = this._nextIterationLanes)[contextid]) !== null && _this$_nextIterationL2 !== void 0 ? _this$_nextIterationL2 : _this$_nextIterationL[contextid] = {};
      this._nextIterationLanes[contextid][laneid] = lane;
    };
  }

  nextIterationLanes(contextid, lanes) {
    var _this$_nextIterationL3, _this$_nextIterationL4;

    (_this$_nextIterationL4 = (_this$_nextIterationL3 = this._nextIterationLanes)[contextid]) !== null && _this$_nextIterationL4 !== void 0 ? _this$_nextIterationL4 : _this$_nextIterationL3[contextid] = { ...lanes
    };
    return this._nextIterationLanes[contextid];
  }

  setNextIterationLanes(contextid, lanes) {
    this._nextIterationLanes[contextid] = lanes;
  }

  currentPeriod(contextid) {
    var _this$_currentPeriod, _this$_currentPeriod$;

    (_this$_currentPeriod$ = (_this$_currentPeriod = this._currentPeriod)[contextid]) !== null && _this$_currentPeriod$ !== void 0 ? _this$_currentPeriod$ : _this$_currentPeriod[contextid] = 0;
    return this._currentPeriod[contextid];
  }

  setCurrentPeriod(contextid, period) {
    this._currentPeriod[contextid] = period;
  }

}

function executeSubscriber(periodSubs) {
  if (periodSubs) {
    const keys = Object.keys(periodSubs);

    for (let j = 0; j < keys.length; j++) {
      periodSubs[keys[j]]();
    }
  }
}

class AttributeChannel extends Channel {
  constructor(props) {
    var _props$comboAttribute;

    super(props);
    /*
        comboAttributes are attributes of type object, holding a number of other attributes.
        E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs
        in an object format keeping the value of each attribute at any given point.
        Combo attributes are passed on the constructor of the Channel in the format:
        props.comboAttributes: {
            transition: ['translateX', 'translateY', ...],
            <something_else>: ['<attrName1>', '<attrName2>', ...]
        }
        */

    this.comboAttributes = (_props$comboAttribute = props.comboAttributes) !== null && _props$comboAttribute !== void 0 ? _props$comboAttribute : {};
    /**
     * For incidents that do not have animatedAttrs there should be only one lane per element.
     * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
     * up with just one lane per element: <element_id>_<this.fixedAttributeName>
     */

    this.fixedAttributeName = '_';
    this.LanesHandler = new LanesHandler({
      comboAttributes: this.comboAttributes
    });
    this.irema = new IReMa();
    this.direction = _FWDS;
  }

  get lanes() {
    return this.LanesHandler.lanes;
  }

  get incidentsById() {
    return this.LanesHandler.incidentsById;
  }

  _resize(durationFraction) {
    this.LanesHandler._resize(durationFraction);
  }
  /* *******************************************************
    DECISION METHODS
  ******************************************************* */

  /**
   * All of the incidents coming to this method are element-attribute incidents meaning that they only
   * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
   * object
   *
   * @param {array} incidents - A collection of Incidents in the form:
   * {
   *  millisecond
   *  incident
   *  id
   * }
   * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
   *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
   *  but will also include an errors array on its return and also will only include the success callbacks on
   *  the execute key of its return
   * @returns either:
   *   {
   *       result:true,
   *       execute: // an array of functions that when executed it will add the Incidents on the Channels
   *   }
   *   or
   *   {
   *       result: false,
   *       errors
   *   }
   */


  checkAddition(incidents) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all-or-nothing';
    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
    /* an array where we keep all affected lanes so we can slip on them at the end.
    The format for each affected lane we keep is:
    {
        mcid: mcid,
        attribute: attribute
    }
    */

    const affectedLanes = []; // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
    // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
    // Because LanesSandboxHandler is only there for testing we don't want to execute these changes
    // during checks but still we need to do so on success. For this, the onSuccessActions array holds all executable
    // functions retured by various LanesHandlerSanbox functions so it can execute them on success.

    const onSuccessActions = [];
    const conflicts = [];

    for (let i = 0; i < incidents.length; i++) {
      let incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not

      const laneItem = incidents[i]; // in the form {millisecond, parentMillisecond, incident, id}

      const {
        incident
      } = laneItem; // the ContextAwareIncident of our MonoIncident

      let {
        mcid,
        attribute
      } = incident;
      attribute || (attribute = this.fixedAttributeName); // the attribute of the MonoIncident
      // maybe it has to

      LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

      affectedLanes.push({
        mcid,
        attribute
      }); // **** if the lane did exist before the new addition check for conflicts

      const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute); // helper.log(overlappingAnim)

      if (overlappingAnims.length > 0) {
        const overlappingIncident = this.incidentsById[overlappingAnims[0].id];
        incidentConflicts = true;
        conflicts.push({
          type: 'unauthorised, overlapping incidents on the same element',
          element_mcid: mcid,
          attribute,
          millisecond: overlappingAnims[0].millisecond,
          incident: overlappingIncident ? {
            attrs: overlappingIncident.DescriptiveIncident.attrs,
            props: overlappingIncident.DescriptiveIncident.props,
            duration: overlappingIncident.duration
          } : undefined
        });
      }

      if (!incidentConflicts) {
        const executables = LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);
        onSuccessActions.push(() => {
          for (let j = 0; j < executables.length; j++) {
            executables[j]();
          }

          incident._onGetContextOnce();
        });
      }
    } // end for each incident
    // if we have conflicts and the type = "all-or-nothing"


    if (conflicts.length > 0 && type === 'all-or-nothing') {
      return {
        result: false,
        errors: conflicts
      };
    } // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
    // This callback will apply all passing additions.
    // success message


    const lanesHandler = this.LanesHandler;

    const exec = function execFunct() {
      for (let i = 0; i < affectedLanes.length; i++) {
        const laneKey = getLaneKey(affectedLanes[i].mcid, affectedLanes[i].attribute);
        const sortedLane = LanesHandlerSandbox.lanes[laneKey].exportFlattened();
        sortedLane.sort((a, b) => a.millisecond - b.millisecond);
        LanesHandlerSandbox.lanes.setValue(laneKey, sortedLane);
      }

      for (let i = 0; i < onSuccessActions.length; i++) {
        onSuccessActions[i]();
      }

      lanesHandler.applySandboxChanges(LanesHandlerSandbox);
    };

    return {
      result: true,
      errors: conflicts,
      execute: exec
    };
  }
  /**
   * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
   * that apply the change
   * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
   * @param {number} millisecondsDelta - the milliseconds delta to apply to the incidents
   * @returns {object} -
   * either:
      {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
      }
    or
      {
        result: false,
        errors: // an array including all the errors / conflicts found on edit
      }
   */


  checkEdit(incidents, millisecondsDelta) {
    const affectedIncidentIds = [];

    for (let i = 0; i < incidents.length; i++) {
      affectedIncidentIds.push(incidents[i].id);
    }

    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
    const conflicts = []; // for each of the affectedAnimations

    for (let i = 0; i < incidents.length; i++) {
      let {
        incident: {
          id: incidentId,
          mcid,
          attribute
        }
      } = incidents[i];
      attribute || (attribute = this.fixedAttributeName);
      const lane = LanesHandlerSandbox.getLane(mcid, attribute); // check for conflicts and edit lane items millisecond

      for (let k = 0; k < lane.length; k++) {
        if (lane[k].id === incidentId) {
          const affectedAnim = lane[k];
          const testLaneElement = { ...affectedAnim
          };
          testLaneElement.millisecond += millisecondsDelta;
          testLaneElement.incident = LanesHandlerSandbox.incidentsById[testLaneElement.id];
          const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);

          if (overlappingAnims.length > 0) {
            conflicts.push({
              type: 'unauthorised, overlapping animations on the same element',
              meta: {
                element_mcid: mcid,
                attribute,
                newAnimation: testLaneElement,
                overlappingAnims
              }
            });
          }

          break;
        } // end of if we found the specific animation on the lane's sequence

      } // end of each lane's item

    } // end for each affected animation's id


    if (conflicts.length > 0) {
      return {
        result: false,
        errors: conflicts
      };
    }

    const that = this;

    const exec = function execFunct() {
      that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);
      that.irema.reset();
    };

    return {
      result: true,
      execute: exec
    };
  }
  /**
   * @param {array} incidents - [{id, start, end, startDelta}]
   * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
   *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
   * */


  checkResizedIncidents(incidents) {
    let fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const excludeIdsFromCheck = [];

    for (let i = 0; i < incidents.length; i++) {
      excludeIdsFromCheck.push(incidents[i].id);
    }

    const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
    const conflicts = []; // for each of the incidents passed

    for (let i = 0; i < incidents.length; i++) {
      // get the ContextAwareIncident
      let {
        mcid,
        attribute
      } = this.LanesHandler.incidentsById[incidents[i].id];
      attribute || (attribute = this.fixedAttributeName);
      const lane = LanesHandlerSandbox.getLane(mcid, attribute);
      const testDuration = incidents[i].end - incidents[i].start; // check for conflicts and edit lane items millisecond

      for (let k = 0; k < lane.length; k++) {
        if (lane[k].id !== incidents[i].id) {
          continue;
        }

        if (fullChannelResize) {
          break;
        }

        const testLaneElement = { ...lane[k]
        };
        testLaneElement.millisecond += incidents[i].startDelta;
        testLaneElement.incident = LanesHandlerSandbox.incidentsById[testLaneElement.id];
        const overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, excludeIdsFromCheck, testDuration);

        if (overlappingAnims.length > 0) {
          conflicts.push({
            type: 'unauthorized overlapping animations on the same element',
            meta: {
              element_mcid: mcid,
              attribute,
              newAnimation: testLaneElement,
              overlappingAnims
            }
          });
        }
      } // end of each lane's item

    } // end for each affected animation's id


    if (conflicts.length > 0) {
      return {
        result: false,
        errors: conflicts
      };
    }

    const that = this;

    const exec = function execFunct() {
      // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
      // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
      // success message
      for (let i = 0; i < incidents.length; i++) {
        that.LanesHandler.updateLane([incidents[i].id], incidents[i].startDelta);
      }

      that.irema.reset();
    };

    return {
      execute: exec,
      result: true
    };
  }
  /**
   *
   */


  checkDelete(removedAnimations) {
    const removedAnimationIds = [];

    for (let i = 0; i < removedAnimations.length; i++) {
      removedAnimationIds.push(removedAnimations[i].id);
    }

    const that = this;

    const exec = function execFunct() {
      that.LanesHandler.deleteAnimations(removedAnimationIds);
      that.irema.reset();
    };

    return {
      result: true,
      execute: exec
    };
  }
  /**
   * This method is responsible for recalculating the scratch values of the first
   * Incident of each of the lanes of the LanesHandler according to the provided
   * context id
   * */


  recalcScratchValues(contextId) {
    this.LanesHandler.recalcScratchValues(contextId);
  }
  /**
   * Slips to just one lane forwards
   * @param {string} laneid - the id of the lane
   * @param {array} lane - the lane to slip into
   * @param {number} from - the millisecond the slip starts from
   * @param {number} to - the target millisecond of the slip
   * @param {string} contextId - the contextId of the Incidents to slip
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  slipIntoLaneForwards(laneid, lane, from, to, contextId) {
    let forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    if (to === 0 && !forceReset) {
      return true;
    } // this flag indicates whether the lane should be included on the next circle or not


    let includeOnNextIteration = true;
    const participatingAnims = [];
    const lastAffectedIndex = this.LanesHandler.getLastAffectedIndex(contextId, laneid, forceReset);
    let newLastAffectedIndex = lastAffectedIndex[0];
    let endingPoint = lastAffectedIndex[1];
    let lastParticipatingFinished = false;

    for (let i = lastAffectedIndex[0]; i < lane.length; i++) {
      const laneItem = lane[i];

      if (laneItem.millisecond >= to) {
        // if the next Incident is outside the from-to area, further down
        if (!forceReset || i === 0) {
          const threshold = Math.floor(laneItem.millisecond / this.irema.subPeriod);
          this.irema.subscribe(contextId, _FWDS, threshold, laneid, lane);
        }

        includeOnNextIteration = false;
        break;
      } else if (endingPoint <= from) {
        // this case is for lanes that have completed their forwards execution
        if (i < lane.length - 1) {
          // for direction changes
          if (lane[i + 1].millisecond < to) {
            endingPoint = this.incidentsById[lane[i + 1].id].duration + lane[i + 1].millisecond;
          }
        } else {
          includeOnNextIteration = false;
        }
      } else if (endingPoint >= from && endingPoint <= to) {
        // the end of the Incident is within from-to
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = true;

        if (i < lane.length - 1) {
          endingPoint = this.incidentsById[lane[i + 1].id].duration + lane[i + 1].millisecond;
        } else {
          includeOnNextIteration = false;
        }
      } else {
        // to is within Incident
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = false;
        break;
      }
    }

    if (newLastAffectedIndex !== lastAffectedIndex[0]) {
      this.LanesHandler.setLastAffectedIndex(contextId, laneid, newLastAffectedIndex);
    }

    if (participatingAnims.length === 0) {
      // there are two cases forceReset can be used: a) when we are flashing the Clip
      // going from 0 to millisecond via flash method of ExtendableClip or when
      // we want to seek the Clip without executing it (like it was in transitional state)
      // we diferentiate the two by the from value which in case (a) is always 0
      if (!!forceReset && from === 0) {
        const firstIncident = this.incidentsById[lane[0].id];
        firstIncident.onProgress(0, contextId);
        return true;
      }

      return includeOnNextIteration;
    } // We only care about the last (in chronological order) Incident, as this
    // will define the final value


    const lastIndex = participatingAnims.length - 1;
    const participatingAnim = this.incidentsById[participatingAnims[lastIndex].id];
    const startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation ends before the target millisecond
    // and it's the last one on the row

    let end = !lastParticipatingFinished ? to - startMillisecond : participatingAnim._duration;
    participatingAnim.onProgress(end, contextId);
    return includeOnNextIteration;
  }
  /**
   * Slips to just one lane backwards
   * @param {string} laneid - the id of the lane
   * @param {array} lane - the lane to slip into
   * @param {number} from - the millisecond the slip starts from
   * @param {number} to - the target millisecond of the slip
   * @param {string} contextId - the contextId of the Incidents to slip
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  slipToLaneBackwards(laneid, lane, from, to, contextId) {
    let includeOnNextIteration = true;
    const participatingAnims = [];
    const lastAffectedIndex = this.LanesHandler.getLastAffectedIndex(contextId, laneid);
    let newLastAffectedIndex = lastAffectedIndex[0];
    let endingPoint = lastAffectedIndex[1];
    let lastParticipatingFinished = false;

    for (let i = lastAffectedIndex[0]; i >= 0; i--) {
      const laneItem = lane[i];

      if (endingPoint < to) {
        // if the next Incident is outside the from-to area, further down
        const threshold = Math.floor(endingPoint / this.irema.subPeriod);
        this.irema.subscribe(contextId, _BWDS, threshold, laneid, lane);
        includeOnNextIteration = false;
        break;
      } else if (laneItem.millisecond > from) {
        // this case is for lanes that have completed their backwards execution
        if (i > 0) {
          // for direction changes
          if (lane[i - 1].millisecond + this.incidentsById[lane[i - 1].id].duration < to) {
            endingPoint = this.incidentsById[lane[i - 1].id].duration + lane[i - 1].millisecond;
          }
        } else {
          includeOnNextIteration = true;
        }
      } else if (laneItem.millisecond <= from && laneItem.millisecond > to) {
        // the start of the Incident is within from-to
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = true;

        if (i > 0) {
          endingPoint = this.incidentsById[lane[i - 1].id].duration + lane[i - 1].millisecond;
        } else {
          includeOnNextIteration = false;
        }
      } else {
        // to is within Incident
        participatingAnims.push(laneItem);
        newLastAffectedIndex = i;
        lastParticipatingFinished = false;
        break;
      }
    }

    if (newLastAffectedIndex !== lastAffectedIndex[0]) {
      this.LanesHandler.setLastAffectedIndex(contextId, laneid, newLastAffectedIndex);
    }

    if (participatingAnims.length === 0) {
      return true;
    } // We only care about the last (in chronological order) Incident, as this
    // will define the final value


    const lastIndex = participatingAnims.length - 1;
    const participatingAnim = this.incidentsById[participatingAnims[lastIndex].id];
    const startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation starts before the target millisecond
    // and it's the last one on the row

    let end = !lastParticipatingFinished ? to - startMillisecond : 0;
    participatingAnim.onProgress(end, contextId);
    return includeOnNextIteration;
  }
  /**
    @param {number} from - the millisecond to start from
    @param {number} to - the millisecond to go to
    @param {string} contextId - the context id to "move"
    @param {boolean} forceReset - set to true if status recalc is needed after edit
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity


  moveTo(from, to, contextId) {
    let forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const direction = to >= from ? _FWDS : _BWDS; // TODO possible solution on 0-0 bug

    const executionSubscribers = this.irema.executionSubscribers(contextId, direction);

    if (forceReset || direction !== this.direction) {
      this.irema._nextIterationLanes = {}; // it might not needed
    }

    const currentNextIterationLanes = this.irema.nextIterationLanes(contextId, this.lanes);
    const currentPeriod = this.irema.currentPeriod(contextId);
    const newPeriod = Math.floor(to / this.irema.subPeriod);

    if (direction === _FWDS) {
      for (let i = currentPeriod; i <= newPeriod; i++) {
        executeSubscriber(executionSubscribers[i]);
      }
    } else {
      for (let i = currentPeriod; i >= newPeriod; i--) {
        executeSubscriber(executionSubscribers[i]);
      }
    } // step 1: iterate through all lanes


    const nextIterationLanes = {};
    const laneKeys = Object.keys(currentNextIterationLanes);
    const funcToRun = direction === _FWDS ? this.slipIntoLaneForwards.bind(this) : this.slipToLaneBackwards.bind(this);

    for (let i = 0; i < laneKeys.length; i++) {
      const lane = this.lanes[laneKeys[i]];
      const res = funcToRun(laneKeys[i], lane, from, to, contextId, forceReset);

      if (res) {
        nextIterationLanes[laneKeys[i]] = lane;
      }
    }

    this.irema.setCurrentPeriod(contextId, newPeriod);
    this.irema.setNextIterationLanes(contextId, nextIterationLanes);
    this.direction = direction;
  }

}

_defineProperty__default["default"](AttributeChannel, "type", 'attributes');

class DescriptiveIncident extends Leaf {
  constructor(attrs, props) {
    if (props === undefined) {
      props = attrs;
      attrs = {};
    }

    super(props);
    const propsValidation = validateProps(props, incidentPropsRule, this.constructor, this.id);

    if (!propsValidation.result) {
      return propsValidation;
    }

    this.inheritedSelector = null;
    this.attrs = attrs;

    if (!hasOwnProp(props, 'duration')) {
      props.duration = 0;
    }

    this.props = props;
    /*
    attributesStaggers is an array that holds a list of stagger objects. A stagger
    object has two keys, "path" and "stagger". path defines the path of the attribute that
    has stagger applied and the stagger is a Stagger Class.
    Similarly, propsStaggers hold the same info only this time for props
    */

    this.attributesStaggers = [];
    this.propsStaggers = [];
    this.setupDynamicValues();
    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */

    this.dynamicDurationValue = null; // the passive flag (when true) indicates that the Descriptive Group has been created
    // and passively added to a Clip or a Combo via buildTree method.
    // Defaults to false

    this.passive = false;
  }

  get duration() {
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    }

    if (this.propsStaggers.length > 0) {
      return 'dynamic';
    }

    return super.duration;
  }
  /*
  Overwrites set duration of Leaf in order to support stagger props
  */


  set duration(milliseconds) {
    if (this.propsStaggers.length > 0) {
      for (let i = 0; i < this.propsStaggers.length; i++) {
        if (this.propsStaggers[i].path === 'repeats') {
          continue;
        }

        const newStaggerExpression = this.propsStaggers[i].stagger.resize(milliseconds / this.duration);
        assignValueToPath(this.props, this.propsStaggers[i].path, newStaggerExpression);
      }

      this.dynamicDurationValue = milliseconds;
      return;
    }

    super.duration = milliseconds;
  }

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const {
      parentNode,
      id
    } = this; // get the position of the Incident within its parent

    const position = parentNode.getLeafPosition(id); // first detach the Incident from its parent

    parentNode.removeIncident(id); // keep a backup of the current attrs/props

    const oldAttrs = deepCopy(this[type]);
    this[type] = newAttrs;
    const res = parentNode.addIncident(this, position);
    this.resetDuration(true);

    if (!res.result) {
      parentNode.removeIncident(id);
      this[type] = oldAttrs;
      this.resetDuration();
      parentNode.addIncident(this, position);
    }

    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  handleCheckForInvalidSelectors() {
    const selector = this.selector();

    if (selector === null) {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'null selector'
      };
    }

    if (selector.charAt(0) === '&') {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'relative selector with no inherited selector',
        selector
      };
    }

    return this.bypass();
  }
  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */


  exportDefinition() {
    return {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props
    };
  }
  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */


  exportLiveDefinition() {
    let includeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let propsToReturn = deepCopy(this.props);

    if (!includeId) {
      delete propsToReturn.id;
    }

    return {
      Class: this.constructor,
      attrs: deepCopy(this.attrs),
      props: propsToReturn
    };
  }

}

_defineProperty__default["default"](DescriptiveIncident, "Incident", MonoIncident);

_defineProperty__default["default"](DescriptiveIncident, "plugin_npm_name", _MC_Attribute);

_defineProperty__default["default"](DescriptiveIncident, "version", version);

_defineProperty__default["default"](DescriptiveIncident, "Channel", AttributeChannel);

_defineProperty__default["default"](DescriptiveIncident, "ClassName", 'Incident');

_defineProperty__default["default"](DescriptiveIncident, "attrsValidationRules", null);

_defineProperty__default["default"](DescriptiveIncident, "propsValidationRules", incidentPropsRule);

function checkPlugin(main) {
  if (hasOwnProp(main, 'default')) {
    main = main.default;
  }

  const plugin_name = main.npm_name;

  if (!hasOwnProp(main, 'name')) {
    helper.notice("Notice on plugin ".concat(plugin_name, ". A plugin should have its name under the key \"name\". It's missing from this plugin"));
  } // TODO this might turn into a mandatory field in future versions


  if (!hasOwnProp(main, 'version')) {
    helper.notice("Notice on ".concat(plugin_name, ". Plugin should always expose its version number.\n      Plugin version is missing"));
  }

  if (!hasOwnProp(main, 'incidents')) {
    if (!hasOwnProp(main, 'Clip')) {
      helper.error("Error on plugin ".concat(plugin_name, ". A plugin must expose at least one Incident or a Clip.\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file while Clips on the \"Clip\"."));
      return false;
    }

    return true;
  }

  if (!Array.isArray(main.incidents)) {
    helper.error("Error on plugin ".concat(plugin_name, ". thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\n    Please refer to the documentation"));
    return false;
  } // We don't exit early here so we can provide warnings for all of the incidents


  let check = true;

  for (let i = 0; i < main.incidents.length; i++) {
    const exposedIncidentDefinition = main.incidents[i];

    if (isObject(exposedIncidentDefinition.exportable) && hasOwnProp(exposedIncidentDefinition.exportable, 'default')) {
      exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
    }

    const exposedIncidentPrototype = exposedIncidentDefinition.exportable.prototype;

    if (!(exposedIncidentPrototype instanceof DescriptiveGroup || exposedIncidentPrototype instanceof HTMLDescriptiveClip || exposedIncidentPrototype instanceof MonoIncident || exposedIncidentPrototype instanceof MediaPlay)) {
      helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex. ").concat(exposedIncidentDefinition.exportable.constructor.name, " doesn't.\nPlease refer to documentation"));
      check = false;
      continue;
    } // check if there are originalDims present and if yes, check their validity


    if (exposedIncidentPrototype instanceof HTMLDescriptiveClip) {
      if (!hasOwnProp(exposedIncidentDefinition, 'originalDims')) {
        helper.log("Warning on plugin ".concat(plugin_name, ". It's always good to provide originalDims\nwhen exposing Incidents extending DOMClip. By defining their original dims the users\nof your plugin will be able to define the desired dimensions of your Incident by\nthe \"containerParams object\""));
        continue;
      }

      const odc = originalDimsCheck(exposedIncidentDefinition.originalDims);

      if (!odc.result) {
        helper.error("Error on plugin ".concat(plugin_name, ". Invalid originalDims value passed on ").concat(exposedIncidentDefinition.name));
        check = false;
      }
    }

    if (!hasOwnProp(exposedIncidentDefinition, 'name')) {
      helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must have the \"name\" key which defines the name of the exported Incident.\nPlease refer to documentation"));
      check = false;
    }
  }

  return check;
} // plugin_name is the unique name of the plugin
// eslint-disable-next-line sonarjs/cognitive-complexity

function loadPlugin(plugin) {
  if (hasOwnProp(plugin, 'default')) {
    plugin = plugin.default;
  }

  if (!hasOwnProp(plugin, 'npm_name')) {
    plugin.npm_name = "plugin_".concat(new Date().getTime());
  }

  if (!checkPlugin(plugin)) {
    return false;
  } // thePlugin is the plugin object which will hold on its keys
  // the names of the exposed Incidents of its. The keys of this object
  // are going to be identical with the names of the classes exposed


  const thePlugin = {};

  if (hasOwnProp(plugin, 'Clip')) {
    if (!hasOwnProp(plugin.Clip, 'exportable')) {
      var _class;

      const DynamicDescriptiveClip = (_class = class DynamicDescriptiveClip extends HTMLDescriptiveClip {}, _defineProperty__default["default"](_class, "Incident", plugin.Clip), _defineProperty__default["default"](_class, "plugin", plugin.npm_name), _defineProperty__default["default"](_class, "version", plugin.version || '*'), _defineProperty__default["default"](_class, "audio", plugin.audio || 'off'), _defineProperty__default["default"](_class, "customClip", true), _class);
      helper.warning("It's always good to provide attributesValidationRules to the exported incidents. ".concat(plugin.npm_name, ".Clip doesn't provide it"));
      thePlugin.Clip = DynamicDescriptiveClip;
    } else {
      var _class2;

      const DynamicDescriptiveClip = (_class2 = class DynamicDescriptiveClip extends HTMLDescriptiveClip {}, _defineProperty__default["default"](_class2, "Incident", plugin.Clip.exportable), _defineProperty__default["default"](_class2, "plugin", plugin.npm_name), _defineProperty__default["default"](_class2, "version", plugin.version || '*'), _defineProperty__default["default"](_class2, "audio", plugin.audio || 'off'), _defineProperty__default["default"](_class2, "customClip", true), _class2);
      let validationMethod;

      if (hasOwnProp(plugin.Clip, 'attributesValidationRules')) {
        validationMethod = validator.compile(plugin.Clip.attributesValidationRules);
      }

      class WrapperClass {
        constructor(_attrs, _props) {
          let attrs = _attrs;
          let props = _props;

          if (_props == undefined) {
            props = attrs;
            attrs = {};
          }

          let instantiatedIncident;

          if (hasOwnProp(plugin.Clip, 'attributesValidationRules')) {
            const validationResult = validationMethod(attrs);

            if (validationResult.length > 0) {
              let errorMessage = "Error on plugin's \"".concat(plugin.npm_name, "\" Clip instantiation. Errors:");

              for (let j = 0; j < validationResult.length; j++) {
                errorMessage += "\n - ".concat(validationResult[j].message, ". ").concat(validationResult[j].actual, " provided");
              }

              helper.error(errorMessage);
              helper.log('breaking');
              return {
                result: false,
                errors: validationResult
              };
            } else {
              helper.log('instantiating');
              instantiatedIncident = new DynamicDescriptiveClip(attrs, props);
              instantiatedIncident.attrsValidationRules = plugin.Clip.attributesValidationRules;
              instantiatedIncident.attrsValidationMethod = validationMethod;
            }
          } else {
            helper.log('instantiating');
            instantiatedIncident = new DynamicDescriptiveClip(attrs, props);
            instantiatedIncident.attrsValidationRules = null;
            helper.warning("It's always good to provide attributesValidationRules to the exported incidents. ".concat(plugin.npm_name, ".").concat(instantiatedIncident.constructor.name, " doesn't provide it"));
          }

          return instantiatedIncident;
        }

      }

      thePlugin.Clip = WrapperClass;
    }
  } // if the plugin definition has compositeAttributes then we dynamically
  // create a new Channel class extending AttributeChannel setting the
  // composite Attributes on the fly. We can then use this Channel class
  // for all Incidents exposed by the plugin


  let AttributeChannelToUse = AttributeChannel;

  if (hasOwnProp(plugin, 'compositeAttributes')) {
    AttributeChannelToUse = class extends AttributeChannel {
      constructor(props) {
        props.comboAttributes = plugin.compositeAttributes;
        super(props);
      }

    };
  } // for each of the exposed Incidents


  if (!hasOwnProp(plugin, 'incidents')) {
    return thePlugin;
  }

  for (let i = 0; i < plugin.incidents.length; i++) {
    Object.defineProperty(thePlugin, plugin.incidents[i].name, prepareIncident(plugin, i, AttributeChannelToUse));
  }

  return thePlugin;
} // eslint-disable-next-line sonarjs/cognitive-complexity

function prepareIncident(plugin, i, AttributeChannelToUse) {
  const incidentClass = plugin.incidents[i].exportable;
  let validationMethod = null,
      validationRules = null;
  let hasValidationRules = false;

  if (hasOwnProp(plugin.incidents[i], 'attributesValidationRules')) {
    hasValidationRules = true;
    const validationRulesToUse = deepCopy(plugin.incidents[i].attributesValidationRules);

    if (hasOwnProp(plugin.incidents[i].attributesValidationRules, 'animatedAttrs')) {
      // make all initialValues optional and store it on the validationRulesToUse
      validationRulesToUse.initialValues = buildInitialValuesValidationRules(validationRulesToUse.animatedAttrs);
    }

    validationRules = validationRulesToUse;
    validationMethod = validator.compile(validationRulesToUse);
  }

  let DynamicDescriptiveIncident; // the exportable Incident can be either a Clip, a Group or an Incident
  // if it is an Incident

  if (incidentClass.prototype instanceof MonoIncident) {
    var _class3;

    DynamicDescriptiveIncident = (_class3 = class DynamicDescriptiveIncident extends DescriptiveIncident {}, _defineProperty__default["default"](_class3, "Incident", incidentClass), _defineProperty__default["default"](_class3, "plugin_npm_name", plugin.npm_name), _defineProperty__default["default"](_class3, "plugin", plugin.npm_name), _defineProperty__default["default"](_class3, "version", plugin.version || '*'), _defineProperty__default["default"](_class3, "ClassName", plugin.incidents[i].name), _defineProperty__default["default"](_class3, "Channel", AttributeChannelToUse), _defineProperty__default["default"](_class3, "audio", plugin.audio || 'off'), _class3);
  } else if (incidentClass.prototype instanceof MediaPlay) {
    var _class4;

    DynamicDescriptiveIncident = (_class4 = class DynamicDescriptiveIncident extends DescriptiveIncident {}, _defineProperty__default["default"](_class4, "Incident", incidentClass), _defineProperty__default["default"](_class4, "audio", plugin.audio || 'off'), _defineProperty__default["default"](_class4, "plugin_npm_name", '@donkeyclip/media-playback'), _defineProperty__default["default"](_class4, "plugin", plugin.npm_name), _defineProperty__default["default"](_class4, "version", plugin.version || '*'), _defineProperty__default["default"](_class4, "ClassName", plugin.incidents[i].name), _defineProperty__default["default"](_class4, "Channel", AudioPlaybackChannel), _class4);
  } else if (incidentClass.prototype instanceof HTMLDescriptiveClip) {
    var _class5;

    DynamicDescriptiveIncident = (_class5 = class DynamicDescriptiveIncident extends incidentClass {}, _defineProperty__default["default"](_class5, "audio", plugin.audio || 'on'), _defineProperty__default["default"](_class5, "originalDims", originalDimsCheck(plugin.incidents[i].originalDims).analysis), _defineProperty__default["default"](_class5, "isAnimation", true), _class5);
  } else if (incidentClass.prototype instanceof DescriptiveGroup) {
    // This Class extends a Descriptive Incident which already has the static property "channel" we don't need
    // to define it again. We only need to add the plugin's information
    DynamicDescriptiveIncident = incidentClass;
  }

  DynamicDescriptiveIncident.plugin = plugin.npm_name;
  DynamicDescriptiveIncident.version = plugin.version || '*';
  DynamicDescriptiveIncident.ClassName = plugin.incidents[i].name;
  DynamicDescriptiveIncident.attrsValidationRules = validationRules;
  DynamicDescriptiveIncident.attrsValidationMethod = validationMethod;
  return {
    enumerable: true,

    get() {
      // the getter will construct a wrapper class which on the constructor will instantiate an object of the
      // exposed class, set to it the plugin name and channel class parameters and return
      // it from the constructor
      class WrapperClass {
        // we transfer some basic information of the DescriptiveIncident to our
        // Wrapper Class as well
        constructor(attrs, props) {
          let instantiatedIncident;

          if (hasValidationRules) {
            const validationResult = validationMethod(attrs);

            if (validationResult.length > 0) {
              let errorMessage = "Error on plugin's \"".concat(plugin.npm_name, "\" \"").concat(plugin.incidents[i].name, "\" instantiation. Errors:");

              for (let j = 0; j < validationResult.length; j++) {
                errorMessage += "\n - ".concat(validationResult[j].message, ". ").concat(validationResult[j].actual, " provided");
              }

              helper.error(errorMessage);
              return {
                result: false,
                errors: validationResult
              };
            }
          }

          instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

          if (instantiatedIncident.result && !hasValidationRules) {
            helper.warning("It's always good to provide attributesValidationRules to the exported incidents. ".concat(plugin.npm_name, " doesn't provide it"));
          }

          return instantiatedIncident;
        }

      }

      _defineProperty__default["default"](WrapperClass, "targetClass", DynamicDescriptiveIncident);

      return WrapperClass;
    }

  };
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

const degrees = Math.PI / 180; // eslint-disable-next-line sonarjs/cognitive-complexity

function getMatrix2D(win, element) {
  const transform = win.getComputedStyle(element).transform;

  if (transform === '' || transform === 'none') {
    return {
      rotate: '0deg',
      rotateX: '0deg',
      rotateY: '0deg',
      scaleX: 1,
      scaleY: 1,
      scale: 1,
      skewX: '0deg',
      skewY: '0deg',
      translateX: '0px',
      translateY: '0px'
    };
  } // matrixValues holds a matrix() css function arguments list (6 in total).
  // See: https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix()
  // matrixValues is actually an array (length 6), each index of which represents the corresponding
  // matrix() argument.


  const matrixValues = transform.split('(')[1].split(')')[0].split(','); // Starting from the 2d matrix values we now want to transform the data
  // to a much easier to use property set (scale, skew, etc). To do so we apply QR decomposition
  // https://en.wikipedia.org/wiki/QR_decomposition

  function qrDecompose(matrix) {
    const angle = Math.atan2(matrix[1], matrix[0]),
          denom = Math.pow(matrix[0], 2) + Math.pow(matrix[1], 2),
          denom2 = Math.pow(matrix[2], 2) + Math.pow(matrix[3], 2),
          scaleX = Math.round(Math.sqrt(denom) * 100) / 100,
          scaleY = Math.round((matrix[0] * matrix[3] - matrix[2] * matrix[1]) / scaleX * 100 || 0) / 100,
          skewX = Math.atan2(matrix[0] * matrix[2] + matrix[1] * matrix[3], denom),
          skewY = Math.atan2(matrix[1] * matrix[3] + matrix[0] * matrix[2], denom2);
    return {
      rotate: "".concat(angle / degrees || 0, "deg"),
      // this is rotation angle in degrees
      scaleX: scaleX === scaleY ? 1 : scaleX !== undefined && scaleX !== null ? scaleX : 1,
      // scaleX factor
      scaleY: scaleX === scaleY ? 1 : scaleY !== undefined && scaleY !== null ? scaleY : 1,
      // scaleY factor
      scale: scaleX === scaleY && scaleX !== null ? scaleY : 1,
      skewX: "".concat(denom === 1 ? skewX / degrees : 0, "deg"),
      // skewX angle degrees
      skewY: "".concat(denom2 === 1 ? skewY / degrees : 0, "deg"),
      // skewY angle degrees
      translateX: "".concat(matrix[4].trim(), "px"),
      // translation point  x
      translateY: "".concat(matrix[5].trim(), "px") // translation point  y

    };
  }

  return qrDecompose(matrixValues);
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const transform = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY'];
var compositeAttributes = {
  transform
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class ExtendableCSSEffect extends MonoIncident {
  constructor() {
    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let dna = arguments.length > 2 ? arguments[2] : undefined;
    super(attrs, props, dna);
    this.compoAttributes = compositeAttributes;
  }

  getScratchValue() {
    let toSearch = this.attributeKey;

    if (toSearch === 'cssOffset') {
      toSearch = 'offset';
    }

    if (toSearch !== 'transform') {
      const val = this.context.window.getComputedStyle(this.element)[toSearch];
      return val !== undefined && val !== '' ? val : 0;
    }

    const obj = {};
    const transform = this.compoAttributes[toSearch];
    const currentTransform = getMatrix2D(this.context.window, this.element);
    const computedStyle = this.context.window.getComputedStyle(this.element);
    let currentTransformProperty;

    for (let i = 0; i < transform.length; i++) {
      currentTransformProperty = transform[i];
      obj[currentTransformProperty] = hasOwnProp(currentTransform, currentTransformProperty) ? currentTransform[currentTransformProperty] : computedStyle[currentTransformProperty];
    }

    return obj;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class CSSEffect$1 extends ExtendableCSSEffect {
  onGetContext() {
    var _this$context, _this$context$CSSAnim, _this$context$CSSAnim2, _this$element$dataset, _this$context$CSSAnim3, _this$context$CSSAnim4, _this$attributeKey, _this$context$CSSAnim5;

    (_this$context$CSSAnim = (_this$context = this.context).CSSAnimationLayer) !== null && _this$context$CSSAnim !== void 0 ? _this$context$CSSAnim : _this$context.CSSAnimationLayer = {};
    (_this$context$CSSAnim3 = (_this$context$CSSAnim2 = this.context.CSSAnimationLayer)[_this$element$dataset = this.element.dataset.motorcortex2Id]) !== null && _this$context$CSSAnim3 !== void 0 ? _this$context$CSSAnim3 : _this$context$CSSAnim2[_this$element$dataset] = {};
    (_this$context$CSSAnim5 = (_this$context$CSSAnim4 = this.context.CSSAnimationLayer[this.element.dataset.motorcortex2Id])[_this$attributeKey = this.attributeKey]) !== null && _this$context$CSSAnim5 !== void 0 ? _this$context$CSSAnim5 : _this$context$CSSAnim4[_this$attributeKey] = {
      id: null,
      animation: {
        cancel: doNothing
      }
    };
    this.CSSAnimationLayerElement = this.context.CSSAnimationLayer[this.element.dataset.motorcortex2Id][this.attributeKey];

    this._init();
  }

  _init() {
    if (!hasOwnProp(this.compoAttributes, this.attributeKey)) {
      this.options = {
        [this.attributeKey]: [this.initialValue, this.targetValue]
      };
      return;
    }

    this.options = {
      transform: ['', '']
    };

    for (const attr of this.compoAttributes[this.attributeKey]) {
      if (!hasOwnProp(this.targetValue, attr)) {
        continue;
      }

      this.options.transform[0] += "".concat([attr], "(").concat(this.initialValue[attr] || 0, ")");
      this.options.transform[1] += "".concat([attr], "(").concat(this.targetValue[attr], ")");
    }
  }

  createAnimation() {
    /* create the new animation */
    this.animation = new Animation(new KeyframeEffect(this.element, [{
      [this.attributeKey]: this.options[this.attributeKey][0]
    }, {
      [this.attributeKey]: this.options[this.attributeKey][1]
    }], {
      duration: this.props.duration,
      fill: 'forwards',
      easing: 'linear'
    }));
    /* add the new animations info to the context */

    this.CSSAnimationLayerElement.id = this.id;
    this.CSSAnimationLayerElement.animation = this.animation;
  }

  onProgress(ms) {
    if (this.CSSAnimationLayerElement.id !== this.id) {
      // TODO investigate the effectiveness or not of this command on resources management
      // this.CSSAnimationLayerElement.animation.cancel();
      this.createAnimation();
    }

    this.animation.currentTime = ms;
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const nu = ['cm', 'mm', 'in', 'px', 'pt', 'pc', 'em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', '%'];
const ru = ['deg', 'rad', 'grad', 'turn'];
const _MEASUREMENT = 'measurement';
const _COLOR = 'color';
const animatedAttrs = {
  type: 'object',
  // strict: true,
  props: {
    background: {
      optional: true,
      type: _COLOR
    },
    backgroundColor: {
      optional: true,
      type: _COLOR
    },
    backgroundPosition: {
      optional: true,
      type: 'string'
    },
    backgroundSize: {
      optional: true,
      type: 'string'
    },
    border: {
      optional: true,
      type: 'string'
    },
    borderBottom: {
      optional: true,
      type: 'string'
    },
    borderBottomColor: {
      optional: true,
      type: _COLOR
    },
    borderBottomLeftRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderBottomRightRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderBottomWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderColor: {
      optional: true,
      type: _COLOR
    },
    borderEndEndRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderEndStartRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderImageOutset: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    borderImageSlice: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    borderImageWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    borderLeft: {
      optional: true,
      type: 'string'
    },
    borderLeftColor: {
      optional: true,
      type: _COLOR
    },
    borderLeftWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderRight: {
      optional: true,
      type: 'string'
    },
    borderRightColor: {
      optional: true,
      type: _COLOR
    },
    borderRightWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderStartEndRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderStartStartRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderTop: {
      optional: true,
      type: 'string'
    },
    borderTopColor: {
      optional: true,
      type: _COLOR
    },
    borderTopLeftRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderTopRightRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderTopWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    borderWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    bottom: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    boxShadow: {
      optional: true,
      type: 'string'
    },
    caretColor: {
      optional: true,
      type: _COLOR
    },
    color: {
      optional: true,
      type: _COLOR
    },
    columnCount: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    columnGap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    columnRule: {
      optional: true,
      type: 'string'
    },
    columnRuleColor: {
      optional: true,
      type: _COLOR
    },
    columnRuleWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    columns: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    columnWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    flex: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    flexBasis: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    flexGrow: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    flexShrink: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    font: {
      optional: true,
      type: 'string'
    },
    fontSize: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    fontSizeAdjust: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    fontStretch: {
      optional: true,
      type: _MEASUREMENT,
      units: ['%']
    },
    fontWeight: {
      optional: true,
      type: 'string'
    },
    gap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    gridColumnGap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    gridGap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    gridRowGap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    gridTemplateColumns: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    gridTemplateRows: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    height: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    inset: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    insetBlock: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    insetBlockEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    insetBlockStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    insetInline: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    insetInlineEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    insetInlineStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    left: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    letterSpacing: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    lineClamp: {
      optional: true,
      type: 'number',
      min: 0,
      integer: true
    },
    lineHeight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    margin: {
      optional: true,
      type: 'string'
    },
    marginBottom: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    marginLeft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    marginRight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    marginTop: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    maskBorder: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    maskPosition: {
      optional: true,
      type: 'string'
    },
    maskSize: {
      optional: true,
      type: 'string'
    },
    maxHeight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    maxWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu,
      min: 0
    },
    objectPosition: {
      optional: true,
      type: 'string'
    },
    cssOffset: {
      optional: true,
      type: 'any'
    },
    offsetAnchor: {
      optional: true,
      type: 'string'
    },
    offsetDistance: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    offsetPath: {
      optional: true,
      type: 'string'
    },
    offsetPosition: {
      optional: true,
      type: 'string'
    },
    offsetRotate: {
      optional: true,
      type: _MEASUREMENT,
      units: ru
    },
    opacity: {
      optional: true,
      type: 'number',
      min: 0,
      max: 1
    },
    order: {
      optional: true,
      type: 'number',
      integer: true
    },
    outline: {
      optional: true,
      type: 'string'
    },
    outlineColor: {
      optional: true,
      type: _COLOR
    },
    outlineOffset: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineRadius: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineRadiusBottomleft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineRadiusBottomright: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineRadiusTopleft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineRadiusTopright: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    outlineWidth: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    padding: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    paddingBottom: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    paddingLeft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    paddingRight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    paddingTop: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    perspective: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    perspectiveOrigin: {
      optional: true,
      type: 'string'
    },
    r: {
      optional: true,
      type: 'string'
    },
    right: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    rotate: {
      optional: true,
      type: _MEASUREMENT,
      units: ru
    },
    rowGap: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scale: {
      optional: true,
      type: 'number',
      min: 0
    },
    scrollbarColor: {
      optional: true,
      type: _COLOR
    },
    scrollMargin: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginBlock: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginBlockEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginBlockStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginBottom: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginInline: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginInlineEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginInlineStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginLeft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginRight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollMarginTop: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPadding: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingBlock: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingBlockEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingBlockStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingBottom: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingInline: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingInlineEnd: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingInlineStart: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingLeft: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingRight: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollPaddingTop: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    scrollSnapCoordinate: {
      optional: true,
      type: 'string'
    },
    scrollSnapDestination: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    shapeImageThreshold: {
      optional: true,
      type: 'string'
    },
    shapeMargin: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    shapeOutside: {
      optional: true,
      type: 'string'
    },
    tabSize: {
      optional: true,
      type: 'string'
    },
    textDecoration: {
      optional: true,
      type: 'string'
    },
    textDecorationColor: {
      optional: true,
      type: _COLOR
    },
    textDecorationThickness: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    textEmphasis: {
      optional: true,
      type: 'string'
    },
    textEmphasisColor: {
      optional: true,
      type: _COLOR
    },
    textFillColor: {
      optional: true,
      type: _COLOR
    },
    textIndent: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    textShadow: {
      optional: true,
      type: 'string'
    },
    textStroke: {
      optional: true,
      type: 'string'
    },
    textStrokeColor: {
      optional: true,
      type: _COLOR
    },
    textUnderlineOffset: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    top: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    transform: {
      optional: true,
      type: 'object',
      props: {
        translateX: {
          type: _MEASUREMENT,
          units: nu,
          optional: true
        },
        translateY: {
          type: _MEASUREMENT,
          units: nu,
          optional: true
        },
        translateZ: {
          type: _MEASUREMENT,
          units: nu,
          optional: true
        },
        rotate: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        rotateX: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        rotateY: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        rotateZ: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        scale: {
          type: 'number',
          min: 0,
          optional: true
        },
        scaleX: {
          type: 'number',
          min: 0,
          optional: true
        },
        scaleY: {
          type: 'number',
          min: 0,
          optional: true
        },
        scaleZ: {
          type: 'number',
          min: 0,
          optional: true
        },
        skewX: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        skewY: {
          type: _MEASUREMENT,
          units: ru,
          optional: true
        },
        perspective: {
          type: _MEASUREMENT,
          units: nu,
          optional: true
        }
      }
    },
    transformOrigin: {
      optional: true,
      type: 'string'
    },
    verticalAlign: {
      optional: true,
      type: 'string'
    },
    visibility: {
      optional: true,
      type: 'string'
    },
    width: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    wordSpacing: {
      optional: true,
      type: _MEASUREMENT,
      units: nu
    },
    zIndex: {
      optional: true,
      type: 'number',
      integer: true
    },
    zoom: {
      optional: true,
      type: _MEASUREMENT,
      units: ['%'],
      min: 0
    }
  },
  transformOrigin: {
    type: 'string'
  },
  verticalAlign: {
    type: 'string'
  },
  visibility: {
    type: 'string'
  },
  width: {
    type: _MEASUREMENT,
    units: nu
  },
  wordSpacing: {
    type: _MEASUREMENT,
    units: nu
  },
  zIndex: {
    type: 'number',
    integer: true
  },
  zoom: {
    type: _MEASUREMENT,
    units: ['%'],
    min: 0
  }
};

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var InternalCSSPlugin = {
  npm_name: '@donkeyclip/css-layer',
  incidents: [{
    exportable: CSSEffect$1,
    name: 'CSSEffect',
    attributesValidationRules: {
      animatedAttrs
    }
  }],
  compositeAttributes
};

const CSSLayer = loadPlugin(InternalCSSPlugin); // AlternativeCore is a variable that aims to hold any alternative core preference. Initially null

let AlternativeCore = null; // a method that accepts an Incident to act as the alternative CSS core implementation

function setCore(Effect) {
  AlternativeCore = Effect;
}
class CSSEffect {
  constructor(attrs, props) {
    const res = new CSSLayer.CSSEffect(attrs, props);

    if (res.result === false) {
      return res;
    }

    if (AlternativeCore !== null) {
      // the static param "Incident" of the DescriptiveIncident instance is the one that will be
      // used on the real Incident implementation. Changing this changes the core of our CSS Engine
      res.constructor.Incident = AlternativeCore;
    }

    return res;
  }

}

_defineProperty__default["default"](CSSEffect, "targetClass", CSSLayer.CSSEffect.targetClass);

const comboAttrsBasicRule = {
  incidents: {
    type: 'array',
    items: {
      type: 'object',
      props: {
        position: {
          type: 'amount',
          integer: true,
          min: 0,
          optional: false
        },
        attrs: {
          type: 'object',
          optional: false
        },
        props: {
          type: 'object',
          optional: false
        },
        incidentClass: {
          type: 'any',
          optional: false
        }
      }
    }
  }
};
const comboAttrsBasicRuleMethod = validator.compile(comboAttrsBasicRule);
const incidentChangeError = "Combos don't allow external addition or manipulation to their Incidents";

function handleInvalidIncidentChange() {
  helper.error(incidentChangeError);
  return {
    result: false,
    errors: [incidentChangeError]
  };
}

class DescriptiveCombo extends DescriptiveGroup {
  constructor(attrs, props) {
    super(attrs, props);

    _defineProperty__default["default"](this, "addIncident", handleInvalidIncidentChange);

    _defineProperty__default["default"](this, "moveIncident", handleInvalidIncidentChange);

    _defineProperty__default["default"](this, "removeIncident", handleInvalidIncidentChange);

    _defineProperty__default["default"](this, "handleCheckAddition", alwaysReturnFalse);

    _defineProperty__default["default"](this, "handleCheckMove", alwaysReturnFalse);

    _defineProperty__default["default"](this, "handleCheckDeletion", alwaysReturnFalse);

    _defineProperty__default["default"](this, "handleCheckResize", alwaysReturnFalse);

    if (this.incidents !== null) {
      // it happens on Combos exposed by plugins (see getter)
      this.attrs.incidents = this.incidents; // we overwrite our incidents in case of a plugin Combo
      // we re-calculate attributes and properties staggers as we've changed the
      // original attrs

      this.attributesStaggers = [];
      this.propsStaggers = [];
      this.setupDynamicValues();
    }

    const propsValidation = validateProps(this.props, comboPropsRule, this.constructor);

    if (!propsValidation.result) {
      return propsValidation;
    } // attributes validation


    const valRes = comboAttrsBasicRuleMethod(this.attrs);

    if (valRes.length > 0) {
      helper.error('The provided attributes for Combo Incident are invalid');
      return {
        result: false,
        errors: valRes
      };
    }

    let errors = [];

    for (let i = 0; i < this.attrs.length; i++) {
      const item = this.attrs[i];

      if (item.incidentClass.attrsValidationRules !== null) {
        const attrValRes = item.incidentClass.attrsValidationMethod(item.attrs);

        if (attrValRes.length > 0) {
          errors = errors.concat(attrValRes.errors);
        }
      }

      const propValRes = validateProps(item.props, item.incidentClass.propsValidationRules, item.incidentClass);

      if (!propValRes.result) {
        errors = errors.concat(propValRes.errors);
      }
    }

    if (errors.length > 0) {
      return {
        result: false,
        errors
      };
    }
    /* in case there are propsStaggers the duration of the Incident can only be
    calculated when the Incident gets applied to real elements. Pre-calculation is
    difficult due to the combination of duration, delay, hiatus and
    repeats props, which are all stagger-able and stagger can have any supported easing.
    The value of this property is only handled by ElementsSplitter, which is the
    representation of the Descriptive Incident in the real tree world.
    */


    this.dynamicDurationValue = null;
  } // to be used on incidentFromDefinition


  get incidents() {
    return null;
  }

  get duration() {
    if (this.dynamicDurationValue !== null) {
      return this.dynamicDurationValue;
    } else {
      return 'dynamic';
    }
  }

  set duration(ms) {
    super.duration = ms;
  }
  /**************** OVERWRITE DESCRIPTIVE GROUP'S INCIDENT MANAGEMENT METHODS ********
   * A DescriptiveCombo is a Group itself that hosts other Incidents. Combos though
   * define solid and specific behaviors, "hardcoded" right from
   * Combo's creation. For this, no direct handling of its Incidents is allowed from the
   * outside (and neither from the inside after the first build).
   * Thus we overwrite the Incidents management layer so it prevents it
   * ********************************************************************************/


  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Incident at any time
   */
  exportDefinition() {
    function stringifyIncidents(incidents) {
      const exportableIncidents = [];

      for (let i = 0; i < incidents.length; i++) {
        const incident = incidents[i];
        let incidentAttrs = incident.attrs;

        if (incident.incidentClass.ClassName === 'Combo') {
          incidentAttrs = { ...incidentAttrs,
            incidents: stringifyIncidents(incidentAttrs.incidents)
          };
        }

        exportableIncidents.push({
          // in order to cover the loaded plugins' Incidents case (case in which the Class
          // is the Wrapper and not directly the exposed Class) we add the second (targetClass) option
          ClassName: incident.incidentClass.ClassName || incident.incidentClass.targetClass.ClassName,
          plugin_npm_name: incident.incidentClass.plugin_npm_name || incident.incidentClass.targetClass.plugin_npm_name,
          version: incident.incidentClass.version || incident.incidentClass.targetClass.version,
          attrs: incidentAttrs,
          props: deepCopy(incident.props),
          position: incident.position
        });
      }

      return exportableIncidents;
    } // if the incidents have been overwritten because the getter returns incidents
    // we just remove them from our export
    // as they play absolutely no role, they get ignored by the system


    let attrsToUse = { ...this.attrs,
      incidents: stringifyIncidents(this.attrs.incidents)
    };
    return {
      ClassName: this.constructor.ClassName,
      version: this.constructor.version,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: attrsToUse,
      props: deepCopy(this.props),
      incidents: {},
      duration: this.duration
    };
  }
  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */


  exportLiveDefinition() {
    let includeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    // if the incidents have been overwriten because the getter returns incidents
    // we just remove them from our export
    // as they play absolutely no role, they get ignored by the system
    let attrsToUse = this.attrs;

    if (this.incidents !== null) {
      attrsToUse = { ...this.attrs,
        incidents: undefined
      };
    }

    let propsToReturn = deepCopy(this.props);

    if (!includeId) {
      delete propsToReturn.id;
    }

    return {
      Class: this.constructor,
      attrs: attrsToUse,
      props: propsToReturn,
      incidents: {}
    };
  }

}

_defineProperty__default["default"](DescriptiveCombo, "isCombo", true);

_defineProperty__default["default"](DescriptiveCombo, "ClassName", 'Combo');

_defineProperty__default["default"](DescriptiveCombo, "attrsValidationRules", null);

_defineProperty__default["default"](DescriptiveCombo, "propsValidationRules", comboPropsRule);

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

class Journey {
  constructor(props) {
    if (!hasOwnProp(props, 'incident')) {
      helper.error('Journey constructor expects an Incident on its properties on the key "incident"');
      return false;
    }

    this.memory = props.capsuleMemory;
    this.stations = [];
    this.incident = props.incident;
    this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;
    this.startState = "".concat(this.incident.runTimeInfo.state);
    this.incident.stop();
  }

  station(millisecond) {

    if (this.stations.length > 0) {
      this.stations[this.stations.length - 1];
    }

    this.stations.push(millisecond);
    this.incident.playableProgress(millisecond / this.incident.duration, millisecond);
  }

  destination() {
    let millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (millisecond != null) {
      this.station(millisecond);
    } else {
      millisecond = this.stations[this.stations.length - 1];
    }

    this.incident.playableProgress(millisecond / this.incident.duration, millisecond); // if the clip was playing start it again

    if (this.startState === 'playing' || this.startState === 'blocked' && this.incident.statusBeforeBlock === 'playing') {
      this.incident.play();
    } else if (millisecond >= this.incident.duration) {
      this.incident.complete();
    } else {
      this.incident.arm();
    }

    this.memory.push(this.exportLog);
  }

  exportLog() {
    return {
      startMillisecond: this.startMillisecond,
      startState: this.startState,
      stations: this.stations
    };
  }

}

class TimeCapsule {
  constructor() {
    this.memory = [];
  }

  startJourney(incident) {
    if (!incident) {
      helper.error('startJourney expects an Incident as an argument');
      return false;
    }

    return new Journey({
      incident,
      capsuleMemory: this.memory
    });
  }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const utils = {
  easings: easing,
  clipFromDefinition: constructIncident
};
const {
  AudioEffect,
  AudioPlayback,
  Clip: CoreAudioClip
} = loadPlugin(audioPlugin);

exports.AudioClip = DescriptiveAudioClip;
exports.AudioEffect = AudioEffect;
exports.AudioPlayback = AudioPlayback;
exports.BrowserClip = BrowserClip;
exports.CSSEffect = CSSEffect;
exports.Combo = DescriptiveCombo;
exports.CoreAudioClip = CoreAudioClip;
exports.Effect = MonoIncident;
exports.ExtendableCSSEffect = ExtendableCSSEffect;
exports.Group = DescriptiveGroup;
exports.HTMLClip = HTMLDescriptiveClip;
exports.MediaPlayback = MediaPlay;
exports.TimeCapsule = TimeCapsule;
exports.loadPlugin = loadPlugin;
exports.setCSSCore = setCore;
exports.utils = utils;
exports.version = version;
