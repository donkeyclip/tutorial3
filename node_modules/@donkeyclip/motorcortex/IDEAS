The Incident objects will support the following event handling methods:
- onInitialise normally here we just set our state and params. It could be renamed to "initialState" like React does it
- onGetContext (on replacement of play() and resume() handling as done right now on Animation.js of Velocity.
                onPlay and onResume built-in methods should always and by default call the onGetContext methods
                which in turn will check the flag and either run or skip. Question about the name (?)
- onProgress
- getScratchValue  (that's a method that takes 2 arguments: the element and one of the animatedAttrs' attribute and returns
                    its value as computed by the plugin itself. It's the scratch value of an element's attribute as calculated
                    directly by the dom)
- onDurationChange (alias of systolDiastole) - normally here we set our duration and just run the onGetContext method optionally
                    The user will be able to pick whether their class want to re-initialise or not on duration change.

get duration() // if we demand the duration on the init params of all Inicdents there is no need to have that
set duration() // and we need to store our duration on a specific key of our object

- onComplete
- onPlay
- onWait
- onResume
- etc


Channel
- setInitialState (alias of onInitialise)
- the user will be able to pick whether they:
    - allow overlapping incidents on the same slector / element
    - define per attribute non-overlapping rules, so the Channel keeps element-attribute lanes
and also they will be able to run their own (extra) code on successful addiont/edit and delete.
This way the Velocity plugin will only have to set the initial values of the newly entered Animations
and that's because it strongly depends on the lanes. It's good to provide convenient methods built in
such as:
- getPeviousLaneItem
- getNextLaneItem
for the newlly entered, edited or deleted Incidents
goTo method will be absorbed as depending on the lanes structure it will just slip to lanes on goTo.


create a preloader plugin (configurable). The preloader plugin will take care of preloading assets (mainly audio and images)
If the user wants to split the full clip into smaller parts so the preloader can preload things the only thing to do
is to create clips (either iframe, iframe but no css isolation or nude) and the preloader will know the segments that
load what so it can preload while playing and indicate load on the seek bar.

create a scroll / parallax plugin that will also expose a vertical bar on the right emulating the browser bar but with
touches (such as chapters). Make it feel like chrome has been hacked rather that suggesting a totally new idea.

We need to create a test suite and incorporate it on donkey clip for plugin creators. Needs investigation - v.2


Incidents initialisation:
attrs:{
    animatedAttrs: {
        left: "500px",
        ...
    },
    attrs:{
        other: 53,
        attributes: 3453
    }
},
props:{
    selector: ".the-selector",
    id: "the-id"
}

next job: getInitialValue / should it exist any more? Should be chained with the new AttributeChannel logic. / Logical analysis

After adding incident.onGetContext(); on Attribute channel line 108 maybe the onGetContext on Group is not necessary any more?


NEXT STEPS
1. Plain Clip  -done
2. Never ending Clips
A never ending / open clip will have an initial duration, the normal duration of it as it's calculated by the Incidents it has.
A never ending / open clip can't be paused / resumed / have its speed changed or been seeked. The clip should first close / end and then it becomes a normal clip
    to which the user can apply any of the mentioned functions.
    While running and once it starts for the first time the clip runs infinitely until it gets the "end" command.
    While running, the open clip doesn't accept edit or deletion commands, only addition commands of incidents belonging to the future
3. Fix logging (make it parametric)  -done
4. Incidents illustration page
5. React plugin
6. Fractions (Incidents that stop on specific point of their execution)
7. Media Element audio plugin
8. Youtube plugin
9. Video effects plugin (https://github.com/shamadee/web-dsp , https://github.com/shamadee/web-dsp-demo)
10. *** Disallow incidents with the same id to enter on the plain Channel. It's an SOS as now it allows it and it produces buggy clips without warnings
11. Incidents of type Group, exported by plugins (except Clips) should never expose their content incidents on getState, unless the user explicitly states them to

// PERFORMANCE
12. start edits / ready  DONE
see getDurationAfterIncidentAdded on Group and ready() on SCGroup   TODO
13. caching of proxy on LanesHandler (not important)   NOT RELEVANT ANH MORE
14. JSON.parse(JSON.stringify()) on createTestLanesSanbox causes huge delay *** must find a workaround *** DONE
15. getIncidentById causes huge delay DONE
16. On DOMContextHandler caching of elements of specific mcid would result to huge economy DONE
*** also the getElements of context handler can be cached but there should be a way to clear cache on the contect *** TODO
17. Do not slipToLane on checkAddition on AttributeChannel if Clip has not ran yet  TODO
18. It's completely reasonable to make getIncidentById more performant for the case the user puts many incidents themselves  TODO
19. Chain donkeyclip with jw player


ΆΞΟΝΕΣ ΒΕΛΤΙΩΣΗΣ ΑΠΟΔΟΣΗ����:
- getIncidentById (check id on addition)
- sanboxing of lanes handler
- massive editing

CLIP AS Incident
- implement IncidentFromDefinition
- change _createElementIncident of DOMAwareIncident so it creates new Incidents,
when new elements appear, out of the export / create process when its incidents are
of type ClipAsIncident and via the use of its virtual clip definition
- on _editChildIncidentAttributes of Group we should change the function so it
recreates the Incident (if the edit fails) out of its definition via IncidentFromDefinition
- even if the case of a passing attr change (checked just for the Incident itself),
in the case the Incident is a Group (or Clip) we need to
try to recreate all of its non-passive Incidents and only if they all return result:true
finally we keep the new Incident. "all-or-nothing" / "keep-passing" could be applied
here in a later phase.
- This way we will be ready to implement the RenderedClipAsIncident which will:
-- create a Clip on a Fragment and use it as the test clip for all additions deletions etc
--

ClipAsIncident:
we will implement an Incident that extends Group.
This incident will receive selector so it's on the DOMAwareIncident case.
onGetContext of this Incident we will create our Clip on this.element
This class will only implement onGetContext and all other methods (and property accesses)
will be proxied to the initialised Clip of it
As a constructor param it'll receive the Clip class along with attrs and props
DOMAwareIncident will implement methods "addIncdent", "editIncident" etc in the following way:
a) it'll keep a virtual Clip on a fragment (virtual Clip)
b) all additions / deletions / edits will first be applied to the virtual clip
    if they pass they will be applied to all of its Incidents and it will return its
        virtual Clip's result
    if they do not pass it will just return its virtual Clip's result

tests to be added:
- DOMAwareIncident and DOM changes (add, remove)
- DOMAwareIncident and

Plain Clip should also be addable by selector (as incident) on the Clip.
For this we need to add one more DOMAwareIncident type, the plain (open) Clip
DOMAwarePlainClipIncident
it accepts commands only when there are clips rendered on the DOM.

Completing the Plain Clip DOMAwareIncident we will proceed with the parametrisation
of the Incidents' execution depending on the index of each element. For example
apply this incident with delay 150ms per element and complete all incidents together,
or keep the fixed duration. Another example of parametrisation is to pass attribute
values that get their value from each element's specific attribute. E.g.:
{
    animatedAttrs: {
        top: `${element.attr['data-percentage']}%}
    }
}

next steps:
a) repeat on Groups
b) Groups (and Clips) syntax on constuctor:

const templ = new Anime.Anime({
    animatedAttrs: [
        width: "200px"
    }
}, {
    duration: 3000,
    easing: "linear",
    hiatus: 300,
    delay: 100,
    repeats: 2,
    // selector: '.selector',
    // template: true
));

const group = new TemplateGroup();
group.addIncident(a, 1000);
group.addIncident(b, 2000);

myClip.addIncident(group.createIncident(), 0);
myClip.addIncident(group.createIncident(), 1000);
a.resize(1000);

const myInc = templ.newIncident(".selector", {animatedAttrs: {width: "100px"}}, {...props});
myClip.addIncident(myInc);

const inc = new Anime.Anime(...);
// inc.id
const inc1000 = clip.addIncident(inc, 1000).incident;
/*
{
    result: true,
    incident: Incident
}
*/
const inc3000 = clip.addIncident(inc, 3000).incident;
clip.removeIncident(Incident.id);
inc.resize(1000);
new Group({
    id: 'group',
    incidents: [
        {
            class: IncidentClass,
            attrs:{
                animatedAttrs: {
                    width: '100%'
                }
            },
            props: {
                duration: 1500,
                selector: '.whatever'
            },
            position: 1000
        },
        {
            class: IncidentClass,
            attrs:{
                animatedAttrs: {
                    width: '0%'
                }
            },
            props: {
                duration: 1500,
                selector: '.whatever'
            }
        }
    ],
    repeat: {
        times: 5
    },
    pattern: {
        lastExecuteDurationFactor: 0.6,
        easing: 'elastic'
    }
});

execution sequence parametrisation:
1. Will accept the following patterns:
a) 'same-finish' : the incidents will all finish together
b) 'same-start' : the incidents will all start together
c) 'same-duration' : the incident's duration will all be the same

the degrees of freedom on the parametrisation are the following:
a) start
b) finish
c) duration

on each freedom degree we can pass a formula. A formula can be:
- either a fix number (a multiplier of the duration)
- a function (that takes two arguments: the index and the duration)
- a bezier curve

Not allowed combinations:
- 'same-finish' with finish formula
- 'same-start' with start formula
- 'same-duration' with duration formula
- 'same-start' with 'same-finish' and a duration formula

in the future formulas should be applicable on repeat params
also a set of predefined formulas and bezier methods should be provided

next step is the dynamic attribute (and duration) values

The full formula / dynamic part should be object oriented so the developers will be able to create formula plugins


--- NEW THINGS ---
- make the Incident compatible with the new things. One attribute (get set), one initial value, one element etc
so everything is much easier for the developers when they write

- DescriptiveCompo (as per definition) -- check
- exportDefinition(live), compatible with incidentFromIngredients
- editAttributes should be implemented via: delete->add-if necessary->restore
- tests

Different types of Clips combined
There might be the case that we have Clips of different types are generated by plugins.
Examples are:
-

Audio next steps:
- pause v
- volume
- loading ---- blocking waitings
- effects

Errors on addIncident could include a url to donkeyclip that would reproduce the current state
of the Clip and show the conflicting Incidents
Helper log should be refactored
OpenClip: takes host (only, can't be CASI).
VideoClip: can be implemented as plugin
Generic Context Handler implemtation (id, classes, mcid)
Case study: create an animated Pureprofile survey
turning all input components to React MC clips and by adding them dynamically on the survey clip and playing the clip

** We need to support audioSources as get audioSources on our ExtendableClip, in the exact same way we do with html & css
** We need to prevent adding root Clips to other Groups

1. Support initialValues ν
2. Support keyframes
3. Support preloaders (?)


Support of staggers on plugins without validations


Other ideas:
IncidentTemplate -> gets initialised as normally, only without selector
 -> provides the method "create" which takes as parameter a selector and produces an
    Incident
 -> Could be a good idea to be open for changes on "create" on both attrs or props

const combo = new MC.Combo({
    incidents:
    [
        {
            incidentClass: Anime,
            attrs: {
                animatedAttrs: {
                    height: '100%'
                }
            },
            props: {
                duration: 500,
                selector: '.black-bar'
            },
            position: 0
        },
        {
            incidentClass: Anime,
            attrs: {
                animatedAttrs: {
                    height: '@dataAttr(value)'
                }
            },
            props: {
                duration: 500,
                selctor: '.yellow-bar'
            },
            position: 500
        }
    ]},
    {
        selector: '.bar-container',
        delay: '@stagger(0, 1000)'
    }
);

- Turn "containerParams" of Clips to "size"
- ComboIncident duration
- ComboIncident export definition
- analyser to support ComboIncidents
- ComboIncidents as exportable from plugins (how to hardcode them and import implementation)


NEXT STEPS (TMP)
- test addition of Combos with and without conflicts
- test deletion of Combos
- test editAttrs of Combos (with and without conflicts)
- test editprops of combos (with and without conflicts)
- implement duration change on DescriptiveCombo using code from DI.setNewDuration
- test duration change and value on DI and real element levels before and after resizing
        but by affecting both the props of DCb and the position and props.duration
        of its incidents

- implement and test sortBy by indexes indexing (before and after), so it serves the
    needs of the problematic ComboAttrsCascading

