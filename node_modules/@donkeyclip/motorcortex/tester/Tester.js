/* eslint-disable no-prototype-builtins */
function compareObjects(obj1, obj2) {
  for (const key in obj1) {
    if (obj1[key] !== obj2[key]) {
      return false;
    }
  }
  return true;
}

class Tester {
  /**
   * @param {object} expected: the expected structure / format of the descriptive
   *  tree. In this form:
   * {
   *      id: <string>
   *      children: {
   *          childrenId: {
   *              id: <string>
   *              position: <int>
   *              children: ...
   *          }, ...
   *      }
   * }
   *
   * */
  testTree(expected, actual) {
    let errors = [];
    if (expected.id !== actual.id) {
      errors.push({
        type: 'invalid id',
        expected: expected.id,
        actual: actual.id,
        expectedObject: expected,
        actualObject: actual,
      });
    }

    if (
      expected.hasOwnProperty('duration') &&
      expected.duration !== actual.duration
    ) {
      errors.push({
        type: 'different duration',
        expected: expected.duration,
        actual: actual.duration,
        expectedObject: expected,
        actualObject: actual,
      });
    }

    // check the number of incidents
    if (expected.hasOwnProperty('children')) {
      if (
        Object.keys(expected.children).length !==
        Object.keys(actual.children).length
      ) {
        errors.push({
          type: 'TREE: different number of children',
          expected: Object.keys(expected.children).length,
          actual: Object.keys(actual.children).length,
          expectedObject: expected,
          actualObject: actual,
        });
      }

      for (const key in expected.children) {
        if (!actual.children.hasOwnProperty(key)) {
          errors.push({
            type: 'TREE: missing child key from children of actual',
            expected: key,
            actual: 'not present',
            expectedObject: expected,
            actualObject: actual,
          });
        } else {
          if (
            expected.children[key].position !== actual.children[key].position
          ) {
            errors.push({
              type: 'TREE: wrong position of child',
              expected: expected.children[key].position,
              actual: actual.children[key].position,
              expectedObject: expected,
              actualObject: actual,
            });
          }
          errors = errors.concat(
            this.testTree(expected.children[key], actual.children[key].leaf),
          );
        }
      }
    }
    return errors;
  }

  /**
   * @param {object} expected: The expected lanes in the following form:
   * {
   *      <laneid>: [
   *          {
   *              id: <string> ~ the incident id
   *              millisecond: <int>
   *              initialValue: <any>
   *          }
   *      ]
   * }
   *
   * @param {object} incidentsById: the incidentsById object of the LanesHanlder
   *  to be used for fetching the initial attributes of each Incident
   * */
  testLanes(expected, actual, incidentsById) {
    // actual = actual.realArray;
    const errors = [];
    if (Object.keys(expected).length !== Object.keys(actual).length) {
      errors.push({
        type: 'LANES: wrong lanes number',
        expected: Object.keys(expected).length,
        actual: Object.keys(actual).length,
        expectedObject: expected,
        actualObject: actual,
      });
    }

    for (const laneKey in expected) {
      if (!actual.hasOwnProperty(laneKey)) {
        errors.push({
          type: 'LANES: missing laneKey',
          expected: laneKey,
          actual: 'not present',
          expectedObject: expected,
          actualObject: actual,
        });
      } else if (expected[laneKey].length !== actual[laneKey].length) {
        errors.push({
          type: `LANES: wrong lanes items number on lane ${laneKey}`,
          expected: expected[laneKey].length,
          actual: actual[laneKey].length,
          expectedObject: expected[laneKey],
          actualObject: actual[laneKey],
        });
      } else {
        for (let i = 0; i < expected[laneKey].length; i++) {
          const expectedLaneItem = expected[laneKey][i];
          const actualLaneItem = actual[laneKey][i];

          let incidentPresent = true;
          if (!incidentsById.hasOwnProperty(expectedLaneItem.id)) {
            errors.push({
              type: `LANES: missing Incident on incidentsById map`,
              expected: expectedLaneItem.id,
              actual: 'not present',
              actualObject: incidentsById,
            });
            incidentPresent = false;
          }

          if (expectedLaneItem.millisecond !== actualLaneItem.millisecond) {
            errors.push({
              type: `LANES: millisecond missmatch on lane item`,
              expected: expectedLaneItem.millisecond,
              actual: actualLaneItem.millisecond,
              expectedObject: expectedLaneItem,
              actualObject: actualLaneItem,
            });
          }
          if (expectedLaneItem.id !== actualLaneItem.id) {
            errors.push({
              type: `LANES: id missmatch on lane item`,
              expected: expectedLaneItem.id,
              actual: actualLaneItem.id,
              expectedObject: expectedLaneItem,
              actualObject: actualLaneItem,
            });
          }
          if (incidentPresent) {
            const incident = incidentsById[expectedLaneItem.id];

            if (typeof expectedLaneItem.initialValue === 'object') {
              if (
                !compareObjects(
                  expectedLaneItem.initialValue,
                  incident.initialValue,
                )
              ) {
                errors.push({
                  type: `LANES: compo initial value missmatch`,
                  expected: expectedLaneItem.initialValue,
                  actual: incident.initialValue,
                  expectedObject: expectedLaneItem,
                  actualObject: actualLaneItem,
                });
              }
            } else {
              if (expectedLaneItem.initialValue !== incident.initialValue) {
                errors.push({
                  type: `LANES: initial value missmatch`,
                  expected: expectedLaneItem.initialValue,
                  actual: incident.initialValue,
                  expectedObject: expectedLaneItem,
                  actualObject: actualLaneItem,
                });
              }
            }

            if (expectedLaneItem.hasOwnProperty('targetValue')) {
              if (typeof expectedLaneItem.targetValue === 'object') {
                if (
                  !compareObjects(
                    expectedLaneItem.targetValue,
                    incident.animatedAttributeValue,
                  )
                ) {
                  errors.push({
                    type: `LANES: compo targetValue missmatch`,
                    expected: expectedLaneItem.targetValue,
                    actual: incident.animatedAttributeValue,
                    expectedObject: expectedLaneItem,
                    actualObject: actualLaneItem,
                  });
                }
              } else {
                if (
                  expectedLaneItem.targetValue !==
                  incident.animatedAttributeValue
                ) {
                  errors.push({
                    type: `LANES: targetValue value missmatch`,
                    expected: expectedLaneItem.targetValue,
                    actual: incident.animatedAttributeValue,
                    expectedObject: expectedLaneItem,
                    actualObject: actualLaneItem,
                  });
                }
              }
            }
          }
        }
      }
    }
    return errors;
  }

  /**
   * @param {array} expected - in the form of:
   * [{
   *      id
   *      millisecond
   * }, ...]
   * @param {array} actual - in the form of:
   * [{
   *      id
   *      millisecond
   * }, ...]
   * */
  testClipLanes(expected, actual) {
    const errors = [];

    if (expected.length !== actual.length) {
      errors.push({
        type: `CLIP LANES: different size of clip lane items`,
        expected: expected.length,
        actual: actual.length,
        expectedLane: expected,
        actualLane: actual,
      });
      return errors;
    }

    for (let i = 0; i < expected.length; i++) {
      if (expected[i].id !== actual[i].id) {
        errors.push({
          type: `CLIP LANES: invalid id of clip lane item`,
          expected: expected[i].id,
          actual: actual[i].id,
          expectedLaneItem: expected[i],
          actualLaneItem: actual[i],
        });
      }
      if (expected[i].millisecond !== actual[i].millisecond) {
        errors.push({
          type: `CLIP LANES: invalid millisecond of clip lane item`,
          expected: expected[i].millisecond,
          actual: actual[i].millisecond,
          expectedLaneItem: expected[i],
          actualLaneItem: actual[i],
        });
      }
    }
    return errors;
  }
}

export default Tester;
